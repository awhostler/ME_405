
ME405lab0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000084  00800200  000034f8  0000358c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000034f8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000017bc  00800284  00800284  00003610  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003610  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003640  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000658  00000000  00000000  00003680  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000aeca  00000000  00000000  00003cd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000378a  00000000  00000000  0000eba2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000043ba  00000000  00000000  0001232c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001238  00000000  00000000  000166e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002673  00000000  00000000  00017920  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005f2a  00000000  00000000  00019f93  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000528  00000000  00000000  0001febd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0d c2       	rjmp	.+1050   	; 0x41c <__ctors_end>
       2:	00 00       	nop
       4:	2a c2       	rjmp	.+1108   	; 0x45a <__bad_interrupt>
       6:	00 00       	nop
       8:	28 c2       	rjmp	.+1104   	; 0x45a <__bad_interrupt>
       a:	00 00       	nop
       c:	26 c2       	rjmp	.+1100   	; 0x45a <__bad_interrupt>
       e:	00 00       	nop
      10:	24 c2       	rjmp	.+1096   	; 0x45a <__bad_interrupt>
      12:	00 00       	nop
      14:	22 c2       	rjmp	.+1092   	; 0x45a <__bad_interrupt>
      16:	00 00       	nop
      18:	20 c2       	rjmp	.+1088   	; 0x45a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	1e c2       	rjmp	.+1084   	; 0x45a <__bad_interrupt>
      1e:	00 00       	nop
      20:	1c c2       	rjmp	.+1080   	; 0x45a <__bad_interrupt>
      22:	00 00       	nop
      24:	1a c2       	rjmp	.+1076   	; 0x45a <__bad_interrupt>
      26:	00 00       	nop
      28:	18 c2       	rjmp	.+1072   	; 0x45a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	16 c2       	rjmp	.+1068   	; 0x45a <__bad_interrupt>
      2e:	00 00       	nop
      30:	14 c2       	rjmp	.+1064   	; 0x45a <__bad_interrupt>
      32:	00 00       	nop
      34:	12 c2       	rjmp	.+1060   	; 0x45a <__bad_interrupt>
      36:	00 00       	nop
      38:	10 c2       	rjmp	.+1056   	; 0x45a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	0e c2       	rjmp	.+1052   	; 0x45a <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c c2       	rjmp	.+1048   	; 0x45a <__bad_interrupt>
      42:	00 00       	nop
      44:	0a c2       	rjmp	.+1044   	; 0x45a <__bad_interrupt>
      46:	00 00       	nop
      48:	08 c2       	rjmp	.+1040   	; 0x45a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	06 c2       	rjmp	.+1036   	; 0x45a <__bad_interrupt>
      4e:	00 00       	nop
      50:	04 c2       	rjmp	.+1032   	; 0x45a <__bad_interrupt>
      52:	00 00       	nop
      54:	02 c2       	rjmp	.+1028   	; 0x45a <__bad_interrupt>
      56:	00 00       	nop
      58:	00 c2       	rjmp	.+1024   	; 0x45a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	fe c1       	rjmp	.+1020   	; 0x45a <__bad_interrupt>
      5e:	00 00       	nop
      60:	fc c1       	rjmp	.+1016   	; 0x45a <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 80 15 	jmp	0x2b00	; 0x2b00 <__vector_25>
      68:	f8 c1       	rjmp	.+1008   	; 0x45a <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f6 c1       	rjmp	.+1004   	; 0x45a <__bad_interrupt>
      6e:	00 00       	nop
      70:	f4 c1       	rjmp	.+1000   	; 0x45a <__bad_interrupt>
      72:	00 00       	nop
      74:	f2 c1       	rjmp	.+996    	; 0x45a <__bad_interrupt>
      76:	00 00       	nop
      78:	f0 c1       	rjmp	.+992    	; 0x45a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	ee c1       	rjmp	.+988    	; 0x45a <__bad_interrupt>
      7e:	00 00       	nop
      80:	ec c1       	rjmp	.+984    	; 0x45a <__bad_interrupt>
      82:	00 00       	nop
      84:	ea c1       	rjmp	.+980    	; 0x45a <__bad_interrupt>
      86:	00 00       	nop
      88:	e8 c1       	rjmp	.+976    	; 0x45a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e6 c1       	rjmp	.+972    	; 0x45a <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 d8 15 	jmp	0x2bb0	; 0x2bb0 <__vector_36>
      94:	e2 c1       	rjmp	.+964    	; 0x45a <__bad_interrupt>
      96:	00 00       	nop
      98:	e0 c1       	rjmp	.+960    	; 0x45a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	de c1       	rjmp	.+956    	; 0x45a <__bad_interrupt>
      9e:	00 00       	nop
      a0:	dc c1       	rjmp	.+952    	; 0x45a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	da c1       	rjmp	.+948    	; 0x45a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	d8 c1       	rjmp	.+944    	; 0x45a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	d6 c1       	rjmp	.+940    	; 0x45a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	d4 c1       	rjmp	.+936    	; 0x45a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	d2 c1       	rjmp	.+932    	; 0x45a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	d0 c1       	rjmp	.+928    	; 0x45a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	48 c5       	rjmp	.+2704   	; 0xb4e <__vector_47>
      be:	00 00       	nop
      c0:	cc c1       	rjmp	.+920    	; 0x45a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ca c1       	rjmp	.+916    	; 0x45a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	c8 c1       	rjmp	.+912    	; 0x45a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	78 13       	cpse	r23, r24
      ce:	7b 13       	cpse	r23, r27
      d0:	7e 13       	cpse	r23, r30
      d2:	81 13       	cpse	r24, r17
      d4:	ac 13       	cpse	r26, r28
      d6:	ac 13       	cpse	r26, r28
      d8:	84 13       	cpse	r24, r20
      da:	94 13       	cpse	r25, r20
      dc:	9b 13       	cpse	r25, r27
      de:	a5 13       	cpse	r26, r21
      e0:	a9 13       	cpse	r26, r25
      e2:	a2 13       	cpse	r26, r18

000000e4 <__trampolines_end>:
      e4:	54 68       	ori	r21, 0x84	; 132
      e6:	65 20       	and	r6, r5
      e8:	41 2f       	mov	r20, r17
      ea:	44 20       	and	r4, r4
      ec:	63 6f       	ori	r22, 0xF3	; 243
      ee:	6e 76       	andi	r22, 0x6E	; 110
      f0:	65 72       	andi	r22, 0x25	; 37
      f2:	74 65       	ori	r23, 0x54	; 84
      f4:	72 20       	and	r7, r2
      f6:	72 65       	ori	r23, 0x52	; 82
      f8:	67 69       	ori	r22, 0x97	; 151
      fa:	73 74       	andi	r23, 0x43	; 67
      fc:	65 72       	andi	r22, 0x25	; 37
      fe:	73 20       	and	r7, r3
     100:	68 61       	ori	r22, 0x18	; 24
     102:	76 65       	ori	r23, 0x56	; 86
     104:	20 74       	andi	r18, 0x40	; 64
     106:	68 65       	ori	r22, 0x58	; 88
     108:	73 65       	ori	r23, 0x53	; 83
     10a:	20 69       	ori	r18, 0x90	; 144
     10c:	6e 70       	andi	r22, 0x0E	; 14
     10e:	75 74       	andi	r23, 0x45	; 69
     110:	73 3a       	cpi	r23, 0xA3	; 163
	...

00000113 <_ZZ16print_all_sharesP8emstreamE3__c_1>:
     113:	4e 6f 20 73 68 61 72 65 64 20 64 61 74 61 20 69     No shared data i
     123:	74 65 6d 73 20 74 6f 20 70 72 69 6e 74 00           tems to print.

00000131 <_ZZ16print_all_sharesP8emstreamE3__c_0>:
     131:	2d 2d 2d 2d 20 20 20 20 20 20 20 20 20 20 20 20     ----            
     141:	2d 2d 2d 2d 20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d     ----    --------
     151:	2d 2d 00                                            --.

00000154 <_ZZ16print_all_sharesP8emstreamE3__c>:
     154:	53 68 61 72 65 2f 51 75 65 75 65 20 20 20 20 20     Share/Queue     
     164:	54 79 70 65 20 20 20 20 46 72 65 65 2f 54 6f 74     Type    Free/Tot
     174:	61 6c 00                                            al.

00000177 <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c_1>:
     177:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     187:	61 73 6b 20 22 00                                   ask ".

0000018d <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c>:
     18d:	54 61 73 6b 20 22 00                                Task ".

00000194 <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c_0>:
     194:	22 20 63 72 65 61 74 65 64 2c 20 73 74 61 63 6b     " created, stack
     1a4:	20 61 74 20 30 78 00                                 at 0x.

000001ab <_ZZN8TaskBase19print_stack_in_listEP8emstreamE3__c>:
     1ab:	54 61 73 6b 3a 20 00                                Task: .

000001b2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     1b2:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000001bd <_ZZ15print_task_listP8emstreamE3__c_7>:
     1bd:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000001c8 <_ZZ15print_task_listP8emstreamE3__c_8>:
     1c8:	2f 00                                               /.

000001ca <_ZZ15print_task_listP8emstreamE3__c_9>:
     1ca:	09 09 2d 00                                         ..-.

000001ce <_ZZ15print_task_listP8emstreamE3__c_4>:
     1ce:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000001df <_ZZ15print_task_listP8emstreamE3__c_5>:
     1df:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000001eb <_ZZ15print_task_listP8emstreamE3__c_6>:
     1eb:	09 2d 2d 2d 2d 00                                   .----.

000001f1 <_ZZ15print_task_listP8emstreamE3__c_1>:
     1f1:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000202 <_ZZ15print_task_listP8emstreamE3__c_2>:
     202:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000020e <_ZZ15print_task_listP8emstreamE3__c_3>:
     20e:	09 52 75 6e 73 00                                   .Runs.

00000214 <_ZZ15print_task_listP8emstreamE3__c>:
     214:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000021f <_ZZ15print_task_listP8emstreamE3__c_0>:
     21f:	09 53 74 61 63 6b 00                                .Stack.

00000226 <_ZZN8TaskBase12print_statusER8emstreamE3__c>:
     226:	09 00                                               ..

00000228 <_ZZN8TaskBase12print_statusER8emstreamE3__c_0>:
     228:	09 00                                               ..

0000022a <_ZZN8TaskBase12print_statusER8emstreamE3__c_1>:
     22a:	2f 00                                               /.

0000022c <_ZZN8TaskBase12print_statusER8emstreamE3__c_2>:
     22c:	09 00                                               ..

0000022e <_ZZN8TaskBase12print_statusER8emstreamE3__c_3>:
     22e:	09 00                                               ..

00000230 <_ZZ15hex_dump_memoryPhS_P8emstreamE3__c>:
     230:	20 20 00                                              .

00000233 <_ZZ4mainE3__c>:
     233:	4d 45 34 30 35 20 4c 61 62 20 31 20 53 74 61 72     ME405 Lab 1 Star
     243:	74 69 6e 67 20 50 72 6f 67 72 61 6d 00              ting Program.

00000250 <_ZZN9task_user11show_statusEvE3__c>:
     250:	4d 45 34 30 35 20 4c 61 62 20 31 20 55 6e 6d 6f     ME405 Lab 1 Unmo
     260:	64 69 66 69 65 64 20 50 72 6f 67 72 61 6d 20 56     dified Program V
     270:	30 2e 30 31 20 00                                   0.01 .

00000276 <_ZZN9task_user11show_statusEvE3__c_0>:
     276:	41 70 72 20 20 37 20 32 30 31 36 00                 Apr  7 2016.

00000282 <_ZZN9task_user11show_statusEvE3__c_1>:
     282:	53 79 73 74 65 6d 20 74 69 6d 65 3a 20 00           System time: .

00000290 <_ZZN9task_user11show_statusEvE3__c_2>:
     290:	2c 20 48 65 61 70 3a 20 00                          , Heap: .

00000299 <_ZZN9task_user11show_statusEvE3__c_3>:
     299:	2c 20 4f 43 52 35 41 3a 20 00                       , OCR5A: .

000002a3 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     2a3:	20 20 68 3a 20 20 20 20 20 48 41 4c 50 21 00          h:     HALP!.

000002b2 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     2b2:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     2c2:	68 65 20 41 56 52 00                                he AVR.

000002c9 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     2c9:	20 20 6e 3a 20 20 20 20 20 45 6e 74 65 72 20 61       n:     Enter a
     2d9:	20 6e 75 6d 62 65 72 20 28 64 65 6d 6f 29 00         number (demo).

000002e8 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     2e8:	20 20 64 3a 20 20 20 20 20 53 74 61 63 6b 20 64       d:     Stack d
     2f8:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000306 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     306:	20 20 73 3a 20 20 20 20 20 56 65 72 73 69 6f 6e       s:     Version
     316:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     326:	6d 61 74 69 6f 6e 00                                mation.

0000032d <_ZZN9task_user18print_help_messageEvE3__c_1>:
     32d:	20 20 74 3a 20 20 20 20 20 53 68 6f 77 20 74 68       t:     Show th
     33d:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000034e <_ZZN9task_user18print_help_messageEvE3__c>:
     34e:	4d 45 34 30 35 20 4c 61 62 20 31 20 55 6e 6d 6f     ME405 Lab 1 Unmo
     35e:	64 69 66 69 65 64 20 50 72 6f 67 72 61 6d 20 56     dified Program V
     36e:	30 2e 30 31 20 00                                   0.01 .

00000374 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     374:	20 68 65 6c 70 00                                    help.

0000037a <_ZZN9task_user3runEvE3__c_6>:
     37a:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     38a:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000397 <_ZZN9task_user3runEvE3__c_4>:
     397:	3c 69 6e 76 61 6c 69 64 20 63 68 61 72 20 22 00     <invalid char ".

000003a7 <_ZZN9task_user3runEvE3__c_5>:
     3a7:	22 3e 00                                            ">.

000003aa <_ZZN9task_user3runEvE3__c_3>:
     3aa:	4e 75 6d 62 65 72 20 65 6e 74 65 72 65 64 3a 20     Number entered: 
	...

000003bb <_ZZN9task_user3runEvE3__c_2>:
     3bb:	22 3a 20 57 54 46 3f 00                             ": WTF?.

000003c3 <_ZZN9task_user3runEvE3__c_1>:
     3c3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000003d1 <_ZZN9task_user3runEvE3__c_0>:
     3d1:	45 6e 74 65 72 20 64 65 63 69 6d 61 6c 20 6e 75     Enter decimal nu
     3e1:	6d 65 72 69 63 20 64 69 67 69 74 73 2c 20 74 68     meric digits, th
     3f1:	65 6e 20 52 45 54 55 52 4e 20 6f 72 20 45 53 43     en RETURN or ESC
	...

00000402 <_ZZN9task_user3runEvE3__c>:
     402:	50 72 65 73 73 20 27 68 27 20 6f 72 20 27 3f 27     Press 'h' or '?'
     412:	20 66 6f 72 20 68 65 6c 70 00                        for help.

0000041c <__ctors_end>:
     41c:	11 24       	eor	r1, r1
     41e:	1f be       	out	0x3f, r1	; 63
     420:	cf ef       	ldi	r28, 0xFF	; 255
     422:	d1 e2       	ldi	r29, 0x21	; 33
     424:	de bf       	out	0x3e, r29	; 62
     426:	cd bf       	out	0x3d, r28	; 61

00000428 <__do_copy_data>:
     428:	12 e0       	ldi	r17, 0x02	; 2
     42a:	a0 e0       	ldi	r26, 0x00	; 0
     42c:	b2 e0       	ldi	r27, 0x02	; 2
     42e:	e8 ef       	ldi	r30, 0xF8	; 248
     430:	f4 e3       	ldi	r31, 0x34	; 52
     432:	00 e0       	ldi	r16, 0x00	; 0
     434:	0b bf       	out	0x3b, r16	; 59
     436:	02 c0       	rjmp	.+4      	; 0x43c <__do_copy_data+0x14>
     438:	07 90       	elpm	r0, Z+
     43a:	0d 92       	st	X+, r0
     43c:	a4 38       	cpi	r26, 0x84	; 132
     43e:	b1 07       	cpc	r27, r17
     440:	d9 f7       	brne	.-10     	; 0x438 <__do_copy_data+0x10>

00000442 <__do_clear_bss>:
     442:	2a e1       	ldi	r18, 0x1A	; 26
     444:	a4 e8       	ldi	r26, 0x84	; 132
     446:	b2 e0       	ldi	r27, 0x02	; 2
     448:	01 c0       	rjmp	.+2      	; 0x44c <.do_clear_bss_start>

0000044a <.do_clear_bss_loop>:
     44a:	1d 92       	st	X+, r1

0000044c <.do_clear_bss_start>:
     44c:	a0 34       	cpi	r26, 0x40	; 64
     44e:	b2 07       	cpc	r27, r18
     450:	e1 f7       	brne	.-8      	; 0x44a <.do_clear_bss_loop>
     452:	0e 94 30 16 	call	0x2c60	; 0x2c60 <main>
     456:	0c 94 7a 1a 	jmp	0x34f4	; 0x34f4 <_exit>

0000045a <__bad_interrupt>:
     45a:	d2 cd       	rjmp	.-1116   	; 0x0 <__vectors>

0000045c <_ZN3adcC1EP8emstream>:
 *  @param p_serial_port A pointer to the serial port which writes debugging info. 
 */

adc::adc (emstream* p_serial_port)
{
	ptr_to_serial = p_serial_port;
     45c:	fc 01       	movw	r30, r24
     45e:	71 83       	std	Z+1, r23	; 0x01
     460:	60 83       	st	Z, r22
	// Do A/D configuration in weird non-readable ways. The student's job is to redo 
	// this by writing good, readable, sensible code rather than obfuscated malarkey.
	//
	// Please do NOT waste time trying to reverse engineer this code; doing so is a
	// complete waste of time! It's easier and quicker to start from scratch. 
	ADMUX = 0b00000000; //clear settings
     462:	ec e7       	ldi	r30, 0x7C	; 124
     464:	f0 e0       	ldi	r31, 0x00	; 0
     466:	10 82       	st	Z, r1
	ADMUX |= (1<<REFS0); // SETS COMPARATOR REFERENCE TO VCC
     468:	80 81       	ld	r24, Z
     46a:	80 64       	ori	r24, 0x40	; 64
     46c:	80 83       	st	Z, r24
	
	ADCSRA= (0b00000000)|(1<<ADEN); // Clear settings, but enable A/D converter hardware
     46e:	ea e7       	ldi	r30, 0x7A	; 122
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	80 e8       	ldi	r24, 0x80	; 128
     474:	80 83       	st	Z, r24
	ADCSRA|= (1<<ADPS0)|(1<<ADPS2); // Set A/D clock prescaler to 32
     476:	80 81       	ld	r24, Z
     478:	85 60       	ori	r24, 0x05	; 5
     47a:	80 83       	st	Z, r24
     47c:	08 95       	ret

0000047e <_ZN3adc9read_onceEh>:
uint16_t adc::read_once (uint8_t ch)
{
	// Since writing A/D code is part of an assignment, here's a well-documented piece of readable code. 
	//
	
	if(!(ch&0b00001111))DBG (ptr_to_serial, "A/D input invalid" << endl); // Check input is valid
     47e:	86 2f       	mov	r24, r22
     480:	8f 70       	andi	r24, 0x0F	; 15
     482:	09 f0       	breq	.+2      	; 0x486 <_ZN3adc9read_onceEh+0x8>
	else ch &= 0b00001111; // Mask 4 lsb of input (just in case)
     484:	68 2f       	mov	r22, r24
	ADMUX &= ~(1<<MUX0|1<<MUX1|1<<MUX2|1<<MUX3); //Change mux selection to zero
     486:	ec e7       	ldi	r30, 0x7C	; 124
     488:	f0 e0       	ldi	r31, 0x00	; 0
     48a:	80 81       	ld	r24, Z
     48c:	80 7f       	andi	r24, 0xF0	; 240
     48e:	80 83       	st	Z, r24
	ADMUX = (ADMUX|(0b00000111&ch)); //Set lower bits of ADMUX to match input
     490:	80 81       	ld	r24, Z
     492:	67 70       	andi	r22, 0x07	; 7
     494:	68 2b       	or	r22, r24
     496:	60 83       	st	Z, r22
	ADMUX |= (1<<ADLAR);
     498:	80 81       	ld	r24, Z
     49a:	80 62       	ori	r24, 0x20	; 32
     49c:	80 83       	st	Z, r24
	
	ADCSRA &= ~(1<<ADATE); //turn off conversion auto-triggering datasheet page 285
     49e:	ea e7       	ldi	r30, 0x7A	; 122
     4a0:	f0 e0       	ldi	r31, 0x00	; 0
     4a2:	80 81       	ld	r24, Z
     4a4:	8f 7d       	andi	r24, 0xDF	; 223
     4a6:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADSC); //use ADSC to start conversion, turns auto off when done.
     4a8:	80 81       	ld	r24, Z
     4aa:	80 64       	ori	r24, 0x40	; 64
     4ac:	80 83       	st	Z, r24
	
	while((ADCSRA)&(1<<ADSC))
     4ae:	80 81       	ld	r24, Z
     4b0:	86 ff       	sbrs	r24, 6
     4b2:	0c c0       	rjmp	.+24     	; 0x4cc <_ZN3adc9read_onceEh+0x4e>
	{
	time++;
     4b4:	80 91 84 02 	lds	r24, 0x0284
     4b8:	90 91 85 02 	lds	r25, 0x0285
     4bc:	01 96       	adiw	r24, 0x01	; 1
     4be:	90 93 85 02 	sts	0x0285, r25
     4c2:	80 93 84 02 	sts	0x0284, r24
	ADMUX |= (1<<ADLAR);
	
	ADCSRA &= ~(1<<ADATE); //turn off conversion auto-triggering datasheet page 285
	ADCSRA |= (1<<ADSC); //use ADSC to start conversion, turns auto off when done.
	
	while((ADCSRA)&(1<<ADSC))
     4c6:	80 81       	ld	r24, Z
     4c8:	86 fd       	sbrc	r24, 6
     4ca:	f4 cf       	rjmp	.-24     	; 0x4b4 <_ZN3adc9read_onceEh+0x36>
	{
	time++;
	}
	sample = (ADCH<<2);
     4cc:	80 91 79 00 	lds	r24, 0x0079
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	88 0f       	add	r24, r24
     4d4:	99 1f       	adc	r25, r25
     4d6:	88 0f       	add	r24, r24
     4d8:	99 1f       	adc	r25, r25
     4da:	90 93 87 02 	sts	0x0287, r25
     4de:	80 93 86 02 	sts	0x0286, r24
	
	return sample;

}
     4e2:	08 95       	ret

000004e4 <_ZN3adc16read_oversampledEhh>:
 *  @param   samples How many samples to take from the A/D converter
 *  @return  A/D conversion result, will be between 0 and 1024.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples)
{
     4e4:	cf 92       	push	r12
     4e6:	df 92       	push	r13
     4e8:	ef 92       	push	r14
     4ea:	ff 92       	push	r15
     4ec:	0f 93       	push	r16
     4ee:	1f 93       	push	r17
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	7c 01       	movw	r14, r24
     4f6:	d6 2e       	mov	r13, r22
     4f8:	c4 2e       	mov	r12, r20
	DBG (ptr_to_serial, "All your readings are belong to us" << endl);
	
	sampleavg = 0;
     4fa:	10 92 89 02 	sts	0x0289, r1
     4fe:	10 92 88 02 	sts	0x0288, r1
	for(int i = 0; i < samples;i ++)
     502:	04 2f       	mov	r16, r20
     504:	10 e0       	ldi	r17, 0x00	; 0
     506:	10 16       	cp	r1, r16
     508:	11 06       	cpc	r1, r17
     50a:	9c f4       	brge	.+38     	; 0x532 <_ZN3adc16read_oversampledEhh+0x4e>
     50c:	c0 e0       	ldi	r28, 0x00	; 0
     50e:	d0 e0       	ldi	r29, 0x00	; 0
	{
		sampleavg += read_once(channel);
     510:	6d 2d       	mov	r22, r13
     512:	c7 01       	movw	r24, r14
     514:	b4 df       	rcall	.-152    	; 0x47e <_ZN3adc9read_onceEh>
     516:	20 91 88 02 	lds	r18, 0x0288
     51a:	30 91 89 02 	lds	r19, 0x0289
     51e:	82 0f       	add	r24, r18
     520:	93 1f       	adc	r25, r19
     522:	90 93 89 02 	sts	0x0289, r25
     526:	80 93 88 02 	sts	0x0288, r24
uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples)
{
	DBG (ptr_to_serial, "All your readings are belong to us" << endl);
	
	sampleavg = 0;
	for(int i = 0; i < samples;i ++)
     52a:	21 96       	adiw	r28, 0x01	; 1
     52c:	c0 17       	cp	r28, r16
     52e:	d1 07       	cpc	r29, r17
     530:	79 f7       	brne	.-34     	; 0x510 <_ZN3adc16read_oversampledEhh+0x2c>
	{
		sampleavg += read_once(channel);
	}
	sampleavg /= samples;
     532:	6c 2d       	mov	r22, r12
     534:	70 e0       	ldi	r23, 0x00	; 0
     536:	80 91 88 02 	lds	r24, 0x0288
     53a:	90 91 89 02 	lds	r25, 0x0289
     53e:	0e 94 89 19 	call	0x3312	; 0x3312 <__udivmodhi4>
     542:	cb 01       	movw	r24, r22
     544:	70 93 89 02 	sts	0x0289, r23
     548:	60 93 88 02 	sts	0x0288, r22
	
	return (sampleavg);
}
     54c:	df 91       	pop	r29
     54e:	cf 91       	pop	r28
     550:	1f 91       	pop	r17
     552:	0f 91       	pop	r16
     554:	ff 90       	pop	r15
     556:	ef 90       	pop	r14
     558:	df 90       	pop	r13
     55a:	cf 90       	pop	r12
     55c:	08 95       	ret

0000055e <_ZlsR8emstreamR3adc>:
 *  @return  A reference to the same serial device on which we write information.
 *           This is used to string together things to write with @c << operators
 */

emstream& operator << (emstream& serpt, adc& a2d)
{
     55e:	cf 92       	push	r12
     560:	df 92       	push	r13
     562:	ef 92       	push	r14
     564:	ff 92       	push	r15
     566:	0f 93       	push	r16
     568:	1f 93       	push	r17
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	ec 01       	movw	r28, r24
     570:	8b 01       	movw	r16, r22
	// Right now this operator doesn't do anything useful. It should be made useful
	serpt << PMS ("The A/D converter registers have these inputs:") 
		  << a2d.read_oversampled (0,8) << endl
          << a2d.read_oversampled (1,8) << endl;
     572:	48 e0       	ldi	r20, 0x08	; 8
     574:	61 e0       	ldi	r22, 0x01	; 1
     576:	c8 01       	movw	r24, r16
     578:	b5 df       	rcall	.-150    	; 0x4e4 <_ZN3adc16read_oversampledEhh>
     57a:	7c 01       	movw	r14, r24

emstream& operator << (emstream& serpt, adc& a2d)
{
	// Right now this operator doesn't do anything useful. It should be made useful
	serpt << PMS ("The A/D converter registers have these inputs:") 
		  << a2d.read_oversampled (0,8) << endl
     57c:	48 e0       	ldi	r20, 0x08	; 8
     57e:	60 e0       	ldi	r22, 0x00	; 0
     580:	c8 01       	movw	r24, r16
     582:	b0 df       	rcall	.-160    	; 0x4e4 <_ZN3adc16read_oversampledEhh>
     584:	6c 01       	movw	r12, r24
 */

emstream& operator << (emstream& serpt, adc& a2d)
{
	// Right now this operator doesn't do anything useful. It should be made useful
	serpt << PMS ("The A/D converter registers have these inputs:") 
     586:	6b e0       	ldi	r22, 0x0B	; 11
     588:	ce 01       	movw	r24, r28
     58a:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
     58e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     590:	64 ee       	ldi	r22, 0xE4	; 228
     592:	70 e0       	ldi	r23, 0x00	; 0
     594:	0e 94 35 13 	call	0x266a	; 0x266a <_ZN8emstream4putsEPKc>
		  << a2d.read_oversampled (0,8) << endl
     598:	b6 01       	movw	r22, r12
     59a:	c8 01       	movw	r24, r16
     59c:	0e 94 b0 13 	call	0x2760	; 0x2760 <_ZN8emstreamlsEj>
     5a0:	66 e0       	ldi	r22, 0x06	; 6
     5a2:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
          << a2d.read_oversampled (1,8) << endl;
     5a6:	b7 01       	movw	r22, r14
     5a8:	0e 94 b0 13 	call	0x2760	; 0x2760 <_ZN8emstreamlsEj>
     5ac:	66 e0       	ldi	r22, 0x06	; 6
     5ae:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
   

	return (serpt);
     5b2:	ce 01       	movw	r24, r28
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
     5b8:	1f 91       	pop	r17
     5ba:	0f 91       	pop	r16
     5bc:	ff 90       	pop	r15
     5be:	ef 90       	pop	r14
     5c0:	df 90       	pop	r13
     5c2:	cf 90       	pop	r12
     5c4:	08 95       	ret

000005c6 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5c6:	0f 93       	push	r16
     5c8:	1f 93       	push	r17
     5ca:	cf 93       	push	r28
     5cc:	df 93       	push	r29
     5ce:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     5d0:	e3 d6       	rcall	.+3526   	; 0x1398 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     5d2:	80 91 8a 02 	lds	r24, 0x028A
     5d6:	81 11       	cpse	r24, r1
     5d8:	1d c0       	rjmp	.+58     	; 0x614 <pvPortMalloc+0x4e>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     5da:	ef e8       	ldi	r30, 0x8F	; 143
     5dc:	f2 e0       	ldi	r31, 0x02	; 2
     5de:	84 e9       	ldi	r24, 0x94	; 148
     5e0:	92 e0       	ldi	r25, 0x02	; 2
     5e2:	91 83       	std	Z+1, r25	; 0x01
     5e4:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     5e6:	13 82       	std	Z+3, r1	; 0x03
     5e8:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     5ea:	eb e8       	ldi	r30, 0x8B	; 139
     5ec:	f2 e0       	ldi	r31, 0x02	; 2
     5ee:	87 e3       	ldi	r24, 0x37	; 55
     5f0:	97 e1       	ldi	r25, 0x17	; 23
     5f2:	93 83       	std	Z+3, r25	; 0x03
     5f4:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     5f6:	11 82       	std	Z+1, r1	; 0x01
     5f8:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     5fa:	a3 e9       	ldi	r26, 0x93	; 147
     5fc:	b2 e0       	ldi	r27, 0x02	; 2
     5fe:	14 96       	adiw	r26, 0x04	; 4
     600:	9c 93       	st	X, r25
     602:	8e 93       	st	-X, r24
     604:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     606:	12 96       	adiw	r26, 0x02	; 2
     608:	fc 93       	st	X, r31
     60a:	ee 93       	st	-X, r30
     60c:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	80 93 8a 02 	sts	0x028A, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     614:	20 97       	sbiw	r28, 0x00	; 0
     616:	09 f4       	brne	.+2      	; 0x61a <pvPortMalloc+0x54>
     618:	5f c0       	rjmp	.+190    	; 0x6d8 <pvPortMalloc+0x112>
		{
			xWantedSize += heapSTRUCT_SIZE;
     61a:	9e 01       	movw	r18, r28
     61c:	2c 5f       	subi	r18, 0xFC	; 252
     61e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     620:	23 96       	adiw	r28, 0x03	; 3
     622:	c6 33       	cpi	r28, 0x36	; 54
     624:	d7 41       	sbci	r29, 0x17	; 23
     626:	08 f0       	brcs	.+2      	; 0x62a <pvPortMalloc+0x64>
     628:	5a c0       	rjmp	.+180    	; 0x6de <pvPortMalloc+0x118>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     62a:	e0 91 8f 02 	lds	r30, 0x028F
     62e:	f0 91 90 02 	lds	r31, 0x0290

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     632:	af e8       	ldi	r26, 0x8F	; 143
     634:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     636:	02 c0       	rjmp	.+4      	; 0x63c <pvPortMalloc+0x76>
     638:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     63a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     63c:	82 81       	ldd	r24, Z+2	; 0x02
     63e:	93 81       	ldd	r25, Z+3	; 0x03
     640:	82 17       	cp	r24, r18
     642:	93 07       	cpc	r25, r19
     644:	20 f4       	brcc	.+8      	; 0x64e <pvPortMalloc+0x88>
     646:	80 81       	ld	r24, Z
     648:	91 81       	ldd	r25, Z+1	; 0x01
     64a:	00 97       	sbiw	r24, 0x00	; 0
     64c:	a9 f7       	brne	.-22     	; 0x638 <pvPortMalloc+0x72>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     64e:	c2 e0       	ldi	r28, 0x02	; 2
     650:	eb 38       	cpi	r30, 0x8B	; 139
     652:	fc 07       	cpc	r31, r28
     654:	09 f4       	brne	.+2      	; 0x658 <pvPortMalloc+0x92>
     656:	46 c0       	rjmp	.+140    	; 0x6e4 <pvPortMalloc+0x11e>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     658:	cd 91       	ld	r28, X+
     65a:	dc 91       	ld	r29, X
     65c:	11 97       	sbiw	r26, 0x01	; 1
     65e:	8e 01       	movw	r16, r28
     660:	0c 5f       	subi	r16, 0xFC	; 252
     662:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     664:	80 81       	ld	r24, Z
     666:	91 81       	ldd	r25, Z+1	; 0x01
     668:	8d 93       	st	X+, r24
     66a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     66c:	82 81       	ldd	r24, Z+2	; 0x02
     66e:	93 81       	ldd	r25, Z+3	; 0x03
     670:	82 1b       	sub	r24, r18
     672:	93 0b       	sbc	r25, r19
     674:	89 30       	cpi	r24, 0x09	; 9
     676:	91 05       	cpc	r25, r1
     678:	10 f1       	brcs	.+68     	; 0x6be <pvPortMalloc+0xf8>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     67a:	bf 01       	movw	r22, r30
     67c:	62 0f       	add	r22, r18
     67e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     680:	db 01       	movw	r26, r22
     682:	13 96       	adiw	r26, 0x03	; 3
     684:	9c 93       	st	X, r25
     686:	8e 93       	st	-X, r24
     688:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     68a:	33 83       	std	Z+3, r19	; 0x03
     68c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     68e:	12 96       	adiw	r26, 0x02	; 2
     690:	4d 91       	ld	r20, X+
     692:	5c 91       	ld	r21, X
     694:	13 97       	sbiw	r26, 0x03	; 3
     696:	8f e8       	ldi	r24, 0x8F	; 143
     698:	92 e0       	ldi	r25, 0x02	; 2
     69a:	01 c0       	rjmp	.+2      	; 0x69e <pvPortMalloc+0xd8>
     69c:	cd 01       	movw	r24, r26
     69e:	ec 01       	movw	r28, r24
     6a0:	a8 81       	ld	r26, Y
     6a2:	b9 81       	ldd	r27, Y+1	; 0x01
     6a4:	12 96       	adiw	r26, 0x02	; 2
     6a6:	2d 91       	ld	r18, X+
     6a8:	3c 91       	ld	r19, X
     6aa:	13 97       	sbiw	r26, 0x03	; 3
     6ac:	24 17       	cp	r18, r20
     6ae:	35 07       	cpc	r19, r21
     6b0:	a8 f3       	brcs	.-22     	; 0x69c <pvPortMalloc+0xd6>
     6b2:	eb 01       	movw	r28, r22
     6b4:	b9 83       	std	Y+1, r27	; 0x01
     6b6:	a8 83       	st	Y, r26
     6b8:	dc 01       	movw	r26, r24
     6ba:	6d 93       	st	X+, r22
     6bc:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     6be:	80 91 00 02 	lds	r24, 0x0200
     6c2:	90 91 01 02 	lds	r25, 0x0201
     6c6:	22 81       	ldd	r18, Z+2	; 0x02
     6c8:	33 81       	ldd	r19, Z+3	; 0x03
     6ca:	82 1b       	sub	r24, r18
     6cc:	93 0b       	sbc	r25, r19
     6ce:	90 93 01 02 	sts	0x0201, r25
     6d2:	80 93 00 02 	sts	0x0200, r24
     6d6:	08 c0       	rjmp	.+16     	; 0x6e8 <pvPortMalloc+0x122>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     6d8:	00 e0       	ldi	r16, 0x00	; 0
     6da:	10 e0       	ldi	r17, 0x00	; 0
     6dc:	05 c0       	rjmp	.+10     	; 0x6e8 <pvPortMalloc+0x122>
     6de:	00 e0       	ldi	r16, 0x00	; 0
     6e0:	10 e0       	ldi	r17, 0x00	; 0
     6e2:	02 c0       	rjmp	.+4      	; 0x6e8 <pvPortMalloc+0x122>
     6e4:	00 e0       	ldi	r16, 0x00	; 0
     6e6:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6e8:	78 d7       	rcall	.+3824   	; 0x15da <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6ea:	c8 01       	movw	r24, r16
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	08 95       	ret

000006f6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6f6:	0f 93       	push	r16
     6f8:	1f 93       	push	r17
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     6fe:	00 97       	sbiw	r24, 0x00	; 0
     700:	31 f1       	breq	.+76     	; 0x74e <vPortFree+0x58>
     702:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     704:	8c 01       	movw	r16, r24
     706:	04 50       	subi	r16, 0x04	; 4
     708:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     70a:	46 d6       	rcall	.+3212   	; 0x1398 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     70c:	f8 01       	movw	r30, r16
     70e:	42 81       	ldd	r20, Z+2	; 0x02
     710:	53 81       	ldd	r21, Z+3	; 0x03
     712:	af e8       	ldi	r26, 0x8F	; 143
     714:	b2 e0       	ldi	r27, 0x02	; 2
     716:	01 c0       	rjmp	.+2      	; 0x71a <vPortFree+0x24>
     718:	df 01       	movw	r26, r30
     71a:	ed 91       	ld	r30, X+
     71c:	fc 91       	ld	r31, X
     71e:	11 97       	sbiw	r26, 0x01	; 1
     720:	22 81       	ldd	r18, Z+2	; 0x02
     722:	33 81       	ldd	r19, Z+3	; 0x03
     724:	24 17       	cp	r18, r20
     726:	35 07       	cpc	r19, r21
     728:	b8 f3       	brcs	.-18     	; 0x718 <vPortFree+0x22>
     72a:	24 97       	sbiw	r28, 0x04	; 4
     72c:	f9 83       	std	Y+1, r31	; 0x01
     72e:	e8 83       	st	Y, r30
     730:	0d 93       	st	X+, r16
     732:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     734:	20 91 00 02 	lds	r18, 0x0200
     738:	30 91 01 02 	lds	r19, 0x0201
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	9b 81       	ldd	r25, Y+3	; 0x03
     740:	82 0f       	add	r24, r18
     742:	93 1f       	adc	r25, r19
     744:	90 93 01 02 	sts	0x0201, r25
     748:	80 93 00 02 	sts	0x0200, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     74c:	46 d7       	rcall	.+3724   	; 0x15da <xTaskResumeAll>
	}
}
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	1f 91       	pop	r17
     754:	0f 91       	pop	r16
     756:	08 95       	ret

00000758 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     758:	80 91 00 02 	lds	r24, 0x0200
     75c:	90 91 01 02 	lds	r25, 0x0201
     760:	08 95       	ret

00000762 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     762:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     764:	03 96       	adiw	r24, 0x03	; 3
     766:	92 83       	std	Z+2, r25	; 0x02
     768:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     76a:	4f ef       	ldi	r20, 0xFF	; 255
     76c:	5f ef       	ldi	r21, 0xFF	; 255
     76e:	ba 01       	movw	r22, r20
     770:	43 83       	std	Z+3, r20	; 0x03
     772:	54 83       	std	Z+4, r21	; 0x04
     774:	65 83       	std	Z+5, r22	; 0x05
     776:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     778:	90 87       	std	Z+8, r25	; 0x08
     77a:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     77c:	92 87       	std	Z+10, r25	; 0x0a
     77e:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     780:	10 82       	st	Z, r1
     782:	08 95       	ret

00000784 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     784:	fc 01       	movw	r30, r24
     786:	13 86       	std	Z+11, r1	; 0x0b
     788:	12 86       	std	Z+10, r1	; 0x0a
     78a:	08 95       	ret

0000078c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	9c 01       	movw	r18, r24
     792:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     794:	dc 01       	movw	r26, r24
     796:	11 96       	adiw	r26, 0x01	; 1
     798:	cd 91       	ld	r28, X+
     79a:	dc 91       	ld	r29, X
     79c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     79e:	d5 83       	std	Z+5, r29	; 0x05
     7a0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     7a2:	8e 81       	ldd	r24, Y+6	; 0x06
     7a4:	9f 81       	ldd	r25, Y+7	; 0x07
     7a6:	97 83       	std	Z+7, r25	; 0x07
     7a8:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     7aa:	8e 81       	ldd	r24, Y+6	; 0x06
     7ac:	9f 81       	ldd	r25, Y+7	; 0x07
     7ae:	dc 01       	movw	r26, r24
     7b0:	15 96       	adiw	r26, 0x05	; 5
     7b2:	7c 93       	st	X, r23
     7b4:	6e 93       	st	-X, r22
     7b6:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     7b8:	7f 83       	std	Y+7, r23	; 0x07
     7ba:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7bc:	33 87       	std	Z+11, r19	; 0x0b
     7be:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     7c0:	f9 01       	movw	r30, r18
     7c2:	80 81       	ld	r24, Z
     7c4:	8f 5f       	subi	r24, 0xFF	; 255
     7c6:	80 83       	st	Z, r24
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7ce:	0f 93       	push	r16
     7d0:	1f 93       	push	r17
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     7d8:	08 81       	ld	r16, Y
     7da:	19 81       	ldd	r17, Y+1	; 0x01
     7dc:	2a 81       	ldd	r18, Y+2	; 0x02
     7de:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7e0:	0f 3f       	cpi	r16, 0xFF	; 255
     7e2:	4f ef       	ldi	r20, 0xFF	; 255
     7e4:	14 07       	cpc	r17, r20
     7e6:	24 07       	cpc	r18, r20
     7e8:	34 07       	cpc	r19, r20
     7ea:	21 f4       	brne	.+8      	; 0x7f4 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7ec:	fc 01       	movw	r30, r24
     7ee:	a1 85       	ldd	r26, Z+9	; 0x09
     7f0:	b2 85       	ldd	r27, Z+10	; 0x0a
     7f2:	11 c0       	rjmp	.+34     	; 0x816 <vListInsert+0x48>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7f4:	dc 01       	movw	r26, r24
     7f6:	13 96       	adiw	r26, 0x03	; 3
     7f8:	01 c0       	rjmp	.+2      	; 0x7fc <vListInsert+0x2e>
     7fa:	df 01       	movw	r26, r30
     7fc:	14 96       	adiw	r26, 0x04	; 4
     7fe:	ed 91       	ld	r30, X+
     800:	fc 91       	ld	r31, X
     802:	15 97       	sbiw	r26, 0x05	; 5
     804:	40 81       	ld	r20, Z
     806:	51 81       	ldd	r21, Z+1	; 0x01
     808:	62 81       	ldd	r22, Z+2	; 0x02
     80a:	73 81       	ldd	r23, Z+3	; 0x03
     80c:	04 17       	cp	r16, r20
     80e:	15 07       	cpc	r17, r21
     810:	26 07       	cpc	r18, r22
     812:	37 07       	cpc	r19, r23
     814:	90 f7       	brcc	.-28     	; 0x7fa <vListInsert+0x2c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     816:	14 96       	adiw	r26, 0x04	; 4
     818:	ed 91       	ld	r30, X+
     81a:	fc 91       	ld	r31, X
     81c:	15 97       	sbiw	r26, 0x05	; 5
     81e:	fd 83       	std	Y+5, r31	; 0x05
     820:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     822:	d7 83       	std	Z+7, r29	; 0x07
     824:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     826:	bf 83       	std	Y+7, r27	; 0x07
     828:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     82a:	15 96       	adiw	r26, 0x05	; 5
     82c:	dc 93       	st	X, r29
     82e:	ce 93       	st	-X, r28
     830:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     832:	9b 87       	std	Y+11, r25	; 0x0b
     834:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     836:	fc 01       	movw	r30, r24
     838:	20 81       	ld	r18, Z
     83a:	2f 5f       	subi	r18, 0xFF	; 255
     83c:	20 83       	st	Z, r18
}
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	08 95       	ret

00000848 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     84e:	a2 85       	ldd	r26, Z+10	; 0x0a
     850:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     852:	c4 81       	ldd	r28, Z+4	; 0x04
     854:	d5 81       	ldd	r29, Z+5	; 0x05
     856:	86 81       	ldd	r24, Z+6	; 0x06
     858:	97 81       	ldd	r25, Z+7	; 0x07
     85a:	9f 83       	std	Y+7, r25	; 0x07
     85c:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     85e:	c6 81       	ldd	r28, Z+6	; 0x06
     860:	d7 81       	ldd	r29, Z+7	; 0x07
     862:	84 81       	ldd	r24, Z+4	; 0x04
     864:	95 81       	ldd	r25, Z+5	; 0x05
     866:	9d 83       	std	Y+5, r25	; 0x05
     868:	8c 83       	std	Y+4, r24	; 0x04

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     86a:	11 96       	adiw	r26, 0x01	; 1
     86c:	cd 91       	ld	r28, X+
     86e:	dc 91       	ld	r29, X
     870:	12 97       	sbiw	r26, 0x02	; 2
     872:	ce 17       	cp	r28, r30
     874:	df 07       	cpc	r29, r31
     876:	31 f4       	brne	.+12     	; 0x884 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     878:	8e 81       	ldd	r24, Y+6	; 0x06
     87a:	9f 81       	ldd	r25, Y+7	; 0x07
     87c:	12 96       	adiw	r26, 0x02	; 2
     87e:	9c 93       	st	X, r25
     880:	8e 93       	st	-X, r24
     882:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     884:	13 86       	std	Z+11, r1	; 0x0b
     886:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     888:	8c 91       	ld	r24, X
     88a:	81 50       	subi	r24, 0x01	; 1
     88c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     88e:	df 91       	pop	r29
     890:	cf 91       	pop	r28
     892:	08 95       	ret

00000894 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     894:	90 93 3f 1a 	sts	0x1A3F, r25
     898:	80 93 3e 1a 	sts	0x1A3E, r24
     89c:	31 e1       	ldi	r19, 0x11	; 17
     89e:	fc 01       	movw	r30, r24
     8a0:	30 83       	st	Z, r19
     8a2:	31 97       	sbiw	r30, 0x01	; 1
     8a4:	22 e2       	ldi	r18, 0x22	; 34
     8a6:	20 83       	st	Z, r18
     8a8:	31 97       	sbiw	r30, 0x01	; 1
     8aa:	a3 e3       	ldi	r26, 0x33	; 51
     8ac:	a0 83       	st	Z, r26
     8ae:	31 97       	sbiw	r30, 0x01	; 1
     8b0:	60 83       	st	Z, r22
     8b2:	31 97       	sbiw	r30, 0x01	; 1
     8b4:	70 83       	st	Z, r23
     8b6:	31 97       	sbiw	r30, 0x01	; 1
     8b8:	10 82       	st	Z, r1
     8ba:	31 97       	sbiw	r30, 0x01	; 1
     8bc:	60 e8       	ldi	r22, 0x80	; 128
     8be:	60 83       	st	Z, r22
     8c0:	31 97       	sbiw	r30, 0x01	; 1
     8c2:	10 82       	st	Z, r1
     8c4:	31 97       	sbiw	r30, 0x01	; 1
     8c6:	62 e0       	ldi	r22, 0x02	; 2
     8c8:	60 83       	st	Z, r22
     8ca:	31 97       	sbiw	r30, 0x01	; 1
     8cc:	63 e0       	ldi	r22, 0x03	; 3
     8ce:	60 83       	st	Z, r22
     8d0:	31 97       	sbiw	r30, 0x01	; 1
     8d2:	64 e0       	ldi	r22, 0x04	; 4
     8d4:	60 83       	st	Z, r22
     8d6:	31 97       	sbiw	r30, 0x01	; 1
     8d8:	65 e0       	ldi	r22, 0x05	; 5
     8da:	60 83       	st	Z, r22
     8dc:	31 97       	sbiw	r30, 0x01	; 1
     8de:	66 e0       	ldi	r22, 0x06	; 6
     8e0:	60 83       	st	Z, r22
     8e2:	31 97       	sbiw	r30, 0x01	; 1
     8e4:	67 e0       	ldi	r22, 0x07	; 7
     8e6:	60 83       	st	Z, r22
     8e8:	31 97       	sbiw	r30, 0x01	; 1
     8ea:	68 e0       	ldi	r22, 0x08	; 8
     8ec:	60 83       	st	Z, r22
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	69 e0       	ldi	r22, 0x09	; 9
     8f2:	60 83       	st	Z, r22
     8f4:	31 97       	sbiw	r30, 0x01	; 1
     8f6:	60 e1       	ldi	r22, 0x10	; 16
     8f8:	60 83       	st	Z, r22
     8fa:	31 97       	sbiw	r30, 0x01	; 1
     8fc:	30 83       	st	Z, r19
     8fe:	31 97       	sbiw	r30, 0x01	; 1
     900:	32 e1       	ldi	r19, 0x12	; 18
     902:	30 83       	st	Z, r19
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	33 e1       	ldi	r19, 0x13	; 19
     908:	30 83       	st	Z, r19
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	34 e1       	ldi	r19, 0x14	; 20
     90e:	30 83       	st	Z, r19
     910:	31 97       	sbiw	r30, 0x01	; 1
     912:	35 e1       	ldi	r19, 0x15	; 21
     914:	30 83       	st	Z, r19
     916:	31 97       	sbiw	r30, 0x01	; 1
     918:	36 e1       	ldi	r19, 0x16	; 22
     91a:	30 83       	st	Z, r19
     91c:	31 97       	sbiw	r30, 0x01	; 1
     91e:	37 e1       	ldi	r19, 0x17	; 23
     920:	30 83       	st	Z, r19
     922:	31 97       	sbiw	r30, 0x01	; 1
     924:	38 e1       	ldi	r19, 0x18	; 24
     926:	30 83       	st	Z, r19
     928:	31 97       	sbiw	r30, 0x01	; 1
     92a:	39 e1       	ldi	r19, 0x19	; 25
     92c:	30 83       	st	Z, r19
     92e:	31 97       	sbiw	r30, 0x01	; 1
     930:	30 e2       	ldi	r19, 0x20	; 32
     932:	30 83       	st	Z, r19
     934:	31 97       	sbiw	r30, 0x01	; 1
     936:	31 e2       	ldi	r19, 0x21	; 33
     938:	30 83       	st	Z, r19
     93a:	31 97       	sbiw	r30, 0x01	; 1
     93c:	20 83       	st	Z, r18
     93e:	31 97       	sbiw	r30, 0x01	; 1
     940:	23 e2       	ldi	r18, 0x23	; 35
     942:	20 83       	st	Z, r18
     944:	31 97       	sbiw	r30, 0x01	; 1
     946:	40 83       	st	Z, r20
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	50 83       	st	Z, r21
     94c:	31 97       	sbiw	r30, 0x01	; 1
     94e:	26 e2       	ldi	r18, 0x26	; 38
     950:	20 83       	st	Z, r18
     952:	31 97       	sbiw	r30, 0x01	; 1
     954:	27 e2       	ldi	r18, 0x27	; 39
     956:	20 83       	st	Z, r18
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	28 e2       	ldi	r18, 0x28	; 40
     95c:	20 83       	st	Z, r18
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	29 e2       	ldi	r18, 0x29	; 41
     962:	20 83       	st	Z, r18
     964:	31 97       	sbiw	r30, 0x01	; 1
     966:	20 e3       	ldi	r18, 0x30	; 48
     968:	20 83       	st	Z, r18
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	21 e3       	ldi	r18, 0x31	; 49
     96e:	20 83       	st	Z, r18
     970:	86 97       	sbiw	r24, 0x26	; 38
     972:	08 95       	ret

00000974 <xPortStartScheduler>:
     974:	87 e0       	ldi	r24, 0x07	; 7
     976:	80 93 29 01 	sts	0x0129, r24
     97a:	8f ec       	ldi	r24, 0xCF	; 207
     97c:	80 93 28 01 	sts	0x0128, r24
     980:	8a e0       	ldi	r24, 0x0A	; 10
     982:	80 93 21 01 	sts	0x0121, r24
     986:	e3 e7       	ldi	r30, 0x73	; 115
     988:	f0 e0       	ldi	r31, 0x00	; 0
     98a:	80 81       	ld	r24, Z
     98c:	82 60       	ori	r24, 0x02	; 2
     98e:	80 83       	st	Z, r24
     990:	a0 91 2a 1a 	lds	r26, 0x1A2A
     994:	b0 91 2b 1a 	lds	r27, 0x1A2B
     998:	cd 91       	ld	r28, X+
     99a:	cd bf       	out	0x3d, r28	; 61
     99c:	dd 91       	ld	r29, X+
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	ff 91       	pop	r31
     9a2:	ef 91       	pop	r30
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	bf 91       	pop	r27
     9aa:	af 91       	pop	r26
     9ac:	9f 91       	pop	r25
     9ae:	8f 91       	pop	r24
     9b0:	7f 91       	pop	r23
     9b2:	6f 91       	pop	r22
     9b4:	5f 91       	pop	r21
     9b6:	4f 91       	pop	r20
     9b8:	3f 91       	pop	r19
     9ba:	2f 91       	pop	r18
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	df 90       	pop	r13
     9c6:	cf 90       	pop	r12
     9c8:	bf 90       	pop	r11
     9ca:	af 90       	pop	r10
     9cc:	9f 90       	pop	r9
     9ce:	8f 90       	pop	r8
     9d0:	7f 90       	pop	r7
     9d2:	6f 90       	pop	r6
     9d4:	5f 90       	pop	r5
     9d6:	4f 90       	pop	r4
     9d8:	3f 90       	pop	r3
     9da:	2f 90       	pop	r2
     9dc:	1f 90       	pop	r1
     9de:	0f 90       	pop	r0
     9e0:	0f be       	out	0x3f, r0	; 63
     9e2:	0f 90       	pop	r0
     9e4:	08 95       	ret
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	08 95       	ret

000009ea <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9ea:	0f 92       	push	r0
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	0f 92       	push	r0
     9f2:	1f 92       	push	r1
     9f4:	11 24       	eor	r1, r1
     9f6:	2f 92       	push	r2
     9f8:	3f 92       	push	r3
     9fa:	4f 92       	push	r4
     9fc:	5f 92       	push	r5
     9fe:	6f 92       	push	r6
     a00:	7f 92       	push	r7
     a02:	8f 92       	push	r8
     a04:	9f 92       	push	r9
     a06:	af 92       	push	r10
     a08:	bf 92       	push	r11
     a0a:	cf 92       	push	r12
     a0c:	df 92       	push	r13
     a0e:	ef 92       	push	r14
     a10:	ff 92       	push	r15
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	2f 93       	push	r18
     a18:	3f 93       	push	r19
     a1a:	4f 93       	push	r20
     a1c:	5f 93       	push	r21
     a1e:	6f 93       	push	r22
     a20:	7f 93       	push	r23
     a22:	8f 93       	push	r24
     a24:	9f 93       	push	r25
     a26:	af 93       	push	r26
     a28:	bf 93       	push	r27
     a2a:	cf 93       	push	r28
     a2c:	df 93       	push	r29
     a2e:	ef 93       	push	r30
     a30:	ff 93       	push	r31
     a32:	a0 91 2a 1a 	lds	r26, 0x1A2A
     a36:	b0 91 2b 1a 	lds	r27, 0x1A2B
     a3a:	0d b6       	in	r0, 0x3d	; 61
     a3c:	0d 92       	st	X+, r0
     a3e:	0e b6       	in	r0, 0x3e	; 62
     a40:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a42:	cc d6       	rcall	.+3480   	; 0x17dc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a44:	a0 91 2a 1a 	lds	r26, 0x1A2A
     a48:	b0 91 2b 1a 	lds	r27, 0x1A2B
     a4c:	cd 91       	ld	r28, X+
     a4e:	cd bf       	out	0x3d, r28	; 61
     a50:	dd 91       	ld	r29, X+
     a52:	de bf       	out	0x3e, r29	; 62
     a54:	ff 91       	pop	r31
     a56:	ef 91       	pop	r30
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	bf 91       	pop	r27
     a5e:	af 91       	pop	r26
     a60:	9f 91       	pop	r25
     a62:	8f 91       	pop	r24
     a64:	7f 91       	pop	r23
     a66:	6f 91       	pop	r22
     a68:	5f 91       	pop	r21
     a6a:	4f 91       	pop	r20
     a6c:	3f 91       	pop	r19
     a6e:	2f 91       	pop	r18
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	ff 90       	pop	r15
     a76:	ef 90       	pop	r14
     a78:	df 90       	pop	r13
     a7a:	cf 90       	pop	r12
     a7c:	bf 90       	pop	r11
     a7e:	af 90       	pop	r10
     a80:	9f 90       	pop	r9
     a82:	8f 90       	pop	r8
     a84:	7f 90       	pop	r7
     a86:	6f 90       	pop	r6
     a88:	5f 90       	pop	r5
     a8a:	4f 90       	pop	r4
     a8c:	3f 90       	pop	r3
     a8e:	2f 90       	pop	r2
     a90:	1f 90       	pop	r1
     a92:	0f 90       	pop	r0
     a94:	0f be       	out	0x3f, r0	; 63
     a96:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a98:	08 95       	ret

00000a9a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a9a:	0f 92       	push	r0
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	f8 94       	cli
     aa0:	0f 92       	push	r0
     aa2:	1f 92       	push	r1
     aa4:	11 24       	eor	r1, r1
     aa6:	2f 92       	push	r2
     aa8:	3f 92       	push	r3
     aaa:	4f 92       	push	r4
     aac:	5f 92       	push	r5
     aae:	6f 92       	push	r6
     ab0:	7f 92       	push	r7
     ab2:	8f 92       	push	r8
     ab4:	9f 92       	push	r9
     ab6:	af 92       	push	r10
     ab8:	bf 92       	push	r11
     aba:	cf 92       	push	r12
     abc:	df 92       	push	r13
     abe:	ef 92       	push	r14
     ac0:	ff 92       	push	r15
     ac2:	0f 93       	push	r16
     ac4:	1f 93       	push	r17
     ac6:	2f 93       	push	r18
     ac8:	3f 93       	push	r19
     aca:	4f 93       	push	r20
     acc:	5f 93       	push	r21
     ace:	6f 93       	push	r22
     ad0:	7f 93       	push	r23
     ad2:	8f 93       	push	r24
     ad4:	9f 93       	push	r25
     ad6:	af 93       	push	r26
     ad8:	bf 93       	push	r27
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	ef 93       	push	r30
     ae0:	ff 93       	push	r31
     ae2:	a0 91 2a 1a 	lds	r26, 0x1A2A
     ae6:	b0 91 2b 1a 	lds	r27, 0x1A2B
     aea:	0d b6       	in	r0, 0x3d	; 61
     aec:	0d 92       	st	X+, r0
     aee:	0e b6       	in	r0, 0x3e	; 62
     af0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     af2:	73 d4       	rcall	.+2278   	; 0x13da <xTaskIncrementTick>
     af4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     af6:	72 d6       	rcall	.+3300   	; 0x17dc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     af8:	a0 91 2a 1a 	lds	r26, 0x1A2A
     afc:	b0 91 2b 1a 	lds	r27, 0x1A2B
     b00:	cd 91       	ld	r28, X+
     b02:	cd bf       	out	0x3d, r28	; 61
     b04:	dd 91       	ld	r29, X+
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	ff 91       	pop	r31
     b0a:	ef 91       	pop	r30
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28
     b10:	bf 91       	pop	r27
     b12:	af 91       	pop	r26
     b14:	9f 91       	pop	r25
     b16:	8f 91       	pop	r24
     b18:	7f 91       	pop	r23
     b1a:	6f 91       	pop	r22
     b1c:	5f 91       	pop	r21
     b1e:	4f 91       	pop	r20
     b20:	3f 91       	pop	r19
     b22:	2f 91       	pop	r18
     b24:	1f 91       	pop	r17
     b26:	0f 91       	pop	r16
     b28:	ff 90       	pop	r15
     b2a:	ef 90       	pop	r14
     b2c:	df 90       	pop	r13
     b2e:	cf 90       	pop	r12
     b30:	bf 90       	pop	r11
     b32:	af 90       	pop	r10
     b34:	9f 90       	pop	r9
     b36:	8f 90       	pop	r8
     b38:	7f 90       	pop	r7
     b3a:	6f 90       	pop	r6
     b3c:	5f 90       	pop	r5
     b3e:	4f 90       	pop	r4
     b40:	3f 90       	pop	r3
     b42:	2f 90       	pop	r2
     b44:	1f 90       	pop	r1
     b46:	0f 90       	pop	r0
     b48:	0f be       	out	0x3f, r0	; 63
     b4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b4c:	08 95       	ret

00000b4e <__vector_47>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
     b4e:	a5 df       	rcall	.-182    	; 0xa9a <vPortYieldFromTick>
		asm volatile ( "reti" );
     b50:	18 95       	reti

00000b52 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     b52:	1f 93       	push	r17
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	ec 01       	movw	r28, r24
     b5a:	14 2f       	mov	r17, r20
     b5c:	88 a1       	ldd	r24, Y+32	; 0x20
     b5e:	81 11       	cpse	r24, r1
     b60:	0b c0       	rjmp	.+22     	; 0xb78 <prvCopyDataToQueue+0x26>
     b62:	88 81       	ld	r24, Y
     b64:	99 81       	ldd	r25, Y+1	; 0x01
     b66:	89 2b       	or	r24, r25
     b68:	09 f0       	breq	.+2      	; 0xb6c <prvCopyDataToQueue+0x1a>
     b6a:	46 c0       	rjmp	.+140    	; 0xbf8 <prvCopyDataToQueue+0xa6>
     b6c:	8a 81       	ldd	r24, Y+2	; 0x02
     b6e:	9b 81       	ldd	r25, Y+3	; 0x03
     b70:	e9 d7       	rcall	.+4050   	; 0x1b44 <xTaskPriorityDisinherit>
     b72:	1b 82       	std	Y+3, r1	; 0x03
     b74:	1a 82       	std	Y+2, r1	; 0x02
     b76:	47 c0       	rjmp	.+142    	; 0xc06 <prvCopyDataToQueue+0xb4>
     b78:	41 11       	cpse	r20, r1
     b7a:	18 c0       	rjmp	.+48     	; 0xbac <prvCopyDataToQueue+0x5a>
     b7c:	48 2f       	mov	r20, r24
     b7e:	50 e0       	ldi	r21, 0x00	; 0
     b80:	8c 81       	ldd	r24, Y+4	; 0x04
     b82:	9d 81       	ldd	r25, Y+5	; 0x05
     b84:	0e 94 fd 19 	call	0x33fa	; 0x33fa <memcpy>
     b88:	28 a1       	ldd	r18, Y+32	; 0x20
     b8a:	8c 81       	ldd	r24, Y+4	; 0x04
     b8c:	9d 81       	ldd	r25, Y+5	; 0x05
     b8e:	82 0f       	add	r24, r18
     b90:	91 1d       	adc	r25, r1
     b92:	9d 83       	std	Y+5, r25	; 0x05
     b94:	8c 83       	std	Y+4, r24	; 0x04
     b96:	2a 81       	ldd	r18, Y+2	; 0x02
     b98:	3b 81       	ldd	r19, Y+3	; 0x03
     b9a:	82 17       	cp	r24, r18
     b9c:	93 07       	cpc	r25, r19
     b9e:	70 f1       	brcs	.+92     	; 0xbfc <prvCopyDataToQueue+0xaa>
     ba0:	88 81       	ld	r24, Y
     ba2:	99 81       	ldd	r25, Y+1	; 0x01
     ba4:	9d 83       	std	Y+5, r25	; 0x05
     ba6:	8c 83       	std	Y+4, r24	; 0x04
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	2d c0       	rjmp	.+90     	; 0xc06 <prvCopyDataToQueue+0xb4>
     bac:	48 2f       	mov	r20, r24
     bae:	50 e0       	ldi	r21, 0x00	; 0
     bb0:	8e 81       	ldd	r24, Y+6	; 0x06
     bb2:	9f 81       	ldd	r25, Y+7	; 0x07
     bb4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <memcpy>
     bb8:	88 a1       	ldd	r24, Y+32	; 0x20
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	91 95       	neg	r25
     bbe:	81 95       	neg	r24
     bc0:	91 09       	sbc	r25, r1
     bc2:	2e 81       	ldd	r18, Y+6	; 0x06
     bc4:	3f 81       	ldd	r19, Y+7	; 0x07
     bc6:	28 0f       	add	r18, r24
     bc8:	39 1f       	adc	r19, r25
     bca:	3f 83       	std	Y+7, r19	; 0x07
     bcc:	2e 83       	std	Y+6, r18	; 0x06
     bce:	48 81       	ld	r20, Y
     bd0:	59 81       	ldd	r21, Y+1	; 0x01
     bd2:	24 17       	cp	r18, r20
     bd4:	35 07       	cpc	r19, r21
     bd6:	30 f4       	brcc	.+12     	; 0xbe4 <prvCopyDataToQueue+0x92>
     bd8:	2a 81       	ldd	r18, Y+2	; 0x02
     bda:	3b 81       	ldd	r19, Y+3	; 0x03
     bdc:	82 0f       	add	r24, r18
     bde:	93 1f       	adc	r25, r19
     be0:	9f 83       	std	Y+7, r25	; 0x07
     be2:	8e 83       	std	Y+6, r24	; 0x06
     be4:	12 30       	cpi	r17, 0x02	; 2
     be6:	61 f4       	brne	.+24     	; 0xc00 <prvCopyDataToQueue+0xae>
     be8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bea:	88 23       	and	r24, r24
     bec:	59 f0       	breq	.+22     	; 0xc04 <prvCopyDataToQueue+0xb2>
     bee:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bf0:	81 50       	subi	r24, 0x01	; 1
     bf2:	8e 8f       	std	Y+30, r24	; 0x1e
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	07 c0       	rjmp	.+14     	; 0xc06 <prvCopyDataToQueue+0xb4>
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	05 c0       	rjmp	.+10     	; 0xc06 <prvCopyDataToQueue+0xb4>
     bfc:	80 e0       	ldi	r24, 0x00	; 0
     bfe:	03 c0       	rjmp	.+6      	; 0xc06 <prvCopyDataToQueue+0xb4>
     c00:	80 e0       	ldi	r24, 0x00	; 0
     c02:	01 c0       	rjmp	.+2      	; 0xc06 <prvCopyDataToQueue+0xb4>
     c04:	80 e0       	ldi	r24, 0x00	; 0
     c06:	9e 8d       	ldd	r25, Y+30	; 0x1e
     c08:	9f 5f       	subi	r25, 0xFF	; 255
     c0a:	9e 8f       	std	Y+30, r25	; 0x1e
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	1f 91       	pop	r17
     c12:	08 95       	ret

00000c14 <prvCopyDataFromQueue>:
     c14:	fc 01       	movw	r30, r24
     c16:	40 a1       	ldd	r20, Z+32	; 0x20
     c18:	44 23       	and	r20, r20
     c1a:	a9 f0       	breq	.+42     	; 0xc46 <prvCopyDataFromQueue+0x32>
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	26 81       	ldd	r18, Z+6	; 0x06
     c20:	37 81       	ldd	r19, Z+7	; 0x07
     c22:	24 0f       	add	r18, r20
     c24:	35 1f       	adc	r19, r21
     c26:	37 83       	std	Z+7, r19	; 0x07
     c28:	26 83       	std	Z+6, r18	; 0x06
     c2a:	82 81       	ldd	r24, Z+2	; 0x02
     c2c:	93 81       	ldd	r25, Z+3	; 0x03
     c2e:	28 17       	cp	r18, r24
     c30:	39 07       	cpc	r19, r25
     c32:	20 f0       	brcs	.+8      	; 0xc3c <prvCopyDataFromQueue+0x28>
     c34:	80 81       	ld	r24, Z
     c36:	91 81       	ldd	r25, Z+1	; 0x01
     c38:	97 83       	std	Z+7, r25	; 0x07
     c3a:	86 83       	std	Z+6, r24	; 0x06
     c3c:	cb 01       	movw	r24, r22
     c3e:	66 81       	ldd	r22, Z+6	; 0x06
     c40:	77 81       	ldd	r23, Z+7	; 0x07
     c42:	0c 94 fd 19 	jmp	0x33fa	; 0x33fa <memcpy>
     c46:	08 95       	ret

00000c48 <prvUnlockQueue>:
     c48:	0f 93       	push	r16
     c4a:	1f 93       	push	r17
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	ec 01       	movw	r28, r24
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	f8 94       	cli
     c56:	0f 92       	push	r0
     c58:	8a a1       	ldd	r24, Y+34	; 0x22
     c5a:	18 16       	cp	r1, r24
     c5c:	ac f4       	brge	.+42     	; 0xc88 <prvUnlockQueue+0x40>
     c5e:	8b 89       	ldd	r24, Y+19	; 0x13
     c60:	81 11       	cpse	r24, r1
     c62:	05 c0       	rjmp	.+10     	; 0xc6e <prvUnlockQueue+0x26>
     c64:	11 c0       	rjmp	.+34     	; 0xc88 <prvUnlockQueue+0x40>
     c66:	9b 89       	ldd	r25, Y+19	; 0x13
     c68:	91 11       	cpse	r25, r1
     c6a:	04 c0       	rjmp	.+8      	; 0xc74 <prvUnlockQueue+0x2c>
     c6c:	0d c0       	rjmp	.+26     	; 0xc88 <prvUnlockQueue+0x40>
     c6e:	8e 01       	movw	r16, r28
     c70:	0d 5e       	subi	r16, 0xED	; 237
     c72:	1f 4f       	sbci	r17, 0xFF	; 255
     c74:	c8 01       	movw	r24, r16
     c76:	3a d6       	rcall	.+3188   	; 0x18ec <xTaskRemoveFromEventList>
     c78:	81 11       	cpse	r24, r1
     c7a:	e5 d6       	rcall	.+3530   	; 0x1a46 <vTaskMissedYield>
     c7c:	9a a1       	ldd	r25, Y+34	; 0x22
     c7e:	91 50       	subi	r25, 0x01	; 1
     c80:	9a a3       	std	Y+34, r25	; 0x22
     c82:	9a a1       	ldd	r25, Y+34	; 0x22
     c84:	19 16       	cp	r1, r25
     c86:	7c f3       	brlt	.-34     	; 0xc66 <prvUnlockQueue+0x1e>
     c88:	8f ef       	ldi	r24, 0xFF	; 255
     c8a:	8a a3       	std	Y+34, r24	; 0x22
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	0f 92       	push	r0
     c96:	89 a1       	ldd	r24, Y+33	; 0x21
     c98:	18 16       	cp	r1, r24
     c9a:	ac f4       	brge	.+42     	; 0xcc6 <prvUnlockQueue+0x7e>
     c9c:	88 85       	ldd	r24, Y+8	; 0x08
     c9e:	81 11       	cpse	r24, r1
     ca0:	05 c0       	rjmp	.+10     	; 0xcac <prvUnlockQueue+0x64>
     ca2:	11 c0       	rjmp	.+34     	; 0xcc6 <prvUnlockQueue+0x7e>
     ca4:	98 85       	ldd	r25, Y+8	; 0x08
     ca6:	91 11       	cpse	r25, r1
     ca8:	04 c0       	rjmp	.+8      	; 0xcb2 <prvUnlockQueue+0x6a>
     caa:	0d c0       	rjmp	.+26     	; 0xcc6 <prvUnlockQueue+0x7e>
     cac:	8e 01       	movw	r16, r28
     cae:	08 5f       	subi	r16, 0xF8	; 248
     cb0:	1f 4f       	sbci	r17, 0xFF	; 255
     cb2:	c8 01       	movw	r24, r16
     cb4:	1b d6       	rcall	.+3126   	; 0x18ec <xTaskRemoveFromEventList>
     cb6:	81 11       	cpse	r24, r1
     cb8:	c6 d6       	rcall	.+3468   	; 0x1a46 <vTaskMissedYield>
     cba:	99 a1       	ldd	r25, Y+33	; 0x21
     cbc:	91 50       	subi	r25, 0x01	; 1
     cbe:	99 a3       	std	Y+33, r25	; 0x21
     cc0:	99 a1       	ldd	r25, Y+33	; 0x21
     cc2:	19 16       	cp	r1, r25
     cc4:	7c f3       	brlt	.-34     	; 0xca4 <prvUnlockQueue+0x5c>
     cc6:	8f ef       	ldi	r24, 0xFF	; 255
     cc8:	89 a3       	std	Y+33, r24	; 0x21
     cca:	0f 90       	pop	r0
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	df 91       	pop	r29
     cd0:	cf 91       	pop	r28
     cd2:	1f 91       	pop	r17
     cd4:	0f 91       	pop	r16
     cd6:	08 95       	ret

00000cd8 <xQueueGenericReset>:
     cd8:	cf 93       	push	r28
     cda:	df 93       	push	r29
     cdc:	ec 01       	movw	r28, r24
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	0f 92       	push	r0
     ce4:	48 81       	ld	r20, Y
     ce6:	59 81       	ldd	r21, Y+1	; 0x01
     ce8:	28 a1       	ldd	r18, Y+32	; 0x20
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	7f 8d       	ldd	r23, Y+31	; 0x1f
     cee:	72 9f       	mul	r23, r18
     cf0:	c0 01       	movw	r24, r0
     cf2:	73 9f       	mul	r23, r19
     cf4:	90 0d       	add	r25, r0
     cf6:	11 24       	eor	r1, r1
     cf8:	fa 01       	movw	r30, r20
     cfa:	e8 0f       	add	r30, r24
     cfc:	f9 1f       	adc	r31, r25
     cfe:	fb 83       	std	Y+3, r31	; 0x03
     d00:	ea 83       	std	Y+2, r30	; 0x02
     d02:	1e 8e       	std	Y+30, r1	; 0x1e
     d04:	5d 83       	std	Y+5, r21	; 0x05
     d06:	4c 83       	std	Y+4, r20	; 0x04
     d08:	82 1b       	sub	r24, r18
     d0a:	93 0b       	sbc	r25, r19
     d0c:	84 0f       	add	r24, r20
     d0e:	95 1f       	adc	r25, r21
     d10:	9f 83       	std	Y+7, r25	; 0x07
     d12:	8e 83       	std	Y+6, r24	; 0x06
     d14:	8f ef       	ldi	r24, 0xFF	; 255
     d16:	89 a3       	std	Y+33, r24	; 0x21
     d18:	8a a3       	std	Y+34, r24	; 0x22
     d1a:	61 11       	cpse	r22, r1
     d1c:	0a c0       	rjmp	.+20     	; 0xd32 <xQueueGenericReset+0x5a>
     d1e:	88 85       	ldd	r24, Y+8	; 0x08
     d20:	88 23       	and	r24, r24
     d22:	69 f0       	breq	.+26     	; 0xd3e <xQueueGenericReset+0x66>
     d24:	ce 01       	movw	r24, r28
     d26:	08 96       	adiw	r24, 0x08	; 8
     d28:	e1 d5       	rcall	.+3010   	; 0x18ec <xTaskRemoveFromEventList>
     d2a:	81 30       	cpi	r24, 0x01	; 1
     d2c:	41 f4       	brne	.+16     	; 0xd3e <xQueueGenericReset+0x66>
     d2e:	5d de       	rcall	.-838    	; 0x9ea <vPortYield>
     d30:	06 c0       	rjmp	.+12     	; 0xd3e <xQueueGenericReset+0x66>
     d32:	ce 01       	movw	r24, r28
     d34:	08 96       	adiw	r24, 0x08	; 8
     d36:	15 dd       	rcall	.-1494   	; 0x762 <vListInitialise>
     d38:	ce 01       	movw	r24, r28
     d3a:	43 96       	adiw	r24, 0x13	; 19
     d3c:	12 dd       	rcall	.-1500   	; 0x762 <vListInitialise>
     d3e:	0f 90       	pop	r0
     d40:	0f be       	out	0x3f, r0	; 63
     d42:	81 e0       	ldi	r24, 0x01	; 1
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	08 95       	ret

00000d4a <xQueueGenericCreate>:
     d4a:	0f 93       	push	r16
     d4c:	1f 93       	push	r17
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	88 23       	and	r24, r24
     d54:	e1 f0       	breq	.+56     	; 0xd8e <xQueueGenericCreate+0x44>
     d56:	06 2f       	mov	r16, r22
     d58:	18 2f       	mov	r17, r24
     d5a:	83 e2       	ldi	r24, 0x23	; 35
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	33 dc       	rcall	.-1946   	; 0x5c6 <pvPortMalloc>
     d60:	ec 01       	movw	r28, r24
     d62:	89 2b       	or	r24, r25
     d64:	b1 f0       	breq	.+44     	; 0xd92 <xQueueGenericCreate+0x48>
     d66:	10 9f       	mul	r17, r16
     d68:	c0 01       	movw	r24, r0
     d6a:	11 24       	eor	r1, r1
     d6c:	01 96       	adiw	r24, 0x01	; 1
     d6e:	2b dc       	rcall	.-1962   	; 0x5c6 <pvPortMalloc>
     d70:	99 83       	std	Y+1, r25	; 0x01
     d72:	88 83       	st	Y, r24
     d74:	89 2b       	or	r24, r25
     d76:	31 f0       	breq	.+12     	; 0xd84 <xQueueGenericCreate+0x3a>
     d78:	1f 8f       	std	Y+31, r17	; 0x1f
     d7a:	08 a3       	std	Y+32, r16	; 0x20
     d7c:	61 e0       	ldi	r22, 0x01	; 1
     d7e:	ce 01       	movw	r24, r28
     d80:	ab df       	rcall	.-170    	; 0xcd8 <xQueueGenericReset>
     d82:	07 c0       	rjmp	.+14     	; 0xd92 <xQueueGenericCreate+0x48>
     d84:	ce 01       	movw	r24, r28
     d86:	b7 dc       	rcall	.-1682   	; 0x6f6 <vPortFree>
     d88:	c0 e0       	ldi	r28, 0x00	; 0
     d8a:	d0 e0       	ldi	r29, 0x00	; 0
     d8c:	02 c0       	rjmp	.+4      	; 0xd92 <xQueueGenericCreate+0x48>
     d8e:	c0 e0       	ldi	r28, 0x00	; 0
     d90:	d0 e0       	ldi	r29, 0x00	; 0
     d92:	ce 01       	movw	r24, r28
     d94:	df 91       	pop	r29
     d96:	cf 91       	pop	r28
     d98:	1f 91       	pop	r17
     d9a:	0f 91       	pop	r16
     d9c:	08 95       	ret

00000d9e <xQueueGenericSend>:
     d9e:	9f 92       	push	r9
     da0:	af 92       	push	r10
     da2:	bf 92       	push	r11
     da4:	cf 92       	push	r12
     da6:	df 92       	push	r13
     da8:	ef 92       	push	r14
     daa:	ff 92       	push	r15
     dac:	0f 93       	push	r16
     dae:	1f 93       	push	r17
     db0:	cf 93       	push	r28
     db2:	df 93       	push	r29
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
     db8:	29 97       	sbiw	r28, 0x09	; 9
     dba:	0f b6       	in	r0, 0x3f	; 63
     dbc:	f8 94       	cli
     dbe:	de bf       	out	0x3e, r29	; 62
     dc0:	0f be       	out	0x3f, r0	; 63
     dc2:	cd bf       	out	0x3d, r28	; 61
     dc4:	7c 01       	movw	r14, r24
     dc6:	5b 01       	movw	r10, r22
     dc8:	2e 83       	std	Y+6, r18	; 0x06
     dca:	3f 83       	std	Y+7, r19	; 0x07
     dcc:	48 87       	std	Y+8, r20	; 0x08
     dce:	59 87       	std	Y+9, r21	; 0x09
     dd0:	10 e0       	ldi	r17, 0x00	; 0
     dd2:	99 24       	eor	r9, r9
     dd4:	93 94       	inc	r9
     dd6:	6c 01       	movw	r12, r24
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	c8 0e       	add	r12, r24
     ddc:	d1 1c       	adc	r13, r1
     dde:	0f b6       	in	r0, 0x3f	; 63
     de0:	f8 94       	cli
     de2:	0f 92       	push	r0
     de4:	f7 01       	movw	r30, r14
     de6:	26 8d       	ldd	r18, Z+30	; 0x1e
     de8:	97 8d       	ldd	r25, Z+31	; 0x1f
     dea:	29 17       	cp	r18, r25
     dec:	10 f0       	brcs	.+4      	; 0xdf2 <xQueueGenericSend+0x54>
     dee:	02 30       	cpi	r16, 0x02	; 2
     df0:	a9 f4       	brne	.+42     	; 0xe1c <xQueueGenericSend+0x7e>
     df2:	40 2f       	mov	r20, r16
     df4:	b5 01       	movw	r22, r10
     df6:	c7 01       	movw	r24, r14
     df8:	ac de       	rcall	.-680    	; 0xb52 <prvCopyDataToQueue>
     dfa:	f7 01       	movw	r30, r14
     dfc:	93 89       	ldd	r25, Z+19	; 0x13
     dfe:	99 23       	and	r25, r25
     e00:	39 f0       	breq	.+14     	; 0xe10 <xQueueGenericSend+0x72>
     e02:	c7 01       	movw	r24, r14
     e04:	43 96       	adiw	r24, 0x13	; 19
     e06:	72 d5       	rcall	.+2788   	; 0x18ec <xTaskRemoveFromEventList>
     e08:	81 30       	cpi	r24, 0x01	; 1
     e0a:	21 f4       	brne	.+8      	; 0xe14 <xQueueGenericSend+0x76>
     e0c:	ee dd       	rcall	.-1060   	; 0x9ea <vPortYield>
     e0e:	02 c0       	rjmp	.+4      	; 0xe14 <xQueueGenericSend+0x76>
     e10:	81 11       	cpse	r24, r1
     e12:	eb dd       	rcall	.-1066   	; 0x9ea <vPortYield>
     e14:	0f 90       	pop	r0
     e16:	0f be       	out	0x3f, r0	; 63
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	4b c0       	rjmp	.+150    	; 0xeb2 <xQueueGenericSend+0x114>
     e1c:	8e 81       	ldd	r24, Y+6	; 0x06
     e1e:	9f 81       	ldd	r25, Y+7	; 0x07
     e20:	a8 85       	ldd	r26, Y+8	; 0x08
     e22:	b9 85       	ldd	r27, Y+9	; 0x09
     e24:	89 2b       	or	r24, r25
     e26:	8a 2b       	or	r24, r26
     e28:	8b 2b       	or	r24, r27
     e2a:	21 f4       	brne	.+8      	; 0xe34 <xQueueGenericSend+0x96>
     e2c:	0f 90       	pop	r0
     e2e:	0f be       	out	0x3f, r0	; 63
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	3f c0       	rjmp	.+126    	; 0xeb2 <xQueueGenericSend+0x114>
     e34:	11 11       	cpse	r17, r1
     e36:	04 c0       	rjmp	.+8      	; 0xe40 <xQueueGenericSend+0xa2>
     e38:	ce 01       	movw	r24, r28
     e3a:	01 96       	adiw	r24, 0x01	; 1
     e3c:	99 d5       	rcall	.+2866   	; 0x1970 <vTaskSetTimeOutState>
     e3e:	19 2d       	mov	r17, r9
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	a9 d2       	rcall	.+1362   	; 0x1398 <vTaskSuspendAll>
     e46:	0f b6       	in	r0, 0x3f	; 63
     e48:	f8 94       	cli
     e4a:	0f 92       	push	r0
     e4c:	f7 01       	movw	r30, r14
     e4e:	81 a1       	ldd	r24, Z+33	; 0x21
     e50:	8f 3f       	cpi	r24, 0xFF	; 255
     e52:	09 f4       	brne	.+2      	; 0xe56 <xQueueGenericSend+0xb8>
     e54:	11 a2       	std	Z+33, r1	; 0x21
     e56:	f7 01       	movw	r30, r14
     e58:	82 a1       	ldd	r24, Z+34	; 0x22
     e5a:	8f 3f       	cpi	r24, 0xFF	; 255
     e5c:	09 f4       	brne	.+2      	; 0xe60 <xQueueGenericSend+0xc2>
     e5e:	12 a2       	std	Z+34, r1	; 0x22
     e60:	0f 90       	pop	r0
     e62:	0f be       	out	0x3f, r0	; 63
     e64:	be 01       	movw	r22, r28
     e66:	6a 5f       	subi	r22, 0xFA	; 250
     e68:	7f 4f       	sbci	r23, 0xFF	; 255
     e6a:	ce 01       	movw	r24, r28
     e6c:	01 96       	adiw	r24, 0x01	; 1
     e6e:	91 d5       	rcall	.+2850   	; 0x1992 <xTaskCheckForTimeOut>
     e70:	81 11       	cpse	r24, r1
     e72:	1b c0       	rjmp	.+54     	; 0xeaa <xQueueGenericSend+0x10c>
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
     e7a:	f7 01       	movw	r30, r14
     e7c:	96 8d       	ldd	r25, Z+30	; 0x1e
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	87 8d       	ldd	r24, Z+31	; 0x1f
     e84:	98 13       	cpse	r25, r24
     e86:	0d c0       	rjmp	.+26     	; 0xea2 <xQueueGenericSend+0x104>
     e88:	4e 81       	ldd	r20, Y+6	; 0x06
     e8a:	5f 81       	ldd	r21, Y+7	; 0x07
     e8c:	68 85       	ldd	r22, Y+8	; 0x08
     e8e:	79 85       	ldd	r23, Y+9	; 0x09
     e90:	c6 01       	movw	r24, r12
     e92:	02 d5       	rcall	.+2564   	; 0x1898 <vTaskPlaceOnEventList>
     e94:	c7 01       	movw	r24, r14
     e96:	d8 de       	rcall	.-592    	; 0xc48 <prvUnlockQueue>
     e98:	a0 d3       	rcall	.+1856   	; 0x15da <xTaskResumeAll>
     e9a:	81 11       	cpse	r24, r1
     e9c:	a0 cf       	rjmp	.-192    	; 0xdde <xQueueGenericSend+0x40>
     e9e:	a5 dd       	rcall	.-1206   	; 0x9ea <vPortYield>
     ea0:	9e cf       	rjmp	.-196    	; 0xdde <xQueueGenericSend+0x40>
     ea2:	c7 01       	movw	r24, r14
     ea4:	d1 de       	rcall	.-606    	; 0xc48 <prvUnlockQueue>
     ea6:	99 d3       	rcall	.+1842   	; 0x15da <xTaskResumeAll>
     ea8:	9a cf       	rjmp	.-204    	; 0xdde <xQueueGenericSend+0x40>
     eaa:	c7 01       	movw	r24, r14
     eac:	cd de       	rcall	.-614    	; 0xc48 <prvUnlockQueue>
     eae:	95 d3       	rcall	.+1834   	; 0x15da <xTaskResumeAll>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	29 96       	adiw	r28, 0x09	; 9
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	1f 91       	pop	r17
     ec4:	0f 91       	pop	r16
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	08 95       	ret

00000ed6 <xQueueGenericReceive>:
     ed6:	9f 92       	push	r9
     ed8:	af 92       	push	r10
     eda:	bf 92       	push	r11
     edc:	cf 92       	push	r12
     ede:	df 92       	push	r13
     ee0:	ef 92       	push	r14
     ee2:	ff 92       	push	r15
     ee4:	0f 93       	push	r16
     ee6:	1f 93       	push	r17
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	cd b7       	in	r28, 0x3d	; 61
     eee:	de b7       	in	r29, 0x3e	; 62
     ef0:	29 97       	sbiw	r28, 0x09	; 9
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	7c 01       	movw	r14, r24
     efe:	5b 01       	movw	r10, r22
     f00:	2e 83       	std	Y+6, r18	; 0x06
     f02:	3f 83       	std	Y+7, r19	; 0x07
     f04:	48 87       	std	Y+8, r20	; 0x08
     f06:	59 87       	std	Y+9, r21	; 0x09
     f08:	10 e0       	ldi	r17, 0x00	; 0
     f0a:	99 24       	eor	r9, r9
     f0c:	93 94       	inc	r9
     f0e:	6c 01       	movw	r12, r24
     f10:	83 e1       	ldi	r24, 0x13	; 19
     f12:	c8 0e       	add	r12, r24
     f14:	d1 1c       	adc	r13, r1
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	0f 92       	push	r0
     f1c:	f7 01       	movw	r30, r14
     f1e:	96 8d       	ldd	r25, Z+30	; 0x1e
     f20:	99 23       	and	r25, r25
     f22:	69 f1       	breq	.+90     	; 0xf7e <xQueueGenericReceive+0xa8>
     f24:	c6 80       	ldd	r12, Z+6	; 0x06
     f26:	d7 80       	ldd	r13, Z+7	; 0x07
     f28:	b5 01       	movw	r22, r10
     f2a:	c7 01       	movw	r24, r14
     f2c:	73 de       	rcall	.-794    	; 0xc14 <prvCopyDataFromQueue>
     f2e:	01 11       	cpse	r16, r1
     f30:	17 c0       	rjmp	.+46     	; 0xf60 <xQueueGenericReceive+0x8a>
     f32:	f7 01       	movw	r30, r14
     f34:	86 8d       	ldd	r24, Z+30	; 0x1e
     f36:	81 50       	subi	r24, 0x01	; 1
     f38:	86 8f       	std	Z+30, r24	; 0x1e
     f3a:	80 81       	ld	r24, Z
     f3c:	91 81       	ldd	r25, Z+1	; 0x01
     f3e:	89 2b       	or	r24, r25
     f40:	21 f4       	brne	.+8      	; 0xf4a <xQueueGenericReceive+0x74>
     f42:	40 d6       	rcall	.+3200   	; 0x1bc4 <pvTaskIncrementMutexHeldCount>
     f44:	f7 01       	movw	r30, r14
     f46:	93 83       	std	Z+3, r25	; 0x03
     f48:	82 83       	std	Z+2, r24	; 0x02
     f4a:	f7 01       	movw	r30, r14
     f4c:	80 85       	ldd	r24, Z+8	; 0x08
     f4e:	88 23       	and	r24, r24
     f50:	91 f0       	breq	.+36     	; 0xf76 <xQueueGenericReceive+0xa0>
     f52:	c7 01       	movw	r24, r14
     f54:	08 96       	adiw	r24, 0x08	; 8
     f56:	ca d4       	rcall	.+2452   	; 0x18ec <xTaskRemoveFromEventList>
     f58:	81 30       	cpi	r24, 0x01	; 1
     f5a:	69 f4       	brne	.+26     	; 0xf76 <xQueueGenericReceive+0xa0>
     f5c:	46 dd       	rcall	.-1396   	; 0x9ea <vPortYield>
     f5e:	0b c0       	rjmp	.+22     	; 0xf76 <xQueueGenericReceive+0xa0>
     f60:	f7 01       	movw	r30, r14
     f62:	d7 82       	std	Z+7, r13	; 0x07
     f64:	c6 82       	std	Z+6, r12	; 0x06
     f66:	83 89       	ldd	r24, Z+19	; 0x13
     f68:	88 23       	and	r24, r24
     f6a:	29 f0       	breq	.+10     	; 0xf76 <xQueueGenericReceive+0xa0>
     f6c:	c7 01       	movw	r24, r14
     f6e:	43 96       	adiw	r24, 0x13	; 19
     f70:	bd d4       	rcall	.+2426   	; 0x18ec <xTaskRemoveFromEventList>
     f72:	81 11       	cpse	r24, r1
     f74:	3a dd       	rcall	.-1420   	; 0x9ea <vPortYield>
     f76:	0f 90       	pop	r0
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	81 e0       	ldi	r24, 0x01	; 1
     f7c:	56 c0       	rjmp	.+172    	; 0x102a <xQueueGenericReceive+0x154>
     f7e:	8e 81       	ldd	r24, Y+6	; 0x06
     f80:	9f 81       	ldd	r25, Y+7	; 0x07
     f82:	a8 85       	ldd	r26, Y+8	; 0x08
     f84:	b9 85       	ldd	r27, Y+9	; 0x09
     f86:	89 2b       	or	r24, r25
     f88:	8a 2b       	or	r24, r26
     f8a:	8b 2b       	or	r24, r27
     f8c:	21 f4       	brne	.+8      	; 0xf96 <xQueueGenericReceive+0xc0>
     f8e:	0f 90       	pop	r0
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	80 e0       	ldi	r24, 0x00	; 0
     f94:	4a c0       	rjmp	.+148    	; 0x102a <xQueueGenericReceive+0x154>
     f96:	11 11       	cpse	r17, r1
     f98:	04 c0       	rjmp	.+8      	; 0xfa2 <xQueueGenericReceive+0xcc>
     f9a:	ce 01       	movw	r24, r28
     f9c:	01 96       	adiw	r24, 0x01	; 1
     f9e:	e8 d4       	rcall	.+2512   	; 0x1970 <vTaskSetTimeOutState>
     fa0:	19 2d       	mov	r17, r9
     fa2:	0f 90       	pop	r0
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	f8 d1       	rcall	.+1008   	; 0x1398 <vTaskSuspendAll>
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	0f 92       	push	r0
     fae:	f7 01       	movw	r30, r14
     fb0:	81 a1       	ldd	r24, Z+33	; 0x21
     fb2:	8f 3f       	cpi	r24, 0xFF	; 255
     fb4:	09 f4       	brne	.+2      	; 0xfb8 <xQueueGenericReceive+0xe2>
     fb6:	11 a2       	std	Z+33, r1	; 0x21
     fb8:	f7 01       	movw	r30, r14
     fba:	82 a1       	ldd	r24, Z+34	; 0x22
     fbc:	8f 3f       	cpi	r24, 0xFF	; 255
     fbe:	09 f4       	brne	.+2      	; 0xfc2 <xQueueGenericReceive+0xec>
     fc0:	12 a2       	std	Z+34, r1	; 0x22
     fc2:	0f 90       	pop	r0
     fc4:	0f be       	out	0x3f, r0	; 63
     fc6:	be 01       	movw	r22, r28
     fc8:	6a 5f       	subi	r22, 0xFA	; 250
     fca:	7f 4f       	sbci	r23, 0xFF	; 255
     fcc:	ce 01       	movw	r24, r28
     fce:	01 96       	adiw	r24, 0x01	; 1
     fd0:	e0 d4       	rcall	.+2496   	; 0x1992 <xTaskCheckForTimeOut>
     fd2:	81 11       	cpse	r24, r1
     fd4:	26 c0       	rjmp	.+76     	; 0x1022 <xQueueGenericReceive+0x14c>
     fd6:	0f b6       	in	r0, 0x3f	; 63
     fd8:	f8 94       	cli
     fda:	0f 92       	push	r0
     fdc:	f7 01       	movw	r30, r14
     fde:	86 8d       	ldd	r24, Z+30	; 0x1e
     fe0:	0f 90       	pop	r0
     fe2:	0f be       	out	0x3f, r0	; 63
     fe4:	81 11       	cpse	r24, r1
     fe6:	19 c0       	rjmp	.+50     	; 0x101a <xQueueGenericReceive+0x144>
     fe8:	80 81       	ld	r24, Z
     fea:	91 81       	ldd	r25, Z+1	; 0x01
     fec:	89 2b       	or	r24, r25
     fee:	41 f4       	brne	.+16     	; 0x1000 <xQueueGenericReceive+0x12a>
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	f8 94       	cli
     ff4:	0f 92       	push	r0
     ff6:	82 81       	ldd	r24, Z+2	; 0x02
     ff8:	93 81       	ldd	r25, Z+3	; 0x03
     ffa:	46 d5       	rcall	.+2700   	; 0x1a88 <vTaskPriorityInherit>
     ffc:	0f 90       	pop	r0
     ffe:	0f be       	out	0x3f, r0	; 63
    1000:	4e 81       	ldd	r20, Y+6	; 0x06
    1002:	5f 81       	ldd	r21, Y+7	; 0x07
    1004:	68 85       	ldd	r22, Y+8	; 0x08
    1006:	79 85       	ldd	r23, Y+9	; 0x09
    1008:	c6 01       	movw	r24, r12
    100a:	46 d4       	rcall	.+2188   	; 0x1898 <vTaskPlaceOnEventList>
    100c:	c7 01       	movw	r24, r14
    100e:	1c de       	rcall	.-968    	; 0xc48 <prvUnlockQueue>
    1010:	e4 d2       	rcall	.+1480   	; 0x15da <xTaskResumeAll>
    1012:	81 11       	cpse	r24, r1
    1014:	80 cf       	rjmp	.-256    	; 0xf16 <xQueueGenericReceive+0x40>
    1016:	e9 dc       	rcall	.-1582   	; 0x9ea <vPortYield>
    1018:	7e cf       	rjmp	.-260    	; 0xf16 <xQueueGenericReceive+0x40>
    101a:	c7 01       	movw	r24, r14
    101c:	15 de       	rcall	.-982    	; 0xc48 <prvUnlockQueue>
    101e:	dd d2       	rcall	.+1466   	; 0x15da <xTaskResumeAll>
    1020:	7a cf       	rjmp	.-268    	; 0xf16 <xQueueGenericReceive+0x40>
    1022:	c7 01       	movw	r24, r14
    1024:	11 de       	rcall	.-990    	; 0xc48 <prvUnlockQueue>
    1026:	d9 d2       	rcall	.+1458   	; 0x15da <xTaskResumeAll>
    1028:	80 e0       	ldi	r24, 0x00	; 0
    102a:	29 96       	adiw	r28, 0x09	; 9
    102c:	0f b6       	in	r0, 0x3f	; 63
    102e:	f8 94       	cli
    1030:	de bf       	out	0x3e, r29	; 62
    1032:	0f be       	out	0x3f, r0	; 63
    1034:	cd bf       	out	0x3d, r28	; 61
    1036:	df 91       	pop	r29
    1038:	cf 91       	pop	r28
    103a:	1f 91       	pop	r17
    103c:	0f 91       	pop	r16
    103e:	ff 90       	pop	r15
    1040:	ef 90       	pop	r14
    1042:	df 90       	pop	r13
    1044:	cf 90       	pop	r12
    1046:	bf 90       	pop	r11
    1048:	af 90       	pop	r10
    104a:	9f 90       	pop	r9
    104c:	08 95       	ret

0000104e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1054:	fc 01       	movw	r30, r24
    1056:	86 8d       	ldd	r24, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
    1058:	0f 90       	pop	r0
    105a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    105c:	08 95       	ret

0000105e <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    105e:	0f b6       	in	r0, 0x3f	; 63
    1060:	f8 94       	cli
    1062:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1064:	fc 01       	movw	r30, r24
    1066:	26 8d       	ldd	r18, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
    1068:	0f 90       	pop	r0
    106a:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    106c:	87 8d       	ldd	r24, Z+31	; 0x1f
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    106e:	82 1b       	sub	r24, r18
    1070:	08 95       	ret

00001072 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1072:	ce ef       	ldi	r28, 0xFE	; 254
    1074:	d9 e1       	ldi	r29, 0x19	; 25
    1076:	88 81       	ld	r24, Y
    1078:	82 30       	cpi	r24, 0x02	; 2
    107a:	f0 f3       	brcs	.-4      	; 0x1078 <prvIdleTask+0x6>
    107c:	b6 dc       	rcall	.-1684   	; 0x9ea <vPortYield>
    107e:	fb cf       	rjmp	.-10     	; 0x1076 <prvIdleTask+0x4>

00001080 <prvAddCurrentTaskToDelayedList>:
    1080:	cf 92       	push	r12
    1082:	df 92       	push	r13
    1084:	ef 92       	push	r14
    1086:	ff 92       	push	r15
    1088:	6b 01       	movw	r12, r22
    108a:	7c 01       	movw	r14, r24
    108c:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1090:	f0 91 2b 1a 	lds	r31, 0x1A2B
    1094:	62 83       	std	Z+2, r22	; 0x02
    1096:	73 83       	std	Z+3, r23	; 0x03
    1098:	84 83       	std	Z+4, r24	; 0x04
    109a:	95 83       	std	Z+5, r25	; 0x05
    109c:	80 91 d2 19 	lds	r24, 0x19D2
    10a0:	90 91 d3 19 	lds	r25, 0x19D3
    10a4:	a0 91 d4 19 	lds	r26, 0x19D4
    10a8:	b0 91 d5 19 	lds	r27, 0x19D5
    10ac:	c8 16       	cp	r12, r24
    10ae:	d9 06       	cpc	r13, r25
    10b0:	ea 06       	cpc	r14, r26
    10b2:	fb 06       	cpc	r15, r27
    10b4:	60 f4       	brcc	.+24     	; 0x10ce <prvAddCurrentTaskToDelayedList+0x4e>
    10b6:	60 91 2a 1a 	lds	r22, 0x1A2A
    10ba:	70 91 2b 1a 	lds	r23, 0x1A2B
    10be:	80 91 e4 19 	lds	r24, 0x19E4
    10c2:	90 91 e5 19 	lds	r25, 0x19E5
    10c6:	6e 5f       	subi	r22, 0xFE	; 254
    10c8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ca:	81 db       	rcall	.-2302   	; 0x7ce <vListInsert>
    10cc:	20 c0       	rjmp	.+64     	; 0x110e <prvAddCurrentTaskToDelayedList+0x8e>
    10ce:	60 91 2a 1a 	lds	r22, 0x1A2A
    10d2:	70 91 2b 1a 	lds	r23, 0x1A2B
    10d6:	80 91 e6 19 	lds	r24, 0x19E6
    10da:	90 91 e7 19 	lds	r25, 0x19E7
    10de:	6e 5f       	subi	r22, 0xFE	; 254
    10e0:	7f 4f       	sbci	r23, 0xFF	; 255
    10e2:	75 db       	rcall	.-2326   	; 0x7ce <vListInsert>
    10e4:	80 91 02 02 	lds	r24, 0x0202
    10e8:	90 91 03 02 	lds	r25, 0x0203
    10ec:	a0 91 04 02 	lds	r26, 0x0204
    10f0:	b0 91 05 02 	lds	r27, 0x0205
    10f4:	c8 16       	cp	r12, r24
    10f6:	d9 06       	cpc	r13, r25
    10f8:	ea 06       	cpc	r14, r26
    10fa:	fb 06       	cpc	r15, r27
    10fc:	40 f4       	brcc	.+16     	; 0x110e <prvAddCurrentTaskToDelayedList+0x8e>
    10fe:	c0 92 02 02 	sts	0x0202, r12
    1102:	d0 92 03 02 	sts	0x0203, r13
    1106:	e0 92 04 02 	sts	0x0204, r14
    110a:	f0 92 05 02 	sts	0x0205, r15
    110e:	ff 90       	pop	r15
    1110:	ef 90       	pop	r14
    1112:	df 90       	pop	r13
    1114:	cf 90       	pop	r12
    1116:	08 95       	ret

00001118 <xTaskGenericCreate>:
    1118:	4f 92       	push	r4
    111a:	5f 92       	push	r5
    111c:	6f 92       	push	r6
    111e:	7f 92       	push	r7
    1120:	8f 92       	push	r8
    1122:	9f 92       	push	r9
    1124:	af 92       	push	r10
    1126:	bf 92       	push	r11
    1128:	cf 92       	push	r12
    112a:	df 92       	push	r13
    112c:	ef 92       	push	r14
    112e:	ff 92       	push	r15
    1130:	0f 93       	push	r16
    1132:	1f 93       	push	r17
    1134:	cf 93       	push	r28
    1136:	df 93       	push	r29
    1138:	4c 01       	movw	r8, r24
    113a:	eb 01       	movw	r28, r22
    113c:	5a 01       	movw	r10, r20
    113e:	29 01       	movw	r4, r18
    1140:	89 e2       	ldi	r24, 0x29	; 41
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	40 da       	rcall	.-2944   	; 0x5c6 <pvPortMalloc>
    1146:	3c 01       	movw	r6, r24
    1148:	00 97       	sbiw	r24, 0x00	; 0
    114a:	09 f4       	brne	.+2      	; 0x114e <xTaskGenericCreate+0x36>
    114c:	d4 c0       	rjmp	.+424    	; 0x12f6 <xTaskGenericCreate+0x1de>
    114e:	c1 14       	cp	r12, r1
    1150:	d1 04       	cpc	r13, r1
    1152:	09 f0       	breq	.+2      	; 0x1156 <xTaskGenericCreate+0x3e>
    1154:	cb c0       	rjmp	.+406    	; 0x12ec <xTaskGenericCreate+0x1d4>
    1156:	c5 01       	movw	r24, r10
    1158:	36 da       	rcall	.-2964   	; 0x5c6 <pvPortMalloc>
    115a:	f3 01       	movw	r30, r6
    115c:	94 8f       	std	Z+28, r25	; 0x1c
    115e:	83 8f       	std	Z+27, r24	; 0x1b
    1160:	00 97       	sbiw	r24, 0x00	; 0
    1162:	19 f4       	brne	.+6      	; 0x116a <xTaskGenericCreate+0x52>
    1164:	c3 01       	movw	r24, r6
    1166:	c7 da       	rcall	.-2674   	; 0x6f6 <vPortFree>
    1168:	c6 c0       	rjmp	.+396    	; 0x12f6 <xTaskGenericCreate+0x1de>
    116a:	a5 01       	movw	r20, r10
    116c:	65 ea       	ldi	r22, 0xA5	; 165
    116e:	70 e0       	ldi	r23, 0x00	; 0
    1170:	0e 94 06 1a 	call	0x340c	; 0x340c <memset>
    1174:	f1 e0       	ldi	r31, 0x01	; 1
    1176:	af 1a       	sub	r10, r31
    1178:	b1 08       	sbc	r11, r1
    117a:	f3 01       	movw	r30, r6
    117c:	83 8d       	ldd	r24, Z+27	; 0x1b
    117e:	94 8d       	ldd	r25, Z+28	; 0x1c
    1180:	a8 0e       	add	r10, r24
    1182:	b9 1e       	adc	r11, r25
    1184:	88 81       	ld	r24, Y
    1186:	85 8f       	std	Z+29, r24	; 0x1d
    1188:	88 81       	ld	r24, Y
    118a:	88 23       	and	r24, r24
    118c:	81 f0       	breq	.+32     	; 0x11ae <xTaskGenericCreate+0x96>
    118e:	d3 01       	movw	r26, r6
    1190:	5e 96       	adiw	r26, 0x1e	; 30
    1192:	fe 01       	movw	r30, r28
    1194:	31 96       	adiw	r30, 0x01	; 1
    1196:	9e 01       	movw	r18, r28
    1198:	26 5f       	subi	r18, 0xF6	; 246
    119a:	3f 4f       	sbci	r19, 0xFF	; 255
    119c:	ef 01       	movw	r28, r30
    119e:	81 91       	ld	r24, Z+
    11a0:	8d 93       	st	X+, r24
    11a2:	88 81       	ld	r24, Y
    11a4:	88 23       	and	r24, r24
    11a6:	19 f0       	breq	.+6      	; 0x11ae <xTaskGenericCreate+0x96>
    11a8:	e2 17       	cp	r30, r18
    11aa:	f3 07       	cpc	r31, r19
    11ac:	b9 f7       	brne	.-18     	; 0x119c <xTaskGenericCreate+0x84>
    11ae:	f3 01       	movw	r30, r6
    11b0:	16 a2       	std	Z+38, r1	; 0x26
    11b2:	10 2f       	mov	r17, r16
    11b4:	04 30       	cpi	r16, 0x04	; 4
    11b6:	08 f0       	brcs	.+2      	; 0x11ba <xTaskGenericCreate+0xa2>
    11b8:	13 e0       	ldi	r17, 0x03	; 3
    11ba:	f3 01       	movw	r30, r6
    11bc:	12 8f       	std	Z+26, r17	; 0x1a
    11be:	17 a3       	std	Z+39, r17	; 0x27
    11c0:	10 a6       	std	Z+40, r1	; 0x28
    11c2:	e3 01       	movw	r28, r6
    11c4:	22 96       	adiw	r28, 0x02	; 2
    11c6:	ce 01       	movw	r24, r28
    11c8:	dd da       	rcall	.-2630   	; 0x784 <vListInitialiseItem>
    11ca:	c3 01       	movw	r24, r6
    11cc:	0e 96       	adiw	r24, 0x0e	; 14
    11ce:	da da       	rcall	.-2636   	; 0x784 <vListInitialiseItem>
    11d0:	f3 01       	movw	r30, r6
    11d2:	73 86       	std	Z+11, r7	; 0x0b
    11d4:	62 86       	std	Z+10, r6	; 0x0a
    11d6:	84 e0       	ldi	r24, 0x04	; 4
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	a0 e0       	ldi	r26, 0x00	; 0
    11dc:	b0 e0       	ldi	r27, 0x00	; 0
    11de:	81 1b       	sub	r24, r17
    11e0:	91 09       	sbc	r25, r1
    11e2:	a1 09       	sbc	r26, r1
    11e4:	b1 09       	sbc	r27, r1
    11e6:	86 87       	std	Z+14, r24	; 0x0e
    11e8:	97 87       	std	Z+15, r25	; 0x0f
    11ea:	a0 8b       	std	Z+16, r26	; 0x10
    11ec:	b1 8b       	std	Z+17, r27	; 0x11
    11ee:	77 8a       	std	Z+23, r7	; 0x17
    11f0:	66 8a       	std	Z+22, r6	; 0x16
    11f2:	a2 01       	movw	r20, r4
    11f4:	b4 01       	movw	r22, r8
    11f6:	c5 01       	movw	r24, r10
    11f8:	4d db       	rcall	.-2406   	; 0x894 <pxPortInitialiseStack>
    11fa:	f3 01       	movw	r30, r6
    11fc:	91 83       	std	Z+1, r25	; 0x01
    11fe:	80 83       	st	Z, r24
    1200:	e1 14       	cp	r14, r1
    1202:	f1 04       	cpc	r15, r1
    1204:	19 f0       	breq	.+6      	; 0x120c <xTaskGenericCreate+0xf4>
    1206:	f7 01       	movw	r30, r14
    1208:	71 82       	std	Z+1, r7	; 0x01
    120a:	60 82       	st	Z, r6
    120c:	0f b6       	in	r0, 0x3f	; 63
    120e:	f8 94       	cli
    1210:	0f 92       	push	r0
    1212:	80 91 d6 19 	lds	r24, 0x19D6
    1216:	8f 5f       	subi	r24, 0xFF	; 255
    1218:	80 93 d6 19 	sts	0x19D6, r24
    121c:	80 91 2a 1a 	lds	r24, 0x1A2A
    1220:	90 91 2b 1a 	lds	r25, 0x1A2B
    1224:	89 2b       	or	r24, r25
    1226:	51 f5       	brne	.+84     	; 0x127c <xTaskGenericCreate+0x164>
    1228:	70 92 2b 1a 	sts	0x1A2B, r7
    122c:	60 92 2a 1a 	sts	0x1A2A, r6
    1230:	80 91 d6 19 	lds	r24, 0x19D6
    1234:	81 30       	cpi	r24, 0x01	; 1
    1236:	89 f5       	brne	.+98     	; 0x129a <xTaskGenericCreate+0x182>
    1238:	8e ef       	ldi	r24, 0xFE	; 254
    123a:	99 e1       	ldi	r25, 0x19	; 25
    123c:	92 da       	rcall	.-2780   	; 0x762 <vListInitialise>
    123e:	89 e0       	ldi	r24, 0x09	; 9
    1240:	9a e1       	ldi	r25, 0x1A	; 26
    1242:	8f da       	rcall	.-2786   	; 0x762 <vListInitialise>
    1244:	84 e1       	ldi	r24, 0x14	; 20
    1246:	9a e1       	ldi	r25, 0x1A	; 26
    1248:	8c da       	rcall	.-2792   	; 0x762 <vListInitialise>
    124a:	8f e1       	ldi	r24, 0x1F	; 31
    124c:	9a e1       	ldi	r25, 0x1A	; 26
    124e:	89 da       	rcall	.-2798   	; 0x762 <vListInitialise>
    1250:	83 ef       	ldi	r24, 0xF3	; 243
    1252:	99 e1       	ldi	r25, 0x19	; 25
    1254:	86 da       	rcall	.-2804   	; 0x762 <vListInitialise>
    1256:	88 ee       	ldi	r24, 0xE8	; 232
    1258:	99 e1       	ldi	r25, 0x19	; 25
    125a:	83 da       	rcall	.-2810   	; 0x762 <vListInitialise>
    125c:	89 ed       	ldi	r24, 0xD9	; 217
    125e:	99 e1       	ldi	r25, 0x19	; 25
    1260:	80 da       	rcall	.-2816   	; 0x762 <vListInitialise>
    1262:	83 ef       	ldi	r24, 0xF3	; 243
    1264:	99 e1       	ldi	r25, 0x19	; 25
    1266:	90 93 e7 19 	sts	0x19E7, r25
    126a:	80 93 e6 19 	sts	0x19E6, r24
    126e:	88 ee       	ldi	r24, 0xE8	; 232
    1270:	99 e1       	ldi	r25, 0x19	; 25
    1272:	90 93 e5 19 	sts	0x19E5, r25
    1276:	80 93 e4 19 	sts	0x19E4, r24
    127a:	0f c0       	rjmp	.+30     	; 0x129a <xTaskGenericCreate+0x182>
    127c:	80 91 d0 19 	lds	r24, 0x19D0
    1280:	81 11       	cpse	r24, r1
    1282:	0b c0       	rjmp	.+22     	; 0x129a <xTaskGenericCreate+0x182>
    1284:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1288:	f0 91 2b 1a 	lds	r31, 0x1A2B
    128c:	82 8d       	ldd	r24, Z+26	; 0x1a
    128e:	08 17       	cp	r16, r24
    1290:	20 f0       	brcs	.+8      	; 0x129a <xTaskGenericCreate+0x182>
    1292:	70 92 2b 1a 	sts	0x1A2B, r7
    1296:	60 92 2a 1a 	sts	0x1A2A, r6
    129a:	80 91 cc 19 	lds	r24, 0x19CC
    129e:	8f 5f       	subi	r24, 0xFF	; 255
    12a0:	80 93 cc 19 	sts	0x19CC, r24
    12a4:	f3 01       	movw	r30, r6
    12a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    12a8:	90 91 d1 19 	lds	r25, 0x19D1
    12ac:	98 17       	cp	r25, r24
    12ae:	10 f4       	brcc	.+4      	; 0x12b4 <xTaskGenericCreate+0x19c>
    12b0:	80 93 d1 19 	sts	0x19D1, r24
    12b4:	fb e0       	ldi	r31, 0x0B	; 11
    12b6:	8f 9f       	mul	r24, r31
    12b8:	c0 01       	movw	r24, r0
    12ba:	11 24       	eor	r1, r1
    12bc:	be 01       	movw	r22, r28
    12be:	82 50       	subi	r24, 0x02	; 2
    12c0:	96 4e       	sbci	r25, 0xE6	; 230
    12c2:	64 da       	rcall	.-2872   	; 0x78c <vListInsertEnd>
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
    12c8:	80 91 d0 19 	lds	r24, 0x19D0
    12cc:	88 23       	and	r24, r24
    12ce:	51 f0       	breq	.+20     	; 0x12e4 <xTaskGenericCreate+0x1cc>
    12d0:	e0 91 2a 1a 	lds	r30, 0x1A2A
    12d4:	f0 91 2b 1a 	lds	r31, 0x1A2B
    12d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    12da:	80 17       	cp	r24, r16
    12dc:	28 f4       	brcc	.+10     	; 0x12e8 <xTaskGenericCreate+0x1d0>
    12de:	85 db       	rcall	.-2294   	; 0x9ea <vPortYield>
    12e0:	81 e0       	ldi	r24, 0x01	; 1
    12e2:	0a c0       	rjmp	.+20     	; 0x12f8 <xTaskGenericCreate+0x1e0>
    12e4:	81 e0       	ldi	r24, 0x01	; 1
    12e6:	08 c0       	rjmp	.+16     	; 0x12f8 <xTaskGenericCreate+0x1e0>
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	06 c0       	rjmp	.+12     	; 0x12f8 <xTaskGenericCreate+0x1e0>
    12ec:	fc 01       	movw	r30, r24
    12ee:	d4 8e       	std	Z+28, r13	; 0x1c
    12f0:	c3 8e       	std	Z+27, r12	; 0x1b
    12f2:	c6 01       	movw	r24, r12
    12f4:	3a cf       	rjmp	.-396    	; 0x116a <xTaskGenericCreate+0x52>
    12f6:	8f ef       	ldi	r24, 0xFF	; 255
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	1f 91       	pop	r17
    12fe:	0f 91       	pop	r16
    1300:	ff 90       	pop	r15
    1302:	ef 90       	pop	r14
    1304:	df 90       	pop	r13
    1306:	cf 90       	pop	r12
    1308:	bf 90       	pop	r11
    130a:	af 90       	pop	r10
    130c:	9f 90       	pop	r9
    130e:	8f 90       	pop	r8
    1310:	7f 90       	pop	r7
    1312:	6f 90       	pop	r6
    1314:	5f 90       	pop	r5
    1316:	4f 90       	pop	r4
    1318:	08 95       	ret

0000131a <uxTaskPriorityGet>:
    131a:	0f b6       	in	r0, 0x3f	; 63
    131c:	f8 94       	cli
    131e:	0f 92       	push	r0
    1320:	00 97       	sbiw	r24, 0x00	; 0
    1322:	21 f4       	brne	.+8      	; 0x132c <uxTaskPriorityGet+0x12>
    1324:	80 91 2a 1a 	lds	r24, 0x1A2A
    1328:	90 91 2b 1a 	lds	r25, 0x1A2B
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63
    1330:	fc 01       	movw	r30, r24
    1332:	82 8d       	ldd	r24, Z+26	; 0x1a
    1334:	08 95       	ret

00001336 <vTaskStartScheduler>:
    1336:	af 92       	push	r10
    1338:	bf 92       	push	r11
    133a:	cf 92       	push	r12
    133c:	df 92       	push	r13
    133e:	ef 92       	push	r14
    1340:	ff 92       	push	r15
    1342:	0f 93       	push	r16
    1344:	a1 2c       	mov	r10, r1
    1346:	b1 2c       	mov	r11, r1
    1348:	c1 2c       	mov	r12, r1
    134a:	d1 2c       	mov	r13, r1
    134c:	0f 2e       	mov	r0, r31
    134e:	f7 ed       	ldi	r31, 0xD7	; 215
    1350:	ef 2e       	mov	r14, r31
    1352:	f9 e1       	ldi	r31, 0x19	; 25
    1354:	ff 2e       	mov	r15, r31
    1356:	f0 2d       	mov	r31, r0
    1358:	00 e0       	ldi	r16, 0x00	; 0
    135a:	20 e0       	ldi	r18, 0x00	; 0
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	44 e6       	ldi	r20, 0x64	; 100
    1360:	50 e0       	ldi	r21, 0x00	; 0
    1362:	68 e0       	ldi	r22, 0x08	; 8
    1364:	72 e0       	ldi	r23, 0x02	; 2
    1366:	89 e3       	ldi	r24, 0x39	; 57
    1368:	98 e0       	ldi	r25, 0x08	; 8
    136a:	d6 de       	rcall	.-596    	; 0x1118 <xTaskGenericCreate>
    136c:	81 30       	cpi	r24, 0x01	; 1
    136e:	61 f4       	brne	.+24     	; 0x1388 <vTaskStartScheduler+0x52>
    1370:	f8 94       	cli
    1372:	80 93 d0 19 	sts	0x19D0, r24
    1376:	10 92 d2 19 	sts	0x19D2, r1
    137a:	10 92 d3 19 	sts	0x19D3, r1
    137e:	10 92 d4 19 	sts	0x19D4, r1
    1382:	10 92 d5 19 	sts	0x19D5, r1
    1386:	f6 da       	rcall	.-2580   	; 0x974 <xPortStartScheduler>
    1388:	0f 91       	pop	r16
    138a:	ff 90       	pop	r15
    138c:	ef 90       	pop	r14
    138e:	df 90       	pop	r13
    1390:	cf 90       	pop	r12
    1392:	bf 90       	pop	r11
    1394:	af 90       	pop	r10
    1396:	08 95       	ret

00001398 <vTaskSuspendAll>:
    1398:	80 91 cb 19 	lds	r24, 0x19CB
    139c:	8f 5f       	subi	r24, 0xFF	; 255
    139e:	80 93 cb 19 	sts	0x19CB, r24
    13a2:	08 95       	ret

000013a4 <xTaskGetTickCount>:
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	f8 94       	cli
    13a8:	0f 92       	push	r0
    13aa:	60 91 d2 19 	lds	r22, 0x19D2
    13ae:	70 91 d3 19 	lds	r23, 0x19D3
    13b2:	80 91 d4 19 	lds	r24, 0x19D4
    13b6:	90 91 d5 19 	lds	r25, 0x19D5
    13ba:	0f 90       	pop	r0
    13bc:	0f be       	out	0x3f, r0	; 63
    13be:	08 95       	ret

000013c0 <pcTaskGetTaskName>:
    13c0:	00 97       	sbiw	r24, 0x00	; 0
    13c2:	21 f4       	brne	.+8      	; 0x13cc <pcTaskGetTaskName+0xc>
    13c4:	80 91 2a 1a 	lds	r24, 0x1A2A
    13c8:	90 91 2b 1a 	lds	r25, 0x1A2B
    13cc:	4d 96       	adiw	r24, 0x1d	; 29
    13ce:	08 95       	ret

000013d0 <xTaskGetIdleTaskHandle>:
    13d0:	80 91 d7 19 	lds	r24, 0x19D7
    13d4:	90 91 d8 19 	lds	r25, 0x19D8
    13d8:	08 95       	ret

000013da <xTaskIncrementTick>:
    13da:	9f 92       	push	r9
    13dc:	af 92       	push	r10
    13de:	bf 92       	push	r11
    13e0:	cf 92       	push	r12
    13e2:	df 92       	push	r13
    13e4:	ef 92       	push	r14
    13e6:	ff 92       	push	r15
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	80 91 cb 19 	lds	r24, 0x19CB
    13f4:	81 11       	cpse	r24, r1
    13f6:	d8 c0       	rjmp	.+432    	; 0x15a8 <xTaskIncrementTick+0x1ce>
    13f8:	80 91 d2 19 	lds	r24, 0x19D2
    13fc:	90 91 d3 19 	lds	r25, 0x19D3
    1400:	a0 91 d4 19 	lds	r26, 0x19D4
    1404:	b0 91 d5 19 	lds	r27, 0x19D5
    1408:	01 96       	adiw	r24, 0x01	; 1
    140a:	a1 1d       	adc	r26, r1
    140c:	b1 1d       	adc	r27, r1
    140e:	80 93 d2 19 	sts	0x19D2, r24
    1412:	90 93 d3 19 	sts	0x19D3, r25
    1416:	a0 93 d4 19 	sts	0x19D4, r26
    141a:	b0 93 d5 19 	sts	0x19D5, r27
    141e:	c0 90 d2 19 	lds	r12, 0x19D2
    1422:	d0 90 d3 19 	lds	r13, 0x19D3
    1426:	e0 90 d4 19 	lds	r14, 0x19D4
    142a:	f0 90 d5 19 	lds	r15, 0x19D5
    142e:	c1 14       	cp	r12, r1
    1430:	d1 04       	cpc	r13, r1
    1432:	e1 04       	cpc	r14, r1
    1434:	f1 04       	cpc	r15, r1
    1436:	f1 f5       	brne	.+124    	; 0x14b4 <xTaskIncrementTick+0xda>
    1438:	80 91 e6 19 	lds	r24, 0x19E6
    143c:	90 91 e7 19 	lds	r25, 0x19E7
    1440:	20 91 e4 19 	lds	r18, 0x19E4
    1444:	30 91 e5 19 	lds	r19, 0x19E5
    1448:	30 93 e7 19 	sts	0x19E7, r19
    144c:	20 93 e6 19 	sts	0x19E6, r18
    1450:	90 93 e5 19 	sts	0x19E5, r25
    1454:	80 93 e4 19 	sts	0x19E4, r24
    1458:	80 91 cd 19 	lds	r24, 0x19CD
    145c:	8f 5f       	subi	r24, 0xFF	; 255
    145e:	80 93 cd 19 	sts	0x19CD, r24
    1462:	e0 91 e6 19 	lds	r30, 0x19E6
    1466:	f0 91 e7 19 	lds	r31, 0x19E7
    146a:	80 81       	ld	r24, Z
    146c:	81 11       	cpse	r24, r1
    146e:	0c c0       	rjmp	.+24     	; 0x1488 <xTaskIncrementTick+0xae>
    1470:	8f ef       	ldi	r24, 0xFF	; 255
    1472:	9f ef       	ldi	r25, 0xFF	; 255
    1474:	dc 01       	movw	r26, r24
    1476:	80 93 02 02 	sts	0x0202, r24
    147a:	90 93 03 02 	sts	0x0203, r25
    147e:	a0 93 04 02 	sts	0x0204, r26
    1482:	b0 93 05 02 	sts	0x0205, r27
    1486:	16 c0       	rjmp	.+44     	; 0x14b4 <xTaskIncrementTick+0xda>
    1488:	e0 91 e6 19 	lds	r30, 0x19E6
    148c:	f0 91 e7 19 	lds	r31, 0x19E7
    1490:	07 80       	ldd	r0, Z+7	; 0x07
    1492:	f0 85       	ldd	r31, Z+8	; 0x08
    1494:	e0 2d       	mov	r30, r0
    1496:	00 84       	ldd	r0, Z+8	; 0x08
    1498:	f1 85       	ldd	r31, Z+9	; 0x09
    149a:	e0 2d       	mov	r30, r0
    149c:	82 81       	ldd	r24, Z+2	; 0x02
    149e:	93 81       	ldd	r25, Z+3	; 0x03
    14a0:	a4 81       	ldd	r26, Z+4	; 0x04
    14a2:	b5 81       	ldd	r27, Z+5	; 0x05
    14a4:	80 93 02 02 	sts	0x0202, r24
    14a8:	90 93 03 02 	sts	0x0203, r25
    14ac:	a0 93 04 02 	sts	0x0204, r26
    14b0:	b0 93 05 02 	sts	0x0205, r27
    14b4:	80 91 02 02 	lds	r24, 0x0202
    14b8:	90 91 03 02 	lds	r25, 0x0203
    14bc:	a0 91 04 02 	lds	r26, 0x0204
    14c0:	b0 91 05 02 	lds	r27, 0x0205
    14c4:	c8 16       	cp	r12, r24
    14c6:	d9 06       	cpc	r13, r25
    14c8:	ea 06       	cpc	r14, r26
    14ca:	fb 06       	cpc	r15, r27
    14cc:	10 f4       	brcc	.+4      	; 0x14d2 <xTaskIncrementTick+0xf8>
    14ce:	b1 2c       	mov	r11, r1
    14d0:	5a c0       	rjmp	.+180    	; 0x1586 <xTaskIncrementTick+0x1ac>
    14d2:	b1 2c       	mov	r11, r1
    14d4:	0f 2e       	mov	r0, r31
    14d6:	fb e0       	ldi	r31, 0x0B	; 11
    14d8:	af 2e       	mov	r10, r31
    14da:	f0 2d       	mov	r31, r0
    14dc:	99 24       	eor	r9, r9
    14de:	93 94       	inc	r9
    14e0:	e0 91 e6 19 	lds	r30, 0x19E6
    14e4:	f0 91 e7 19 	lds	r31, 0x19E7
    14e8:	90 81       	ld	r25, Z
    14ea:	91 11       	cpse	r25, r1
    14ec:	0c c0       	rjmp	.+24     	; 0x1506 <xTaskIncrementTick+0x12c>
    14ee:	8f ef       	ldi	r24, 0xFF	; 255
    14f0:	9f ef       	ldi	r25, 0xFF	; 255
    14f2:	dc 01       	movw	r26, r24
    14f4:	80 93 02 02 	sts	0x0202, r24
    14f8:	90 93 03 02 	sts	0x0203, r25
    14fc:	a0 93 04 02 	sts	0x0204, r26
    1500:	b0 93 05 02 	sts	0x0205, r27
    1504:	40 c0       	rjmp	.+128    	; 0x1586 <xTaskIncrementTick+0x1ac>
    1506:	e0 91 e6 19 	lds	r30, 0x19E6
    150a:	f0 91 e7 19 	lds	r31, 0x19E7
    150e:	07 80       	ldd	r0, Z+7	; 0x07
    1510:	f0 85       	ldd	r31, Z+8	; 0x08
    1512:	e0 2d       	mov	r30, r0
    1514:	c0 85       	ldd	r28, Z+8	; 0x08
    1516:	d1 85       	ldd	r29, Z+9	; 0x09
    1518:	8a 81       	ldd	r24, Y+2	; 0x02
    151a:	9b 81       	ldd	r25, Y+3	; 0x03
    151c:	ac 81       	ldd	r26, Y+4	; 0x04
    151e:	bd 81       	ldd	r27, Y+5	; 0x05
    1520:	c8 16       	cp	r12, r24
    1522:	d9 06       	cpc	r13, r25
    1524:	ea 06       	cpc	r14, r26
    1526:	fb 06       	cpc	r15, r27
    1528:	48 f4       	brcc	.+18     	; 0x153c <xTaskIncrementTick+0x162>
    152a:	80 93 02 02 	sts	0x0202, r24
    152e:	90 93 03 02 	sts	0x0203, r25
    1532:	a0 93 04 02 	sts	0x0204, r26
    1536:	b0 93 05 02 	sts	0x0205, r27
    153a:	25 c0       	rjmp	.+74     	; 0x1586 <xTaskIncrementTick+0x1ac>
    153c:	8e 01       	movw	r16, r28
    153e:	0e 5f       	subi	r16, 0xFE	; 254
    1540:	1f 4f       	sbci	r17, 0xFF	; 255
    1542:	c8 01       	movw	r24, r16
    1544:	81 d9       	rcall	.-3326   	; 0x848 <uxListRemove>
    1546:	88 8d       	ldd	r24, Y+24	; 0x18
    1548:	99 8d       	ldd	r25, Y+25	; 0x19
    154a:	89 2b       	or	r24, r25
    154c:	19 f0       	breq	.+6      	; 0x1554 <xTaskIncrementTick+0x17a>
    154e:	ce 01       	movw	r24, r28
    1550:	0e 96       	adiw	r24, 0x0e	; 14
    1552:	7a d9       	rcall	.-3340   	; 0x848 <uxListRemove>
    1554:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1556:	80 91 d1 19 	lds	r24, 0x19D1
    155a:	82 17       	cp	r24, r18
    155c:	10 f4       	brcc	.+4      	; 0x1562 <xTaskIncrementTick+0x188>
    155e:	20 93 d1 19 	sts	0x19D1, r18
    1562:	a2 9e       	mul	r10, r18
    1564:	c0 01       	movw	r24, r0
    1566:	11 24       	eor	r1, r1
    1568:	b8 01       	movw	r22, r16
    156a:	82 50       	subi	r24, 0x02	; 2
    156c:	96 4e       	sbci	r25, 0xE6	; 230
    156e:	0e d9       	rcall	.-3556   	; 0x78c <vListInsertEnd>
    1570:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1574:	f0 91 2b 1a 	lds	r31, 0x1A2B
    1578:	9a 8d       	ldd	r25, Y+26	; 0x1a
    157a:	82 8d       	ldd	r24, Z+26	; 0x1a
    157c:	98 17       	cp	r25, r24
    157e:	08 f4       	brcc	.+2      	; 0x1582 <xTaskIncrementTick+0x1a8>
    1580:	af cf       	rjmp	.-162    	; 0x14e0 <xTaskIncrementTick+0x106>
    1582:	b9 2c       	mov	r11, r9
    1584:	ad cf       	rjmp	.-166    	; 0x14e0 <xTaskIncrementTick+0x106>
    1586:	e0 91 2a 1a 	lds	r30, 0x1A2A
    158a:	f0 91 2b 1a 	lds	r31, 0x1A2B
    158e:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1590:	8b e0       	ldi	r24, 0x0B	; 11
    1592:	e8 9f       	mul	r30, r24
    1594:	f0 01       	movw	r30, r0
    1596:	11 24       	eor	r1, r1
    1598:	e2 50       	subi	r30, 0x02	; 2
    159a:	f6 4e       	sbci	r31, 0xE6	; 230
    159c:	80 81       	ld	r24, Z
    159e:	82 30       	cpi	r24, 0x02	; 2
    15a0:	48 f0       	brcs	.+18     	; 0x15b4 <xTaskIncrementTick+0x1da>
    15a2:	bb 24       	eor	r11, r11
    15a4:	b3 94       	inc	r11
    15a6:	06 c0       	rjmp	.+12     	; 0x15b4 <xTaskIncrementTick+0x1da>
    15a8:	80 91 cf 19 	lds	r24, 0x19CF
    15ac:	8f 5f       	subi	r24, 0xFF	; 255
    15ae:	80 93 cf 19 	sts	0x19CF, r24
    15b2:	b1 2c       	mov	r11, r1
    15b4:	80 91 ce 19 	lds	r24, 0x19CE
    15b8:	88 23       	and	r24, r24
    15ba:	11 f0       	breq	.+4      	; 0x15c0 <xTaskIncrementTick+0x1e6>
    15bc:	bb 24       	eor	r11, r11
    15be:	b3 94       	inc	r11
    15c0:	8b 2d       	mov	r24, r11
    15c2:	df 91       	pop	r29
    15c4:	cf 91       	pop	r28
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	ff 90       	pop	r15
    15cc:	ef 90       	pop	r14
    15ce:	df 90       	pop	r13
    15d0:	cf 90       	pop	r12
    15d2:	bf 90       	pop	r11
    15d4:	af 90       	pop	r10
    15d6:	9f 90       	pop	r9
    15d8:	08 95       	ret

000015da <xTaskResumeAll>:
    15da:	cf 92       	push	r12
    15dc:	df 92       	push	r13
    15de:	ef 92       	push	r14
    15e0:	ff 92       	push	r15
    15e2:	0f 93       	push	r16
    15e4:	1f 93       	push	r17
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	f8 94       	cli
    15ee:	0f 92       	push	r0
    15f0:	80 91 cb 19 	lds	r24, 0x19CB
    15f4:	81 50       	subi	r24, 0x01	; 1
    15f6:	80 93 cb 19 	sts	0x19CB, r24
    15fa:	80 91 cb 19 	lds	r24, 0x19CB
    15fe:	81 11       	cpse	r24, r1
    1600:	5a c0       	rjmp	.+180    	; 0x16b6 <xTaskResumeAll+0xdc>
    1602:	80 91 d6 19 	lds	r24, 0x19D6
    1606:	81 11       	cpse	r24, r1
    1608:	29 c0       	rjmp	.+82     	; 0x165c <xTaskResumeAll+0x82>
    160a:	58 c0       	rjmp	.+176    	; 0x16bc <xTaskResumeAll+0xe2>
    160c:	d7 01       	movw	r26, r14
    160e:	17 96       	adiw	r26, 0x07	; 7
    1610:	ed 91       	ld	r30, X+
    1612:	fc 91       	ld	r31, X
    1614:	18 97       	sbiw	r26, 0x08	; 8
    1616:	c0 85       	ldd	r28, Z+8	; 0x08
    1618:	d1 85       	ldd	r29, Z+9	; 0x09
    161a:	ce 01       	movw	r24, r28
    161c:	0e 96       	adiw	r24, 0x0e	; 14
    161e:	14 d9       	rcall	.-3544   	; 0x848 <uxListRemove>
    1620:	8e 01       	movw	r16, r28
    1622:	0e 5f       	subi	r16, 0xFE	; 254
    1624:	1f 4f       	sbci	r17, 0xFF	; 255
    1626:	c8 01       	movw	r24, r16
    1628:	0f d9       	rcall	.-3554   	; 0x848 <uxListRemove>
    162a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    162c:	80 91 d1 19 	lds	r24, 0x19D1
    1630:	89 17       	cp	r24, r25
    1632:	10 f4       	brcc	.+4      	; 0x1638 <xTaskResumeAll+0x5e>
    1634:	90 93 d1 19 	sts	0x19D1, r25
    1638:	d9 9e       	mul	r13, r25
    163a:	c0 01       	movw	r24, r0
    163c:	11 24       	eor	r1, r1
    163e:	b8 01       	movw	r22, r16
    1640:	82 50       	subi	r24, 0x02	; 2
    1642:	96 4e       	sbci	r25, 0xE6	; 230
    1644:	a3 d8       	rcall	.-3770   	; 0x78c <vListInsertEnd>
    1646:	e0 91 2a 1a 	lds	r30, 0x1A2A
    164a:	f0 91 2b 1a 	lds	r31, 0x1A2B
    164e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1650:	82 8d       	ldd	r24, Z+26	; 0x1a
    1652:	98 17       	cp	r25, r24
    1654:	78 f0       	brcs	.+30     	; 0x1674 <xTaskResumeAll+0x9a>
    1656:	c0 92 ce 19 	sts	0x19CE, r12
    165a:	0c c0       	rjmp	.+24     	; 0x1674 <xTaskResumeAll+0x9a>
    165c:	0f 2e       	mov	r0, r31
    165e:	f9 ed       	ldi	r31, 0xD9	; 217
    1660:	ef 2e       	mov	r14, r31
    1662:	f9 e1       	ldi	r31, 0x19	; 25
    1664:	ff 2e       	mov	r15, r31
    1666:	f0 2d       	mov	r31, r0
    1668:	0f 2e       	mov	r0, r31
    166a:	fb e0       	ldi	r31, 0x0B	; 11
    166c:	df 2e       	mov	r13, r31
    166e:	f0 2d       	mov	r31, r0
    1670:	cc 24       	eor	r12, r12
    1672:	c3 94       	inc	r12
    1674:	f7 01       	movw	r30, r14
    1676:	80 81       	ld	r24, Z
    1678:	81 11       	cpse	r24, r1
    167a:	c8 cf       	rjmp	.-112    	; 0x160c <xTaskResumeAll+0x32>
    167c:	80 91 cf 19 	lds	r24, 0x19CF
    1680:	88 23       	and	r24, r24
    1682:	91 f0       	breq	.+36     	; 0x16a8 <xTaskResumeAll+0xce>
    1684:	80 91 cf 19 	lds	r24, 0x19CF
    1688:	88 23       	and	r24, r24
    168a:	71 f0       	breq	.+28     	; 0x16a8 <xTaskResumeAll+0xce>
    168c:	c1 e0       	ldi	r28, 0x01	; 1
    168e:	a5 de       	rcall	.-694    	; 0x13da <xTaskIncrementTick>
    1690:	81 11       	cpse	r24, r1
    1692:	c0 93 ce 19 	sts	0x19CE, r28
    1696:	80 91 cf 19 	lds	r24, 0x19CF
    169a:	81 50       	subi	r24, 0x01	; 1
    169c:	80 93 cf 19 	sts	0x19CF, r24
    16a0:	80 91 cf 19 	lds	r24, 0x19CF
    16a4:	81 11       	cpse	r24, r1
    16a6:	f3 cf       	rjmp	.-26     	; 0x168e <xTaskResumeAll+0xb4>
    16a8:	80 91 ce 19 	lds	r24, 0x19CE
    16ac:	81 30       	cpi	r24, 0x01	; 1
    16ae:	29 f4       	brne	.+10     	; 0x16ba <xTaskResumeAll+0xe0>
    16b0:	9c d9       	rcall	.-3272   	; 0x9ea <vPortYield>
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	03 c0       	rjmp	.+6      	; 0x16bc <xTaskResumeAll+0xe2>
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	01 c0       	rjmp	.+2      	; 0x16bc <xTaskResumeAll+0xe2>
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	df 91       	pop	r29
    16c2:	cf 91       	pop	r28
    16c4:	1f 91       	pop	r17
    16c6:	0f 91       	pop	r16
    16c8:	ff 90       	pop	r15
    16ca:	ef 90       	pop	r14
    16cc:	df 90       	pop	r13
    16ce:	cf 90       	pop	r12
    16d0:	08 95       	ret

000016d2 <vTaskDelayUntil>:
    16d2:	cf 92       	push	r12
    16d4:	df 92       	push	r13
    16d6:	ef 92       	push	r14
    16d8:	ff 92       	push	r15
    16da:	0f 93       	push	r16
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	ec 01       	movw	r28, r24
    16e4:	6a 01       	movw	r12, r20
    16e6:	7b 01       	movw	r14, r22
    16e8:	57 de       	rcall	.-850    	; 0x1398 <vTaskSuspendAll>
    16ea:	80 91 d2 19 	lds	r24, 0x19D2
    16ee:	90 91 d3 19 	lds	r25, 0x19D3
    16f2:	a0 91 d4 19 	lds	r26, 0x19D4
    16f6:	b0 91 d5 19 	lds	r27, 0x19D5
    16fa:	08 81       	ld	r16, Y
    16fc:	19 81       	ldd	r17, Y+1	; 0x01
    16fe:	2a 81       	ldd	r18, Y+2	; 0x02
    1700:	3b 81       	ldd	r19, Y+3	; 0x03
    1702:	c0 0e       	add	r12, r16
    1704:	d1 1e       	adc	r13, r17
    1706:	e2 1e       	adc	r14, r18
    1708:	f3 1e       	adc	r15, r19
    170a:	80 17       	cp	r24, r16
    170c:	91 07       	cpc	r25, r17
    170e:	a2 07       	cpc	r26, r18
    1710:	b3 07       	cpc	r27, r19
    1712:	78 f4       	brcc	.+30     	; 0x1732 <vTaskDelayUntil+0x60>
    1714:	c0 16       	cp	r12, r16
    1716:	d1 06       	cpc	r13, r17
    1718:	e2 06       	cpc	r14, r18
    171a:	f3 06       	cpc	r15, r19
    171c:	40 f5       	brcc	.+80     	; 0x176e <vTaskDelayUntil+0x9c>
    171e:	c8 82       	st	Y, r12
    1720:	d9 82       	std	Y+1, r13	; 0x01
    1722:	ea 82       	std	Y+2, r14	; 0x02
    1724:	fb 82       	std	Y+3, r15	; 0x03
    1726:	8c 15       	cp	r24, r12
    1728:	9d 05       	cpc	r25, r13
    172a:	ae 05       	cpc	r26, r14
    172c:	bf 05       	cpc	r27, r15
    172e:	a8 f4       	brcc	.+42     	; 0x175a <vTaskDelayUntil+0x88>
    1730:	0b c0       	rjmp	.+22     	; 0x1748 <vTaskDelayUntil+0x76>
    1732:	c0 16       	cp	r12, r16
    1734:	d1 06       	cpc	r13, r17
    1736:	e2 06       	cpc	r14, r18
    1738:	f3 06       	cpc	r15, r19
    173a:	a0 f0       	brcs	.+40     	; 0x1764 <vTaskDelayUntil+0x92>
    173c:	8c 15       	cp	r24, r12
    173e:	9d 05       	cpc	r25, r13
    1740:	ae 05       	cpc	r26, r14
    1742:	bf 05       	cpc	r27, r15
    1744:	78 f0       	brcs	.+30     	; 0x1764 <vTaskDelayUntil+0x92>
    1746:	13 c0       	rjmp	.+38     	; 0x176e <vTaskDelayUntil+0x9c>
    1748:	80 91 2a 1a 	lds	r24, 0x1A2A
    174c:	90 91 2b 1a 	lds	r25, 0x1A2B
    1750:	02 96       	adiw	r24, 0x02	; 2
    1752:	7a d8       	rcall	.-3852   	; 0x848 <uxListRemove>
    1754:	c7 01       	movw	r24, r14
    1756:	b6 01       	movw	r22, r12
    1758:	93 dc       	rcall	.-1754   	; 0x1080 <prvAddCurrentTaskToDelayedList>
    175a:	3f df       	rcall	.-386    	; 0x15da <xTaskResumeAll>
    175c:	81 11       	cpse	r24, r1
    175e:	0c c0       	rjmp	.+24     	; 0x1778 <vTaskDelayUntil+0xa6>
    1760:	44 d9       	rcall	.-3448   	; 0x9ea <vPortYield>
    1762:	0a c0       	rjmp	.+20     	; 0x1778 <vTaskDelayUntil+0xa6>
    1764:	c8 82       	st	Y, r12
    1766:	d9 82       	std	Y+1, r13	; 0x01
    1768:	ea 82       	std	Y+2, r14	; 0x02
    176a:	fb 82       	std	Y+3, r15	; 0x03
    176c:	ed cf       	rjmp	.-38     	; 0x1748 <vTaskDelayUntil+0x76>
    176e:	c8 82       	st	Y, r12
    1770:	d9 82       	std	Y+1, r13	; 0x01
    1772:	ea 82       	std	Y+2, r14	; 0x02
    1774:	fb 82       	std	Y+3, r15	; 0x03
    1776:	f1 cf       	rjmp	.-30     	; 0x175a <vTaskDelayUntil+0x88>
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	ff 90       	pop	r15
    1782:	ef 90       	pop	r14
    1784:	df 90       	pop	r13
    1786:	cf 90       	pop	r12
    1788:	08 95       	ret

0000178a <vTaskDelay>:
    178a:	cf 92       	push	r12
    178c:	df 92       	push	r13
    178e:	ef 92       	push	r14
    1790:	ff 92       	push	r15
    1792:	6b 01       	movw	r12, r22
    1794:	7c 01       	movw	r14, r24
    1796:	67 2b       	or	r22, r23
    1798:	68 2b       	or	r22, r24
    179a:	69 2b       	or	r22, r25
    179c:	c9 f0       	breq	.+50     	; 0x17d0 <vTaskDelay+0x46>
    179e:	fc dd       	rcall	.-1032   	; 0x1398 <vTaskSuspendAll>
    17a0:	80 91 d2 19 	lds	r24, 0x19D2
    17a4:	90 91 d3 19 	lds	r25, 0x19D3
    17a8:	a0 91 d4 19 	lds	r26, 0x19D4
    17ac:	b0 91 d5 19 	lds	r27, 0x19D5
    17b0:	c8 0e       	add	r12, r24
    17b2:	d9 1e       	adc	r13, r25
    17b4:	ea 1e       	adc	r14, r26
    17b6:	fb 1e       	adc	r15, r27
    17b8:	80 91 2a 1a 	lds	r24, 0x1A2A
    17bc:	90 91 2b 1a 	lds	r25, 0x1A2B
    17c0:	02 96       	adiw	r24, 0x02	; 2
    17c2:	42 d8       	rcall	.-3964   	; 0x848 <uxListRemove>
    17c4:	c7 01       	movw	r24, r14
    17c6:	b6 01       	movw	r22, r12
    17c8:	5b dc       	rcall	.-1866   	; 0x1080 <prvAddCurrentTaskToDelayedList>
    17ca:	07 df       	rcall	.-498    	; 0x15da <xTaskResumeAll>
    17cc:	81 11       	cpse	r24, r1
    17ce:	01 c0       	rjmp	.+2      	; 0x17d2 <vTaskDelay+0x48>
    17d0:	0c d9       	rcall	.-3560   	; 0x9ea <vPortYield>
    17d2:	ff 90       	pop	r15
    17d4:	ef 90       	pop	r14
    17d6:	df 90       	pop	r13
    17d8:	cf 90       	pop	r12
    17da:	08 95       	ret

000017dc <vTaskSwitchContext>:
    17dc:	80 91 cb 19 	lds	r24, 0x19CB
    17e0:	88 23       	and	r24, r24
    17e2:	21 f0       	breq	.+8      	; 0x17ec <vTaskSwitchContext+0x10>
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	80 93 ce 19 	sts	0x19CE, r24
    17ea:	08 95       	ret
    17ec:	10 92 ce 19 	sts	0x19CE, r1
    17f0:	e0 91 d1 19 	lds	r30, 0x19D1
    17f4:	4b e0       	ldi	r20, 0x0B	; 11
    17f6:	e4 9f       	mul	r30, r20
    17f8:	f0 01       	movw	r30, r0
    17fa:	11 24       	eor	r1, r1
    17fc:	e2 50       	subi	r30, 0x02	; 2
    17fe:	f6 4e       	sbci	r31, 0xE6	; 230
    1800:	80 81       	ld	r24, Z
    1802:	81 11       	cpse	r24, r1
    1804:	10 c0       	rjmp	.+32     	; 0x1826 <vTaskSwitchContext+0x4a>
    1806:	9b e0       	ldi	r25, 0x0B	; 11
    1808:	80 91 d1 19 	lds	r24, 0x19D1
    180c:	81 50       	subi	r24, 0x01	; 1
    180e:	80 93 d1 19 	sts	0x19D1, r24
    1812:	e0 91 d1 19 	lds	r30, 0x19D1
    1816:	9e 9f       	mul	r25, r30
    1818:	f0 01       	movw	r30, r0
    181a:	11 24       	eor	r1, r1
    181c:	e2 50       	subi	r30, 0x02	; 2
    181e:	f6 4e       	sbci	r31, 0xE6	; 230
    1820:	80 81       	ld	r24, Z
    1822:	88 23       	and	r24, r24
    1824:	89 f3       	breq	.-30     	; 0x1808 <vTaskSwitchContext+0x2c>
    1826:	80 91 d1 19 	lds	r24, 0x19D1
    182a:	28 2f       	mov	r18, r24
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	4b e0       	ldi	r20, 0x0B	; 11
    1830:	84 9f       	mul	r24, r20
    1832:	c0 01       	movw	r24, r0
    1834:	11 24       	eor	r1, r1
    1836:	dc 01       	movw	r26, r24
    1838:	a2 50       	subi	r26, 0x02	; 2
    183a:	b6 4e       	sbci	r27, 0xE6	; 230
    183c:	11 96       	adiw	r26, 0x01	; 1
    183e:	ed 91       	ld	r30, X+
    1840:	fc 91       	ld	r31, X
    1842:	12 97       	sbiw	r26, 0x02	; 2
    1844:	04 80       	ldd	r0, Z+4	; 0x04
    1846:	f5 81       	ldd	r31, Z+5	; 0x05
    1848:	e0 2d       	mov	r30, r0
    184a:	12 96       	adiw	r26, 0x02	; 2
    184c:	fc 93       	st	X, r31
    184e:	ee 93       	st	-X, r30
    1850:	11 97       	sbiw	r26, 0x01	; 1
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	95 4e       	sbci	r25, 0xE5	; 229
    1856:	e8 17       	cp	r30, r24
    1858:	f9 07       	cpc	r31, r25
    185a:	61 f4       	brne	.+24     	; 0x1874 <vTaskSwitchContext+0x98>
    185c:	84 81       	ldd	r24, Z+4	; 0x04
    185e:	95 81       	ldd	r25, Z+5	; 0x05
    1860:	4b e0       	ldi	r20, 0x0B	; 11
    1862:	42 9f       	mul	r20, r18
    1864:	f0 01       	movw	r30, r0
    1866:	43 9f       	mul	r20, r19
    1868:	f0 0d       	add	r31, r0
    186a:	11 24       	eor	r1, r1
    186c:	e2 50       	subi	r30, 0x02	; 2
    186e:	f6 4e       	sbci	r31, 0xE6	; 230
    1870:	92 83       	std	Z+2, r25	; 0x02
    1872:	81 83       	std	Z+1, r24	; 0x01
    1874:	8b e0       	ldi	r24, 0x0B	; 11
    1876:	82 9f       	mul	r24, r18
    1878:	f0 01       	movw	r30, r0
    187a:	83 9f       	mul	r24, r19
    187c:	f0 0d       	add	r31, r0
    187e:	11 24       	eor	r1, r1
    1880:	e2 50       	subi	r30, 0x02	; 2
    1882:	f6 4e       	sbci	r31, 0xE6	; 230
    1884:	01 80       	ldd	r0, Z+1	; 0x01
    1886:	f2 81       	ldd	r31, Z+2	; 0x02
    1888:	e0 2d       	mov	r30, r0
    188a:	80 85       	ldd	r24, Z+8	; 0x08
    188c:	91 85       	ldd	r25, Z+9	; 0x09
    188e:	90 93 2b 1a 	sts	0x1A2B, r25
    1892:	80 93 2a 1a 	sts	0x1A2A, r24
    1896:	08 95       	ret

00001898 <vTaskPlaceOnEventList>:
    1898:	cf 92       	push	r12
    189a:	df 92       	push	r13
    189c:	ef 92       	push	r14
    189e:	ff 92       	push	r15
    18a0:	6a 01       	movw	r12, r20
    18a2:	7b 01       	movw	r14, r22
    18a4:	20 91 2a 1a 	lds	r18, 0x1A2A
    18a8:	30 91 2b 1a 	lds	r19, 0x1A2B
    18ac:	b9 01       	movw	r22, r18
    18ae:	62 5f       	subi	r22, 0xF2	; 242
    18b0:	7f 4f       	sbci	r23, 0xFF	; 255
    18b2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <vListInsert>
    18b6:	80 91 2a 1a 	lds	r24, 0x1A2A
    18ba:	90 91 2b 1a 	lds	r25, 0x1A2B
    18be:	02 96       	adiw	r24, 0x02	; 2
    18c0:	0e 94 24 04 	call	0x848	; 0x848 <uxListRemove>
    18c4:	80 91 d2 19 	lds	r24, 0x19D2
    18c8:	90 91 d3 19 	lds	r25, 0x19D3
    18cc:	a0 91 d4 19 	lds	r26, 0x19D4
    18d0:	b0 91 d5 19 	lds	r27, 0x19D5
    18d4:	bc 01       	movw	r22, r24
    18d6:	cd 01       	movw	r24, r26
    18d8:	6c 0d       	add	r22, r12
    18da:	7d 1d       	adc	r23, r13
    18dc:	8e 1d       	adc	r24, r14
    18de:	9f 1d       	adc	r25, r15
    18e0:	cf db       	rcall	.-2146   	; 0x1080 <prvAddCurrentTaskToDelayedList>
    18e2:	ff 90       	pop	r15
    18e4:	ef 90       	pop	r14
    18e6:	df 90       	pop	r13
    18e8:	cf 90       	pop	r12
    18ea:	08 95       	ret

000018ec <xTaskRemoveFromEventList>:
    18ec:	0f 93       	push	r16
    18ee:	1f 93       	push	r17
    18f0:	cf 93       	push	r28
    18f2:	df 93       	push	r29
    18f4:	dc 01       	movw	r26, r24
    18f6:	17 96       	adiw	r26, 0x07	; 7
    18f8:	ed 91       	ld	r30, X+
    18fa:	fc 91       	ld	r31, X
    18fc:	18 97       	sbiw	r26, 0x08	; 8
    18fe:	c0 85       	ldd	r28, Z+8	; 0x08
    1900:	d1 85       	ldd	r29, Z+9	; 0x09
    1902:	8e 01       	movw	r16, r28
    1904:	02 5f       	subi	r16, 0xF2	; 242
    1906:	1f 4f       	sbci	r17, 0xFF	; 255
    1908:	c8 01       	movw	r24, r16
    190a:	0e 94 24 04 	call	0x848	; 0x848 <uxListRemove>
    190e:	80 91 cb 19 	lds	r24, 0x19CB
    1912:	81 11       	cpse	r24, r1
    1914:	16 c0       	rjmp	.+44     	; 0x1942 <xTaskRemoveFromEventList+0x56>
    1916:	0c 50       	subi	r16, 0x0C	; 12
    1918:	11 09       	sbc	r17, r1
    191a:	c8 01       	movw	r24, r16
    191c:	0e 94 24 04 	call	0x848	; 0x848 <uxListRemove>
    1920:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1922:	80 91 d1 19 	lds	r24, 0x19D1
    1926:	89 17       	cp	r24, r25
    1928:	10 f4       	brcc	.+4      	; 0x192e <xTaskRemoveFromEventList+0x42>
    192a:	90 93 d1 19 	sts	0x19D1, r25
    192e:	bb e0       	ldi	r27, 0x0B	; 11
    1930:	9b 9f       	mul	r25, r27
    1932:	c0 01       	movw	r24, r0
    1934:	11 24       	eor	r1, r1
    1936:	b8 01       	movw	r22, r16
    1938:	82 50       	subi	r24, 0x02	; 2
    193a:	96 4e       	sbci	r25, 0xE6	; 230
    193c:	0e 94 c6 03 	call	0x78c	; 0x78c <vListInsertEnd>
    1940:	05 c0       	rjmp	.+10     	; 0x194c <xTaskRemoveFromEventList+0x60>
    1942:	b8 01       	movw	r22, r16
    1944:	89 ed       	ldi	r24, 0xD9	; 217
    1946:	99 e1       	ldi	r25, 0x19	; 25
    1948:	0e 94 c6 03 	call	0x78c	; 0x78c <vListInsertEnd>
    194c:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1950:	f0 91 2b 1a 	lds	r31, 0x1A2B
    1954:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1956:	82 8d       	ldd	r24, Z+26	; 0x1a
    1958:	89 17       	cp	r24, r25
    195a:	20 f4       	brcc	.+8      	; 0x1964 <xTaskRemoveFromEventList+0x78>
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	80 93 ce 19 	sts	0x19CE, r24
    1962:	01 c0       	rjmp	.+2      	; 0x1966 <xTaskRemoveFromEventList+0x7a>
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	df 91       	pop	r29
    1968:	cf 91       	pop	r28
    196a:	1f 91       	pop	r17
    196c:	0f 91       	pop	r16
    196e:	08 95       	ret

00001970 <vTaskSetTimeOutState>:
    1970:	20 91 cd 19 	lds	r18, 0x19CD
    1974:	fc 01       	movw	r30, r24
    1976:	20 83       	st	Z, r18
    1978:	40 91 d2 19 	lds	r20, 0x19D2
    197c:	50 91 d3 19 	lds	r21, 0x19D3
    1980:	60 91 d4 19 	lds	r22, 0x19D4
    1984:	70 91 d5 19 	lds	r23, 0x19D5
    1988:	41 83       	std	Z+1, r20	; 0x01
    198a:	52 83       	std	Z+2, r21	; 0x02
    198c:	63 83       	std	Z+3, r22	; 0x03
    198e:	74 83       	std	Z+4, r23	; 0x04
    1990:	08 95       	ret

00001992 <xTaskCheckForTimeOut>:
    1992:	8f 92       	push	r8
    1994:	9f 92       	push	r9
    1996:	af 92       	push	r10
    1998:	bf 92       	push	r11
    199a:	cf 92       	push	r12
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	fc 01       	movw	r30, r24
    19a8:	db 01       	movw	r26, r22
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	0f 92       	push	r0
    19b0:	40 91 d2 19 	lds	r20, 0x19D2
    19b4:	50 91 d3 19 	lds	r21, 0x19D3
    19b8:	60 91 d4 19 	lds	r22, 0x19D4
    19bc:	70 91 d5 19 	lds	r23, 0x19D5
    19c0:	80 91 cd 19 	lds	r24, 0x19CD
    19c4:	90 81       	ld	r25, Z
    19c6:	98 17       	cp	r25, r24
    19c8:	49 f0       	breq	.+18     	; 0x19dc <xTaskCheckForTimeOut+0x4a>
    19ca:	01 81       	ldd	r16, Z+1	; 0x01
    19cc:	12 81       	ldd	r17, Z+2	; 0x02
    19ce:	23 81       	ldd	r18, Z+3	; 0x03
    19d0:	34 81       	ldd	r19, Z+4	; 0x04
    19d2:	40 17       	cp	r20, r16
    19d4:	51 07       	cpc	r21, r17
    19d6:	62 07       	cpc	r22, r18
    19d8:	73 07       	cpc	r23, r19
    19da:	28 f5       	brcc	.+74     	; 0x1a26 <xTaskCheckForTimeOut+0x94>
    19dc:	c1 80       	ldd	r12, Z+1	; 0x01
    19de:	d2 80       	ldd	r13, Z+2	; 0x02
    19e0:	e3 80       	ldd	r14, Z+3	; 0x03
    19e2:	f4 80       	ldd	r15, Z+4	; 0x04
    19e4:	0d 91       	ld	r16, X+
    19e6:	1d 91       	ld	r17, X+
    19e8:	2d 91       	ld	r18, X+
    19ea:	3c 91       	ld	r19, X
    19ec:	13 97       	sbiw	r26, 0x03	; 3
    19ee:	4a 01       	movw	r8, r20
    19f0:	5b 01       	movw	r10, r22
    19f2:	8c 18       	sub	r8, r12
    19f4:	9d 08       	sbc	r9, r13
    19f6:	ae 08       	sbc	r10, r14
    19f8:	bf 08       	sbc	r11, r15
    19fa:	80 16       	cp	r8, r16
    19fc:	91 06       	cpc	r9, r17
    19fe:	a2 06       	cpc	r10, r18
    1a00:	b3 06       	cpc	r11, r19
    1a02:	98 f4       	brcc	.+38     	; 0x1a2a <xTaskCheckForTimeOut+0x98>
    1a04:	cf 01       	movw	r24, r30
    1a06:	c4 1a       	sub	r12, r20
    1a08:	d5 0a       	sbc	r13, r21
    1a0a:	e6 0a       	sbc	r14, r22
    1a0c:	f7 0a       	sbc	r15, r23
    1a0e:	0c 0d       	add	r16, r12
    1a10:	1d 1d       	adc	r17, r13
    1a12:	2e 1d       	adc	r18, r14
    1a14:	3f 1d       	adc	r19, r15
    1a16:	0d 93       	st	X+, r16
    1a18:	1d 93       	st	X+, r17
    1a1a:	2d 93       	st	X+, r18
    1a1c:	3c 93       	st	X, r19
    1a1e:	13 97       	sbiw	r26, 0x03	; 3
    1a20:	a7 df       	rcall	.-178    	; 0x1970 <vTaskSetTimeOutState>
    1a22:	80 e0       	ldi	r24, 0x00	; 0
    1a24:	03 c0       	rjmp	.+6      	; 0x1a2c <xTaskCheckForTimeOut+0x9a>
    1a26:	81 e0       	ldi	r24, 0x01	; 1
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <xTaskCheckForTimeOut+0x9a>
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	0f 90       	pop	r0
    1a2e:	0f be       	out	0x3f, r0	; 63
    1a30:	1f 91       	pop	r17
    1a32:	0f 91       	pop	r16
    1a34:	ff 90       	pop	r15
    1a36:	ef 90       	pop	r14
    1a38:	df 90       	pop	r13
    1a3a:	cf 90       	pop	r12
    1a3c:	bf 90       	pop	r11
    1a3e:	af 90       	pop	r10
    1a40:	9f 90       	pop	r9
    1a42:	8f 90       	pop	r8
    1a44:	08 95       	ret

00001a46 <vTaskMissedYield>:
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	80 93 ce 19 	sts	0x19CE, r24
    1a4c:	08 95       	ret

00001a4e <uxTaskGetStackHighWaterMark>:
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	21 f4       	brne	.+8      	; 0x1a5a <uxTaskGetStackHighWaterMark+0xc>
    1a52:	80 91 2a 1a 	lds	r24, 0x1A2A
    1a56:	90 91 2b 1a 	lds	r25, 0x1A2B
    1a5a:	dc 01       	movw	r26, r24
    1a5c:	5b 96       	adiw	r26, 0x1b	; 27
    1a5e:	ed 91       	ld	r30, X+
    1a60:	fc 91       	ld	r31, X
    1a62:	5c 97       	sbiw	r26, 0x1c	; 28
    1a64:	80 81       	ld	r24, Z
    1a66:	85 3a       	cpi	r24, 0xA5	; 165
    1a68:	59 f4       	brne	.+22     	; 0x1a80 <uxTaskGetStackHighWaterMark+0x32>
    1a6a:	31 96       	adiw	r30, 0x01	; 1
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	dc 01       	movw	r26, r24
    1a72:	01 96       	adiw	r24, 0x01	; 1
    1a74:	a1 1d       	adc	r26, r1
    1a76:	b1 1d       	adc	r27, r1
    1a78:	21 91       	ld	r18, Z+
    1a7a:	25 3a       	cpi	r18, 0xA5	; 165
    1a7c:	d1 f3       	breq	.-12     	; 0x1a72 <uxTaskGetStackHighWaterMark+0x24>
    1a7e:	08 95       	ret
    1a80:	80 e0       	ldi	r24, 0x00	; 0
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	dc 01       	movw	r26, r24
    1a86:	08 95       	ret

00001a88 <vTaskPriorityInherit>:
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	cf 93       	push	r28
    1a8e:	df 93       	push	r29
    1a90:	fc 01       	movw	r30, r24
    1a92:	89 2b       	or	r24, r25
    1a94:	09 f4       	brne	.+2      	; 0x1a98 <vTaskPriorityInherit+0x10>
    1a96:	51 c0       	rjmp	.+162    	; 0x1b3a <vTaskPriorityInherit+0xb2>
    1a98:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a9a:	a0 91 2a 1a 	lds	r26, 0x1A2A
    1a9e:	b0 91 2b 1a 	lds	r27, 0x1A2B
    1aa2:	5a 96       	adiw	r26, 0x1a	; 26
    1aa4:	9c 91       	ld	r25, X
    1aa6:	89 17       	cp	r24, r25
    1aa8:	08 f0       	brcs	.+2      	; 0x1aac <vTaskPriorityInherit+0x24>
    1aaa:	47 c0       	rjmp	.+142    	; 0x1b3a <vTaskPriorityInherit+0xb2>
    1aac:	46 85       	ldd	r20, Z+14	; 0x0e
    1aae:	57 85       	ldd	r21, Z+15	; 0x0f
    1ab0:	60 89       	ldd	r22, Z+16	; 0x10
    1ab2:	71 89       	ldd	r23, Z+17	; 0x11
    1ab4:	77 23       	and	r23, r23
    1ab6:	94 f0       	brlt	.+36     	; 0x1adc <vTaskPriorityInherit+0x54>
    1ab8:	a0 91 2a 1a 	lds	r26, 0x1A2A
    1abc:	b0 91 2b 1a 	lds	r27, 0x1A2B
    1ac0:	5a 96       	adiw	r26, 0x1a	; 26
    1ac2:	9c 91       	ld	r25, X
    1ac4:	44 e0       	ldi	r20, 0x04	; 4
    1ac6:	50 e0       	ldi	r21, 0x00	; 0
    1ac8:	60 e0       	ldi	r22, 0x00	; 0
    1aca:	70 e0       	ldi	r23, 0x00	; 0
    1acc:	49 1b       	sub	r20, r25
    1ace:	51 09       	sbc	r21, r1
    1ad0:	61 09       	sbc	r22, r1
    1ad2:	71 09       	sbc	r23, r1
    1ad4:	46 87       	std	Z+14, r20	; 0x0e
    1ad6:	57 87       	std	Z+15, r21	; 0x0f
    1ad8:	60 8b       	std	Z+16, r22	; 0x10
    1ada:	71 8b       	std	Z+17, r23	; 0x11
    1adc:	2b e0       	ldi	r18, 0x0B	; 11
    1ade:	82 9f       	mul	r24, r18
    1ae0:	c0 01       	movw	r24, r0
    1ae2:	11 24       	eor	r1, r1
    1ae4:	82 50       	subi	r24, 0x02	; 2
    1ae6:	96 4e       	sbci	r25, 0xE6	; 230
    1ae8:	24 85       	ldd	r18, Z+12	; 0x0c
    1aea:	35 85       	ldd	r19, Z+13	; 0x0d
    1aec:	28 17       	cp	r18, r24
    1aee:	39 07       	cpc	r19, r25
    1af0:	e9 f4       	brne	.+58     	; 0x1b2c <vTaskPriorityInherit+0xa4>
    1af2:	8f 01       	movw	r16, r30
    1af4:	ef 01       	movw	r28, r30
    1af6:	22 96       	adiw	r28, 0x02	; 2
    1af8:	ce 01       	movw	r24, r28
    1afa:	0e 94 24 04 	call	0x848	; 0x848 <uxListRemove>
    1afe:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1b02:	f0 91 2b 1a 	lds	r31, 0x1A2B
    1b06:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b08:	f8 01       	movw	r30, r16
    1b0a:	92 8f       	std	Z+26, r25	; 0x1a
    1b0c:	80 91 d1 19 	lds	r24, 0x19D1
    1b10:	89 17       	cp	r24, r25
    1b12:	10 f4       	brcc	.+4      	; 0x1b18 <vTaskPriorityInherit+0x90>
    1b14:	90 93 d1 19 	sts	0x19D1, r25
    1b18:	fb e0       	ldi	r31, 0x0B	; 11
    1b1a:	9f 9f       	mul	r25, r31
    1b1c:	c0 01       	movw	r24, r0
    1b1e:	11 24       	eor	r1, r1
    1b20:	be 01       	movw	r22, r28
    1b22:	82 50       	subi	r24, 0x02	; 2
    1b24:	96 4e       	sbci	r25, 0xE6	; 230
    1b26:	0e 94 c6 03 	call	0x78c	; 0x78c <vListInsertEnd>
    1b2a:	07 c0       	rjmp	.+14     	; 0x1b3a <vTaskPriorityInherit+0xb2>
    1b2c:	a0 91 2a 1a 	lds	r26, 0x1A2A
    1b30:	b0 91 2b 1a 	lds	r27, 0x1A2B
    1b34:	5a 96       	adiw	r26, 0x1a	; 26
    1b36:	8c 91       	ld	r24, X
    1b38:	82 8f       	std	Z+26, r24	; 0x1a
    1b3a:	df 91       	pop	r29
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	08 95       	ret

00001b44 <xTaskPriorityDisinherit>:
    1b44:	0f 93       	push	r16
    1b46:	1f 93       	push	r17
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	89 2b       	or	r24, r25
    1b50:	79 f1       	breq	.+94     	; 0x1bb0 <xTaskPriorityDisinherit+0x6c>
    1b52:	80 a5       	ldd	r24, Z+40	; 0x28
    1b54:	81 50       	subi	r24, 0x01	; 1
    1b56:	80 a7       	std	Z+40, r24	; 0x28
    1b58:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b5a:	97 a1       	ldd	r25, Z+39	; 0x27
    1b5c:	29 17       	cp	r18, r25
    1b5e:	51 f1       	breq	.+84     	; 0x1bb4 <xTaskPriorityDisinherit+0x70>
    1b60:	81 11       	cpse	r24, r1
    1b62:	2a c0       	rjmp	.+84     	; 0x1bb8 <xTaskPriorityDisinherit+0x74>
    1b64:	ef 01       	movw	r28, r30
    1b66:	8f 01       	movw	r16, r30
    1b68:	0e 5f       	subi	r16, 0xFE	; 254
    1b6a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b6c:	c8 01       	movw	r24, r16
    1b6e:	0e 94 24 04 	call	0x848	; 0x848 <uxListRemove>
    1b72:	9f a1       	ldd	r25, Y+39	; 0x27
    1b74:	9a 8f       	std	Y+26, r25	; 0x1a
    1b76:	44 e0       	ldi	r20, 0x04	; 4
    1b78:	50 e0       	ldi	r21, 0x00	; 0
    1b7a:	60 e0       	ldi	r22, 0x00	; 0
    1b7c:	70 e0       	ldi	r23, 0x00	; 0
    1b7e:	49 1b       	sub	r20, r25
    1b80:	51 09       	sbc	r21, r1
    1b82:	61 09       	sbc	r22, r1
    1b84:	71 09       	sbc	r23, r1
    1b86:	4e 87       	std	Y+14, r20	; 0x0e
    1b88:	5f 87       	std	Y+15, r21	; 0x0f
    1b8a:	68 8b       	std	Y+16, r22	; 0x10
    1b8c:	79 8b       	std	Y+17, r23	; 0x11
    1b8e:	80 91 d1 19 	lds	r24, 0x19D1
    1b92:	89 17       	cp	r24, r25
    1b94:	10 f4       	brcc	.+4      	; 0x1b9a <xTaskPriorityDisinherit+0x56>
    1b96:	90 93 d1 19 	sts	0x19D1, r25
    1b9a:	2b e0       	ldi	r18, 0x0B	; 11
    1b9c:	92 9f       	mul	r25, r18
    1b9e:	c0 01       	movw	r24, r0
    1ba0:	11 24       	eor	r1, r1
    1ba2:	b8 01       	movw	r22, r16
    1ba4:	82 50       	subi	r24, 0x02	; 2
    1ba6:	96 4e       	sbci	r25, 0xE6	; 230
    1ba8:	0e 94 c6 03 	call	0x78c	; 0x78c <vListInsertEnd>
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	05 c0       	rjmp	.+10     	; 0x1bba <xTaskPriorityDisinherit+0x76>
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	03 c0       	rjmp	.+6      	; 0x1bba <xTaskPriorityDisinherit+0x76>
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
    1bb6:	01 c0       	rjmp	.+2      	; 0x1bba <xTaskPriorityDisinherit+0x76>
    1bb8:	80 e0       	ldi	r24, 0x00	; 0
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	1f 91       	pop	r17
    1bc0:	0f 91       	pop	r16
    1bc2:	08 95       	ret

00001bc4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1bc4:	80 91 2a 1a 	lds	r24, 0x1A2A
    1bc8:	90 91 2b 1a 	lds	r25, 0x1A2B
    1bcc:	89 2b       	or	r24, r25
    1bce:	39 f0       	breq	.+14     	; 0x1bde <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1bd0:	e0 91 2a 1a 	lds	r30, 0x1A2A
    1bd4:	f0 91 2b 1a 	lds	r31, 0x1A2B
    1bd8:	80 a5       	ldd	r24, Z+40	; 0x28
    1bda:	8f 5f       	subi	r24, 0xFF	; 255
    1bdc:	80 a7       	std	Z+40, r24	; 0x28
		}

		return pxCurrentTCB;
    1bde:	80 91 2a 1a 	lds	r24, 0x1A2A
    1be2:	90 91 2b 1a 	lds	r25, 0x1A2B
	}
    1be6:	08 95       	ret

00001be8 <_ZN9BaseShareC1EPKc>:
 *           base class object which can't do anything!) but instead by the 
 *           constructors of descendent classes. 
 *  @param   p_name The name for the shared data item, in a character string
 */

BaseShare::BaseShare (const char* p_name = NULL)
    1be8:	ef 92       	push	r14
    1bea:	ff 92       	push	r15
    1bec:	0f 93       	push	r16
    1bee:	1f 93       	push	r17
    1bf0:	cf 93       	push	r28
    1bf2:	df 93       	push	r29
    1bf4:	8c 01       	movw	r16, r24
    1bf6:	7b 01       	movw	r14, r22
    1bf8:	81 e1       	ldi	r24, 0x11	; 17
    1bfa:	92 e0       	ldi	r25, 0x02	; 2
    1bfc:	f8 01       	movw	r30, r16
    1bfe:	91 83       	std	Z+1, r25	; 0x01
    1c00:	80 83       	st	Z, r24
{
	// Allocate some memory and then save the share's name; trim it to 12 characters
	if (p_name != NULL)
    1c02:	61 15       	cp	r22, r1
    1c04:	71 05       	cpc	r23, r1
    1c06:	a9 f0       	breq	.+42     	; 0x1c32 <_ZN9BaseShareC1EPKc+0x4a>
	{
		uint8_t namelength = strlen (p_name);
    1c08:	fb 01       	movw	r30, r22
    1c0a:	01 90       	ld	r0, Z+
    1c0c:	00 20       	and	r0, r0
    1c0e:	e9 f7       	brne	.-6      	; 0x1c0a <_ZN9BaseShareC1EPKc+0x22>
    1c10:	31 97       	sbiw	r30, 0x01	; 1
		namelength = (namelength <= 12) ? namelength : 12;
    1c12:	e6 1b       	sub	r30, r22
    1c14:	ed 30       	cpi	r30, 0x0D	; 13
    1c16:	08 f0       	brcs	.+2      	; 0x1c1a <_ZN9BaseShareC1EPKc+0x32>
    1c18:	ec e0       	ldi	r30, 0x0C	; 12
		name = new char[namelength + 1];
    1c1a:	ce 2f       	mov	r28, r30
    1c1c:	d0 e0       	ldi	r29, 0x00	; 0
    1c1e:	ce 01       	movw	r24, r28
    1c20:	01 96       	adiw	r24, 0x01	; 1
    1c22:	81 d4       	rcall	.+2306   	; 0x2526 <_Znaj>
    1c24:	f8 01       	movw	r30, r16
    1c26:	95 83       	std	Z+5, r25	; 0x05
    1c28:	84 83       	std	Z+4, r24	; 0x04
		strncpy (name, p_name, namelength);
    1c2a:	ae 01       	movw	r20, r28
    1c2c:	b7 01       	movw	r22, r14
    1c2e:	0e 94 0d 1a 	call	0x341a	; 0x341a <strncpy>
	}

	// Install this share in the linked list of shares
	p_next = p_newest;
    1c32:	80 91 2c 1a 	lds	r24, 0x1A2C
    1c36:	90 91 2d 1a 	lds	r25, 0x1A2D
    1c3a:	f8 01       	movw	r30, r16
    1c3c:	97 83       	std	Z+7, r25	; 0x07
    1c3e:	86 83       	std	Z+6, r24	; 0x06
	p_newest = this;
    1c40:	10 93 2d 1a 	sts	0x1A2D, r17
    1c44:	00 93 2c 1a 	sts	0x1A2C, r16
}
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	1f 91       	pop	r17
    1c4e:	0f 91       	pop	r16
    1c50:	ff 90       	pop	r15
    1c52:	ef 90       	pop	r14
    1c54:	08 95       	ret

00001c56 <_Z16print_all_sharesP8emstream>:
 *           status of other shares in reverse order of creation. 
 *  @param   p_ser_dev A pointer to the serial device on which shares are printed
 */

void print_all_shares (emstream* p_ser_dev)
{
    1c56:	0f 93       	push	r16
    1c58:	1f 93       	push	r17
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	ec 01       	movw	r28, r24
	if (BaseShare::p_newest != NULL)
    1c60:	80 91 2c 1a 	lds	r24, 0x1A2C
    1c64:	90 91 2d 1a 	lds	r25, 0x1A2D
    1c68:	89 2b       	or	r24, r25
    1c6a:	09 f1       	breq	.+66     	; 0x1cae <_Z16print_all_sharesP8emstream+0x58>
	{
		*p_ser_dev << PMS ("Share/Queue     Type    Free/Total") << endl;
    1c6c:	6b e0       	ldi	r22, 0x0B	; 11
    1c6e:	ce 01       	movw	r24, r28
    1c70:	33 d5       	rcall	.+2662   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1c72:	8c 01       	movw	r16, r24
    1c74:	64 e5       	ldi	r22, 0x54	; 84
    1c76:	71 e0       	ldi	r23, 0x01	; 1
    1c78:	f8 d4       	rcall	.+2544   	; 0x266a <_ZN8emstream4putsEPKc>
    1c7a:	66 e0       	ldi	r22, 0x06	; 6
    1c7c:	c8 01       	movw	r24, r16
    1c7e:	2c d5       	rcall	.+2648   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
		*p_ser_dev << PMS ("----            ----    ----------") << endl;
    1c80:	6b e0       	ldi	r22, 0x0B	; 11
    1c82:	ce 01       	movw	r24, r28
    1c84:	29 d5       	rcall	.+2642   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1c86:	8c 01       	movw	r16, r24
    1c88:	61 e3       	ldi	r22, 0x31	; 49
    1c8a:	71 e0       	ldi	r23, 0x01	; 1
    1c8c:	ee d4       	rcall	.+2524   	; 0x266a <_ZN8emstream4putsEPKc>
    1c8e:	66 e0       	ldi	r22, 0x06	; 6
    1c90:	c8 01       	movw	r24, r16
    1c92:	22 d5       	rcall	.+2628   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

		BaseShare::p_newest->print_in_list (p_ser_dev);
    1c94:	80 91 2c 1a 	lds	r24, 0x1A2C
    1c98:	90 91 2d 1a 	lds	r25, 0x1A2D
    1c9c:	dc 01       	movw	r26, r24
    1c9e:	ed 91       	ld	r30, X+
    1ca0:	fc 91       	ld	r31, X
    1ca2:	01 90       	ld	r0, Z+
    1ca4:	f0 81       	ld	r31, Z
    1ca6:	e0 2d       	mov	r30, r0
    1ca8:	be 01       	movw	r22, r28
    1caa:	09 95       	icall
    1cac:	0a c0       	rjmp	.+20     	; 0x1cc2 <_Z16print_all_sharesP8emstream+0x6c>
	}
	else
	{
		*p_ser_dev << PMS ("No shared data items to print") << endl;
    1cae:	6b e0       	ldi	r22, 0x0B	; 11
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	12 d5       	rcall	.+2596   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1cb4:	ec 01       	movw	r28, r24
    1cb6:	63 e1       	ldi	r22, 0x13	; 19
    1cb8:	71 e0       	ldi	r23, 0x01	; 1
    1cba:	d7 d4       	rcall	.+2478   	; 0x266a <_ZN8emstream4putsEPKc>
    1cbc:	66 e0       	ldi	r22, 0x06	; 6
    1cbe:	ce 01       	movw	r24, r28
    1cc0:	0b d5       	rcall	.+2582   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	}
}
    1cc2:	df 91       	pop	r29
    1cc4:	cf 91       	pop	r28
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	08 95       	ret

00001ccc <_ZN8TaskBaseC1EPKchjP8emstream>:
 *                        (default: @c configMINIMAL_STACK_SIZE)
 *  @param   p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which 
 *                     can be used by this task to communicate (default: NULL)
 */

TaskBase::TaskBase (const char* a_name, unsigned portBASE_TYPE a_priority, 
    1ccc:	4f 92       	push	r4
    1cce:	5f 92       	push	r5
    1cd0:	6f 92       	push	r6
    1cd2:	7f 92       	push	r7
    1cd4:	8f 92       	push	r8
    1cd6:	9f 92       	push	r9
    1cd8:	af 92       	push	r10
    1cda:	bf 92       	push	r11
    1cdc:	cf 92       	push	r12
    1cde:	df 92       	push	r13
    1ce0:	ef 92       	push	r14
    1ce2:	ff 92       	push	r15
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
    1cec:	ec 01       	movw	r28, r24
    1cee:	3b 01       	movw	r6, r22
    1cf0:	29 01       	movw	r4, r18
    1cf2:	48 01       	movw	r8, r16
					size_t a_stack_size, emstream* p_ser_dev)
    1cf4:	fc 01       	movw	r30, r24
    1cf6:	87 e1       	ldi	r24, 0x17	; 23
    1cf8:	92 e0       	ldi	r25, 0x02	; 2
    1cfa:	81 93       	st	Z+, r24
    1cfc:	91 93       	st	Z+, r25
{
	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    1cfe:	a1 2c       	mov	r10, r1
    1d00:	b1 2c       	mov	r11, r1
    1d02:	c1 2c       	mov	r12, r1
    1d04:	d1 2c       	mov	r13, r1
    1d06:	7f 01       	movw	r14, r30
    1d08:	04 2f       	mov	r16, r20
    1d0a:	9e 01       	movw	r18, r28
    1d0c:	a2 01       	movw	r20, r4
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	9f e0       	ldi	r25, 0x0F	; 15
    1d12:	02 da       	rcall	.-3068   	; 0x1118 <xTaskGenericCreate>
		 a_priority,                                // Priority for the new task
		 &handle                                    // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    1d14:	9f 82       	std	Y+7, r9	; 0x07
    1d16:	8e 82       	std	Y+6, r8	; 0x06
	total_stack = a_stack_size;
    1d18:	59 86       	std	Y+9, r5	; 0x09
    1d1a:	48 86       	std	Y+8, r4	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    1d1c:	20 91 2e 1a 	lds	r18, 0x1A2E
    1d20:	30 91 2f 1a 	lds	r19, 0x1A2F
    1d24:	3d 83       	std	Y+5, r19	; 0x05
    1d26:	2c 83       	std	Y+4, r18	; 0x04
	last_created_task_pointer = this;
    1d28:	d0 93 2f 1a 	sts	0x1A2F, r29
    1d2c:	c0 93 2e 1a 	sts	0x1A2E, r28

	// Initialize the finite state machine and its transition logger
	state = 0;
    1d30:	1c 86       	std	Y+12, r1	; 0x0c
	previous_state = 0;
    1d32:	1d 86       	std	Y+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    1d34:	40 90 3e 1a 	lds	r4, 0x1A3E
    1d38:	50 90 3f 1a 	lds	r5, 0x1A3F
    1d3c:	9f ef       	ldi	r25, 0xFF	; 255
    1d3e:	49 1a       	sub	r4, r25
    1d40:	59 0a       	sbc	r5, r25
    1d42:	50 92 3f 1a 	sts	0x1A3F, r5
    1d46:	40 92 3e 1a 	sts	0x1A3E, r4
    1d4a:	5b 86       	std	Y+11, r5	; 0x0b
    1d4c:	4a 86       	std	Y+10, r4	; 0x0a

	// Initialize the run counter
	runs = 0;
    1d4e:	1e 86       	std	Y+14, r1	; 0x0e
    1d50:	1f 86       	std	Y+15, r1	; 0x0f
    1d52:	18 8a       	std	Y+16, r1	; 0x10
    1d54:	19 8a       	std	Y+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    1d56:	81 14       	cp	r8, r1
    1d58:	91 04       	cpc	r9, r1
    1d5a:	09 f4       	brne	.+2      	; 0x1d5e <_ZN8TaskBaseC1EPKchjP8emstream+0x92>
    1d5c:	32 c0       	rjmp	.+100    	; 0x1dc2 <_ZN8TaskBaseC1EPKchjP8emstream+0xf6>
	{
		if (task_status == pdPASS)
    1d5e:	81 30       	cpi	r24, 0x01	; 1
    1d60:	d9 f4       	brne	.+54     	; 0x1d98 <_ZN8TaskBaseC1EPKchjP8emstream+0xcc>
		{
			*p_serial << PMS ("Task \"") << a_name << PMS ("\" created, stack at 0x")
    1d62:	6b e0       	ldi	r22, 0x0B	; 11
    1d64:	c4 01       	movw	r24, r8
    1d66:	b8 d4       	rcall	.+2416   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d68:	ec 01       	movw	r28, r24
    1d6a:	6d e8       	ldi	r22, 0x8D	; 141
    1d6c:	71 e0       	ldi	r23, 0x01	; 1
    1d6e:	7d d4       	rcall	.+2298   	; 0x266a <_ZN8emstream4putsEPKc>
    1d70:	b3 01       	movw	r22, r6
    1d72:	ce 01       	movw	r24, r28
    1d74:	7a d4       	rcall	.+2292   	; 0x266a <_ZN8emstream4putsEPKc>
    1d76:	6b e0       	ldi	r22, 0x0B	; 11
    1d78:	ce 01       	movw	r24, r28
    1d7a:	ae d4       	rcall	.+2396   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d7c:	ec 01       	movw	r28, r24
    1d7e:	64 e9       	ldi	r22, 0x94	; 148
    1d80:	71 e0       	ldi	r23, 0x01	; 1
    1d82:	73 d4       	rcall	.+2278   	; 0x266a <_ZN8emstream4putsEPKc>
				<< hex << (portPOINTER_SIZE_TYPE)top_of_stack << dec << endl;
    1d84:	63 e0       	ldi	r22, 0x03	; 3
    1d86:	ce 01       	movw	r24, r28
    1d88:	a7 d4       	rcall	.+2382   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d8a:	b2 01       	movw	r22, r4
    1d8c:	e9 d4       	rcall	.+2514   	; 0x2760 <_ZN8emstreamlsEj>
    1d8e:	62 e0       	ldi	r22, 0x02	; 2
    1d90:	a3 d4       	rcall	.+2374   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d92:	66 e0       	ldi	r22, 0x06	; 6
    1d94:	a1 d4       	rcall	.+2370   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d96:	15 c0       	rjmp	.+42     	; 0x1dc2 <_ZN8TaskBaseC1EPKchjP8emstream+0xf6>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task \"") << a_name << '"' << endl;
    1d98:	6b e0       	ldi	r22, 0x0B	; 11
    1d9a:	c4 01       	movw	r24, r8
    1d9c:	9d d4       	rcall	.+2362   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1d9e:	ec 01       	movw	r28, r24
    1da0:	67 e7       	ldi	r22, 0x77	; 119
    1da2:	71 e0       	ldi	r23, 0x01	; 1
    1da4:	62 d4       	rcall	.+2244   	; 0x266a <_ZN8emstream4putsEPKc>
    1da6:	b3 01       	movw	r22, r6
    1da8:	ce 01       	movw	r24, r28
    1daa:	5f d4       	rcall	.+2238   	; 0x266a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    1dac:	e8 81       	ld	r30, Y
    1dae:	f9 81       	ldd	r31, Y+1	; 0x01
    1db0:	02 80       	ldd	r0, Z+2	; 0x02
    1db2:	f3 81       	ldd	r31, Z+3	; 0x03
    1db4:	e0 2d       	mov	r30, r0
    1db6:	62 e2       	ldi	r22, 0x22	; 34
    1db8:	ce 01       	movw	r24, r28
    1dba:	09 95       	icall
    1dbc:	66 e0       	ldi	r22, 0x06	; 6
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	8b d4       	rcall	.+2326   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    1dc2:	df 91       	pop	r29
    1dc4:	cf 91       	pop	r28
    1dc6:	1f 91       	pop	r17
    1dc8:	0f 91       	pop	r16
    1dca:	ff 90       	pop	r15
    1dcc:	ef 90       	pop	r14
    1dce:	df 90       	pop	r13
    1dd0:	cf 90       	pop	r12
    1dd2:	bf 90       	pop	r11
    1dd4:	af 90       	pop	r10
    1dd6:	9f 90       	pop	r9
    1dd8:	8f 90       	pop	r8
    1dda:	7f 90       	pop	r7
    1ddc:	6f 90       	pop	r6
    1dde:	5f 90       	pop	r5
    1de0:	4f 90       	pop	r4
    1de2:	08 95       	ret

00001de4 <_ZN8TaskBase22_call_users_run_methodEPS_>:
 *           it is the C (not C++) function which was registered with the scheduler.
 *  @param   p_task A pointer to the task (this task) whose run method is to be called
 */

void TaskBase::_call_users_run_method (TaskBase* p_task)
{
    1de4:	ec 01       	movw	r28, r24
	// This is where the user's run() method is actually called
	p_task->run ();
    1de6:	e8 81       	ld	r30, Y
    1de8:	f9 81       	ldd	r31, Y+1	; 0x01
    1dea:	01 90       	ld	r0, Z+
    1dec:	f0 81       	ld	r31, Z
    1dee:	e0 2d       	mov	r30, r0
    1df0:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    1df2:	1b 82       	std	Y+3, r1	; 0x03
    1df4:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    1df6:	6f ef       	ldi	r22, 0xFF	; 255
    1df8:	7f ef       	ldi	r23, 0xFF	; 255
    1dfa:	cb 01       	movw	r24, r22
    1dfc:	c6 dc       	rcall	.-1652   	; 0x178a <vTaskDelay>
 *           @c _call_static_run_method() function was, in turn, called by FreeRTOS; 
 *           it is the C (not C++) function which was registered with the scheduler.
 *  @param   p_task A pointer to the task (this task) whose run method is to be called
 */

void TaskBase::_call_users_run_method (TaskBase* p_task)
    1dfe:	fb cf       	rjmp	.-10     	; 0x1df6 <_ZN8TaskBase22_call_users_run_methodEPS_+0x12>

00001e00 <_call_static_run_method>:
 *                  function; the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (TaskBase* p_task)
{
	TaskBase::_call_users_run_method (p_task);
    1e00:	f1 df       	rcall	.-30     	; 0x1de4 <_ZN8TaskBase22_call_users_run_methodEPS_>

00001e02 <_ZN8TaskBase13transition_toEh>:
 *  @param   new_state The state to which this task will transition
 */

void TaskBase::transition_to (uint8_t new_state)
{
	state = new_state;
    1e02:	fc 01       	movw	r30, r24
    1e04:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    1e06:	65 87       	std	Z+13, r22	; 0x0d
    1e08:	08 95       	ret

00001e0a <_ZN8TaskBase19print_stack_in_listEP8emstream>:
 *           printed separately afterwards. 
 *  @param   p_ser_dev The serial device to which each task prints its stack
 */

void TaskBase::print_stack_in_list (emstream* p_ser_dev)
{
    1e0a:	cf 92       	push	r12
    1e0c:	df 92       	push	r13
    1e0e:	ef 92       	push	r14
    1e10:	ff 92       	push	r15
    1e12:	0f 93       	push	r16
    1e14:	1f 93       	push	r17
    1e16:	cf 93       	push	r28
    1e18:	df 93       	push	r29
    1e1a:	ec 01       	movw	r28, r24
    1e1c:	7b 01       	movw	r14, r22
	*p_ser_dev << PMS ("Task: ") 
			   << (const char*)(pcTaskGetTaskName (handle)) 
    1e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e20:	9b 81       	ldd	r25, Y+3	; 0x03
    1e22:	ce da       	rcall	.-2660   	; 0x13c0 <pcTaskGetTaskName>
    1e24:	6c 01       	movw	r12, r24
 *  @param   p_ser_dev The serial device to which each task prints its stack
 */

void TaskBase::print_stack_in_list (emstream* p_ser_dev)
{
	*p_ser_dev << PMS ("Task: ") 
    1e26:	6b e0       	ldi	r22, 0x0B	; 11
    1e28:	c7 01       	movw	r24, r14
    1e2a:	56 d4       	rcall	.+2220   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1e2c:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1e2e:	6b ea       	ldi	r22, 0xAB	; 171
    1e30:	71 e0       	ldi	r23, 0x01	; 1
    1e32:	1b d4       	rcall	.+2102   	; 0x266a <_ZN8emstream4putsEPKc>
    1e34:	b6 01       	movw	r22, r12
    1e36:	c8 01       	movw	r24, r16
    1e38:	18 d4       	rcall	.+2096   	; 0x266a <_ZN8emstream4putsEPKc>
			   << (const char*)(pcTaskGetTaskName (handle)) 
			   << endl;
    1e3a:	66 e0       	ldi	r22, 0x06	; 6
    1e3c:	c8 01       	movw	r24, r16
    1e3e:	4c d4       	rcall	.+2200   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param   p_ser_dev The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_dev)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_dev);
    1e40:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e42:	9b 85       	ldd	r25, Y+11	; 0x0b
		 *           stack's contents for debugging and instructional purposes.
		 *  @param   p_ser_dev The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_dev)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
    1e44:	28 85       	ldd	r18, Y+8	; 0x08
    1e46:	39 85       	ldd	r19, Y+9	; 0x09
								(uint8_t*)(top_of_stack), p_ser_dev);
    1e48:	a7 01       	movw	r20, r14
    1e4a:	bc 01       	movw	r22, r24
    1e4c:	82 1b       	sub	r24, r18
    1e4e:	93 0b       	sbc	r25, r19
    1e50:	e6 d2       	rcall	.+1484   	; 0x241e <_Z15hex_dump_memoryPhS_P8emstream>

	dump_stack (p_ser_dev);

	if (prev_task_pointer != NULL)
    1e52:	8c 81       	ldd	r24, Y+4	; 0x04
    1e54:	9d 81       	ldd	r25, Y+5	; 0x05
    1e56:	00 97       	sbiw	r24, 0x00	; 0
    1e58:	11 f0       	breq	.+4      	; 0x1e5e <_ZN8TaskBase19print_stack_in_listEP8emstream+0x54>
	{
		prev_task_pointer->print_stack_in_list (p_ser_dev);
    1e5a:	b7 01       	movw	r22, r14
    1e5c:	d6 df       	rcall	.-84     	; 0x1e0a <_ZN8TaskBase19print_stack_in_listEP8emstream>
	}
}
    1e5e:	df 91       	pop	r29
    1e60:	cf 91       	pop	r28
    1e62:	1f 91       	pop	r17
    1e64:	0f 91       	pop	r16
    1e66:	ff 90       	pop	r15
    1e68:	ef 90       	pop	r14
    1e6a:	df 90       	pop	r13
    1e6c:	cf 90       	pop	r12
    1e6e:	08 95       	ret

00001e70 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    1e70:	0f 93       	push	r16
    1e72:	1f 93       	push	r17
    1e74:	cf 93       	push	r28
    1e76:	df 93       	push	r29
    1e78:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    1e7a:	80 91 2e 1a 	lds	r24, 0x1A2E
    1e7e:	90 91 2f 1a 	lds	r25, 0x1A2F
    1e82:	00 97       	sbiw	r24, 0x00	; 0
    1e84:	11 f0       	breq	.+4      	; 0x1e8a <_Z17print_task_stacksP8emstream+0x1a>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    1e86:	be 01       	movw	r22, r28
    1e88:	c0 df       	rcall	.-128    	; 0x1e0a <_ZN8TaskBase19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << PMS ("Task: IDLE") << endl;
    1e8a:	6b e0       	ldi	r22, 0x0B	; 11
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	24 d4       	rcall	.+2120   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1e90:	8c 01       	movw	r16, r24
    1e92:	62 eb       	ldi	r22, 0xB2	; 178
    1e94:	71 e0       	ldi	r23, 0x01	; 1
    1e96:	e9 d3       	rcall	.+2002   	; 0x266a <_ZN8emstream4putsEPKc>
    1e98:	66 e0       	ldi	r22, 0x06	; 6
    1e9a:	c8 01       	movw	r24, r16
    1e9c:	1d d4       	rcall	.+2106   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
								(uint8_t*)(portStackTopForTask + 1), ser_dev);
    1e9e:	80 91 3e 1a 	lds	r24, 0x1A3E
    1ea2:	90 91 3f 1a 	lds	r25, 0x1A3F
    1ea6:	bc 01       	movw	r22, r24
    1ea8:	6f 5f       	subi	r22, 0xFF	; 255
    1eaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1eac:	ae 01       	movw	r20, r28
    1eae:	83 56       	subi	r24, 0x63	; 99
    1eb0:	91 09       	sbc	r25, r1
    1eb2:	b5 d2       	rcall	.+1386   	; 0x241e <_Z15hex_dump_memoryPhS_P8emstream>
}
    1eb4:	df 91       	pop	r29
    1eb6:	cf 91       	pop	r28
    1eb8:	1f 91       	pop	r17
    1eba:	0f 91       	pop	r16
    1ebc:	08 95       	ret

00001ebe <_ZN8TaskBase12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void TaskBase::print_status (emstream& ser_dev)
{
    1ebe:	8f 92       	push	r8
    1ec0:	9f 92       	push	r9
    1ec2:	af 92       	push	r10
    1ec4:	bf 92       	push	r11
    1ec6:	cf 92       	push	r12
    1ec8:	df 92       	push	r13
    1eca:	ef 92       	push	r14
    1ecc:	ff 92       	push	r15
    1ece:	0f 93       	push	r16
    1ed0:	1f 93       	push	r17
    1ed2:	cf 93       	push	r28
    1ed4:	df 93       	push	r29
    1ed6:	ec 01       	movw	r28, r24
    1ed8:	8b 01       	movw	r16, r22
	ser_dev.puts (pcTaskGetTaskName (handle));
    1eda:	8a 81       	ldd	r24, Y+2	; 0x02
    1edc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ede:	70 da       	rcall	.-2848   	; 0x13c0 <pcTaskGetTaskName>
    1ee0:	bc 01       	movw	r22, r24
    1ee2:	c8 01       	movw	r24, r16
    1ee4:	c2 d3       	rcall	.+1924   	; 0x266a <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    1ee6:	d8 01       	movw	r26, r16
    1ee8:	ed 91       	ld	r30, X+
    1eea:	fc 91       	ld	r31, X
    1eec:	02 80       	ldd	r0, Z+2	; 0x02
    1eee:	f3 81       	ldd	r31, Z+3	; 0x03
    1ef0:	e0 2d       	mov	r30, r0
    1ef2:	69 e0       	ldi	r22, 0x09	; 9
    1ef4:	c8 01       	movw	r24, r16
    1ef6:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    1ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    1efa:	9b 81       	ldd	r25, Y+3	; 0x03
    1efc:	61 da       	rcall	.-2878   	; 0x13c0 <pcTaskGetTaskName>
    1efe:	fc 01       	movw	r30, r24
    1f00:	01 90       	ld	r0, Z+
    1f02:	00 20       	and	r0, r0
    1f04:	e9 f7       	brne	.-6      	; 0x1f00 <_ZN8TaskBase12print_statusER8emstream+0x42>
    1f06:	31 97       	sbiw	r30, 0x01	; 1
    1f08:	e8 1b       	sub	r30, r24
    1f0a:	f9 0b       	sbc	r31, r25
    1f0c:	38 97       	sbiw	r30, 0x08	; 8
    1f0e:	48 f4       	brcc	.+18     	; 0x1f22 <_ZN8TaskBase12print_statusER8emstream+0x64>
	{
		ser_dev.putchar ('\t');
    1f10:	d8 01       	movw	r26, r16
    1f12:	ed 91       	ld	r30, X+
    1f14:	fc 91       	ld	r31, X
    1f16:	02 80       	ldd	r0, Z+2	; 0x02
    1f18:	f3 81       	ldd	r31, Z+3	; 0x03
    1f1a:	e0 2d       	mov	r30, r0
    1f1c:	69 e0       	ldi	r22, 0x09	; 9
    1f1e:	c8 01       	movw	r24, r16
    1f20:	09 95       	icall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< (size_t)(get_total_stack ()) << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    1f22:	ce 84       	ldd	r12, Y+14	; 0x0e
    1f24:	df 84       	ldd	r13, Y+15	; 0x0f
    1f26:	e8 88       	ldd	r14, Y+16	; 0x10
    1f28:	f9 88       	ldd	r15, Y+17	; 0x11
		 *           the constructor call.
		 *  @return  The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    1f2a:	a8 84       	ldd	r10, Y+8	; 0x08
    1f2c:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << (uint8_t)(uxTaskPriorityGet (handle)) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    1f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f30:	9b 81       	ldd	r25, Y+3	; 0x03
    1f32:	8d dd       	rcall	.-1254   	; 0x1a4e <uxTaskGetStackHighWaterMark>
    1f34:	98 2e       	mov	r9, r24
		 *           cause state transitions.
		 *  @return  The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    1f36:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << (uint8_t)(uxTaskPriorityGet (handle)) << PMS ("\t")
    1f38:	8a 81       	ldd	r24, Y+2	; 0x02
    1f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f3c:	ee d9       	rcall	.-3108   	; 0x131a <uxTaskPriorityGet>
    1f3e:	68 2f       	mov	r22, r24
    1f40:	c8 01       	movw	r24, r16
    1f42:	86 d4       	rcall	.+2316   	; 0x2850 <_ZN8emstreamlsEh>
    1f44:	6b e0       	ldi	r22, 0x0B	; 11
    1f46:	c8 d3       	rcall	.+1936   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1f48:	ec 01       	movw	r28, r24
    1f4a:	66 e2       	ldi	r22, 0x26	; 38
    1f4c:	72 e0       	ldi	r23, 0x02	; 2
    1f4e:	8d d3       	rcall	.+1818   	; 0x266a <_ZN8emstream4putsEPKc>
			<< get_state ()
    1f50:	68 2d       	mov	r22, r8
    1f52:	ce 01       	movw	r24, r28
    1f54:	7d d4       	rcall	.+2298   	; 0x2850 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    1f56:	6b e0       	ldi	r22, 0x0B	; 11
    1f58:	bf d3       	rcall	.+1918   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1f5a:	ec 01       	movw	r28, r24
    1f5c:	68 e2       	ldi	r22, 0x28	; 40
    1f5e:	72 e0       	ldi	r23, 0x02	; 2
    1f60:	84 d3       	rcall	.+1800   	; 0x266a <_ZN8emstream4putsEPKc>
    1f62:	69 2d       	mov	r22, r9
    1f64:	ce 01       	movw	r24, r28
    1f66:	74 d4       	rcall	.+2280   	; 0x2850 <_ZN8emstreamlsEh>
    1f68:	6b e0       	ldi	r22, 0x0B	; 11
    1f6a:	b6 d3       	rcall	.+1900   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1f6c:	ec 01       	movw	r28, r24
    1f6e:	6a e2       	ldi	r22, 0x2A	; 42
    1f70:	72 e0       	ldi	r23, 0x02	; 2
    1f72:	7b d3       	rcall	.+1782   	; 0x266a <_ZN8emstream4putsEPKc>
			<< (size_t)(get_total_stack ()) << PMS ("\t")
    1f74:	b5 01       	movw	r22, r10
    1f76:	ce 01       	movw	r24, r28
    1f78:	f3 d3       	rcall	.+2022   	; 0x2760 <_ZN8emstreamlsEj>
    1f7a:	6b e0       	ldi	r22, 0x0B	; 11
    1f7c:	ad d3       	rcall	.+1882   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1f7e:	ec 01       	movw	r28, r24
    1f80:	6c e2       	ldi	r22, 0x2C	; 44
    1f82:	72 e0       	ldi	r23, 0x02	; 2
    1f84:	72 d3       	rcall	.+1764   	; 0x266a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    1f86:	6b e0       	ldi	r22, 0x0B	; 11
    1f88:	ce 01       	movw	r24, r28
    1f8a:	a6 d3       	rcall	.+1868   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    1f8c:	ec 01       	movw	r28, r24
    1f8e:	6e e2       	ldi	r22, 0x2E	; 46
    1f90:	72 e0       	ldi	r23, 0x02	; 2
    1f92:	6b d3       	rcall	.+1750   	; 0x266a <_ZN8emstream4putsEPKc>
    1f94:	b7 01       	movw	r22, r14
    1f96:	a6 01       	movw	r20, r12
    1f98:	ce 01       	movw	r24, r28
    1f9a:	18 d4       	rcall	.+2096   	; 0x27cc <_ZN8emstreamlsEm>
}
    1f9c:	df 91       	pop	r29
    1f9e:	cf 91       	pop	r28
    1fa0:	1f 91       	pop	r17
    1fa2:	0f 91       	pop	r16
    1fa4:	ff 90       	pop	r15
    1fa6:	ef 90       	pop	r14
    1fa8:	df 90       	pop	r13
    1faa:	cf 90       	pop	r12
    1fac:	bf 90       	pop	r11
    1fae:	af 90       	pop	r10
    1fb0:	9f 90       	pop	r9
    1fb2:	8f 90       	pop	r8
    1fb4:	08 95       	ret

00001fb6 <_ZlsR8emstreamR8TaskBase>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, TaskBase& a_task)
{
    1fb6:	cf 93       	push	r28
    1fb8:	df 93       	push	r29
    1fba:	ec 01       	movw	r28, r24
    1fbc:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    1fbe:	db 01       	movw	r26, r22
    1fc0:	ed 91       	ld	r30, X+
    1fc2:	fc 91       	ld	r31, X
    1fc4:	02 80       	ldd	r0, Z+2	; 0x02
    1fc6:	f3 81       	ldd	r31, Z+3	; 0x03
    1fc8:	e0 2d       	mov	r30, r0
    1fca:	be 01       	movw	r22, r28
    1fcc:	09 95       	icall
	return (ser_dev);
}
    1fce:	ce 01       	movw	r24, r28
    1fd0:	df 91       	pop	r29
    1fd2:	cf 91       	pop	r28
    1fd4:	08 95       	ret

00001fd6 <_ZN8TaskBase20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void TaskBase::print_status_in_list (emstream* ser_device)
{
    1fd6:	0f 93       	push	r16
    1fd8:	1f 93       	push	r17
    1fda:	cf 93       	push	r28
    1fdc:	df 93       	push	r29
    1fde:	ec 01       	movw	r28, r24
    1fe0:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    1fe2:	bc 01       	movw	r22, r24
    1fe4:	c8 01       	movw	r24, r16
    1fe6:	e7 df       	rcall	.-50     	; 0x1fb6 <_ZlsR8emstreamR8TaskBase>
    1fe8:	66 e0       	ldi	r22, 0x06	; 6
    1fea:	76 d3       	rcall	.+1772   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    1fec:	8c 81       	ldd	r24, Y+4	; 0x04
    1fee:	9d 81       	ldd	r25, Y+5	; 0x05
    1ff0:	00 97       	sbiw	r24, 0x00	; 0
    1ff2:	11 f0       	breq	.+4      	; 0x1ff8 <_ZN8TaskBase20print_status_in_listEP8emstream+0x22>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    1ff4:	b8 01       	movw	r22, r16
    1ff6:	ef df       	rcall	.-34     	; 0x1fd6 <_ZN8TaskBase20print_status_in_listEP8emstream>
	}
}
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	08 95       	ret

00002002 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2002:	0f 93       	push	r16
    2004:	1f 93       	push	r17
    2006:	cf 93       	push	r28
    2008:	df 93       	push	r29
    200a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    200c:	6b e0       	ldi	r22, 0x0B	; 11
    200e:	64 d3       	rcall	.+1736   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2010:	8c 01       	movw	r16, r24
    2012:	64 e1       	ldi	r22, 0x14	; 20
    2014:	72 e0       	ldi	r23, 0x02	; 2
    2016:	29 d3       	rcall	.+1618   	; 0x266a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2018:	6b e0       	ldi	r22, 0x0B	; 11
    201a:	c8 01       	movw	r24, r16
    201c:	5d d3       	rcall	.+1722   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    201e:	8c 01       	movw	r16, r24
    2020:	6f e1       	ldi	r22, 0x1F	; 31
    2022:	72 e0       	ldi	r23, 0x02	; 2
    2024:	22 d3       	rcall	.+1604   	; 0x266a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2026:	66 e0       	ldi	r22, 0x06	; 6
    2028:	c8 01       	movw	r24, r16
    202a:	56 d3       	rcall	.+1708   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    202c:	6b e0       	ldi	r22, 0x0B	; 11
    202e:	ce 01       	movw	r24, r28
    2030:	53 d3       	rcall	.+1702   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2032:	8c 01       	movw	r16, r24
    2034:	61 ef       	ldi	r22, 0xF1	; 241
    2036:	71 e0       	ldi	r23, 0x01	; 1
    2038:	18 d3       	rcall	.+1584   	; 0x266a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    203a:	6b e0       	ldi	r22, 0x0B	; 11
    203c:	c8 01       	movw	r24, r16
    203e:	4c d3       	rcall	.+1688   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2040:	8c 01       	movw	r16, r24
    2042:	62 e0       	ldi	r22, 0x02	; 2
    2044:	72 e0       	ldi	r23, 0x02	; 2
    2046:	11 d3       	rcall	.+1570   	; 0x266a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2048:	6b e0       	ldi	r22, 0x0B	; 11
    204a:	c8 01       	movw	r24, r16
    204c:	45 d3       	rcall	.+1674   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    204e:	8c 01       	movw	r16, r24
    2050:	6e e0       	ldi	r22, 0x0E	; 14
    2052:	72 e0       	ldi	r23, 0x02	; 2
    2054:	0a d3       	rcall	.+1556   	; 0x266a <_ZN8emstream4putsEPKc>
    2056:	66 e0       	ldi	r22, 0x06	; 6
    2058:	c8 01       	movw	r24, r16
    205a:	3e d3       	rcall	.+1660   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    205c:	6b e0       	ldi	r22, 0x0B	; 11
    205e:	ce 01       	movw	r24, r28
    2060:	3b d3       	rcall	.+1654   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2062:	8c 01       	movw	r16, r24
    2064:	6e ec       	ldi	r22, 0xCE	; 206
    2066:	71 e0       	ldi	r23, 0x01	; 1
    2068:	00 d3       	rcall	.+1536   	; 0x266a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    206a:	6b e0       	ldi	r22, 0x0B	; 11
    206c:	c8 01       	movw	r24, r16
    206e:	34 d3       	rcall	.+1640   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2070:	8c 01       	movw	r16, r24
    2072:	6f ed       	ldi	r22, 0xDF	; 223
    2074:	71 e0       	ldi	r23, 0x01	; 1
    2076:	f9 d2       	rcall	.+1522   	; 0x266a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2078:	6b e0       	ldi	r22, 0x0B	; 11
    207a:	c8 01       	movw	r24, r16
    207c:	2d d3       	rcall	.+1626   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    207e:	8c 01       	movw	r16, r24
    2080:	6b ee       	ldi	r22, 0xEB	; 235
    2082:	71 e0       	ldi	r23, 0x01	; 1
    2084:	f2 d2       	rcall	.+1508   	; 0x266a <_ZN8emstream4putsEPKc>
    2086:	66 e0       	ldi	r22, 0x06	; 6
    2088:	c8 01       	movw	r24, r16
    208a:	26 d3       	rcall	.+1612   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    208c:	80 91 2e 1a 	lds	r24, 0x1A2E
    2090:	90 91 2f 1a 	lds	r25, 0x1A2F
    2094:	00 97       	sbiw	r24, 0x00	; 0
    2096:	11 f0       	breq	.+4      	; 0x209c <_Z15print_task_listP8emstream+0x9a>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2098:	be 01       	movw	r22, r28
    209a:	9d df       	rcall	.-198    	; 0x1fd6 <_ZN8TaskBase20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    209c:	99 d9       	rcall	.-3278   	; 0x13d0 <xTaskGetIdleTaskHandle>
    209e:	d7 dc       	rcall	.-1618   	; 0x1a4e <uxTaskGetStackHighWaterMark>
    20a0:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    20a2:	6b e0       	ldi	r22, 0x0B	; 11
    20a4:	ce 01       	movw	r24, r28
    20a6:	18 d3       	rcall	.+1584   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    20a8:	ec 01       	movw	r28, r24
    20aa:	6d eb       	ldi	r22, 0xBD	; 189
    20ac:	71 e0       	ldi	r23, 0x01	; 1
    20ae:	dd d2       	rcall	.+1466   	; 0x266a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    20b0:	61 2f       	mov	r22, r17
    20b2:	ce 01       	movw	r24, r28
    20b4:	cd d3       	rcall	.+1946   	; 0x2850 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t-")
    20b6:	6b e0       	ldi	r22, 0x0B	; 11
    20b8:	0f d3       	rcall	.+1566   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    20ba:	ec 01       	movw	r28, r24
    20bc:	68 ec       	ldi	r22, 0xC8	; 200
    20be:	71 e0       	ldi	r23, 0x01	; 1
    20c0:	d4 d2       	rcall	.+1448   	; 0x266a <_ZN8emstream4putsEPKc>
    20c2:	64 e6       	ldi	r22, 0x64	; 100
    20c4:	70 e0       	ldi	r23, 0x00	; 0
    20c6:	ce 01       	movw	r24, r28
    20c8:	4b d3       	rcall	.+1686   	; 0x2760 <_ZN8emstreamlsEj>
    20ca:	6b e0       	ldi	r22, 0x0B	; 11
    20cc:	05 d3       	rcall	.+1546   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    20ce:	ec 01       	movw	r28, r24
    20d0:	6a ec       	ldi	r22, 0xCA	; 202
    20d2:	71 e0       	ldi	r23, 0x01	; 1
    20d4:	ca d2       	rcall	.+1428   	; 0x266a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    20d6:	66 e0       	ldi	r22, 0x06	; 6
    20d8:	ce 01       	movw	r24, r28
    20da:	fe d2       	rcall	.+1532   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
}
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	1f 91       	pop	r17
    20e2:	0f 91       	pop	r16
    20e4:	08 95       	ret

000020e6 <_ZN9TextQueue13print_in_listEP8emstream>:
 *           device. 
 *  @param   p_ser_dev Pointer to a serial device on which to print the status
 */

void TextQueue::print_in_list (emstream* p_ser_dev)
{
    20e6:	cf 92       	push	r12
    20e8:	df 92       	push	r13
    20ea:	ef 92       	push	r14
    20ec:	ff 92       	push	r15
    20ee:	0f 93       	push	r16
    20f0:	1f 93       	push	r17
    20f2:	cf 93       	push	r28
    20f4:	df 93       	push	r29
    20f6:	7c 01       	movw	r14, r24
    20f8:	8b 01       	movw	r16, r22
    20fa:	dc 01       	movw	r26, r24
    20fc:	1a 96       	adiw	r26, 0x0a	; 10
    20fe:	6d 91       	ld	r22, X+
    2100:	7c 91       	ld	r23, X
    2102:	1b 97       	sbiw	r26, 0x0b	; 11
    2104:	c8 01       	movw	r24, r16
    2106:	b1 d2       	rcall	.+1378   	; 0x266a <_ZN8emstream4putsEPKc>
	// Print this task's name and pad it to 16 characters
	*p_ser_dev << name;
	for (uint8_t cols = strlen (name); cols < 16; cols++)
    2108:	f7 01       	movw	r30, r14
    210a:	a2 85       	ldd	r26, Z+10	; 0x0a
    210c:	b3 85       	ldd	r27, Z+11	; 0x0b
    210e:	fd 01       	movw	r30, r26
    2110:	01 90       	ld	r0, Z+
    2112:	00 20       	and	r0, r0
    2114:	e9 f7       	brne	.-6      	; 0x2110 <_ZN9TextQueue13print_in_listEP8emstream+0x2a>
    2116:	31 97       	sbiw	r30, 0x01	; 1
    2118:	ce 2f       	mov	r28, r30
    211a:	ca 1b       	sub	r28, r26
    211c:	c0 31       	cpi	r28, 0x10	; 16
    211e:	60 f4       	brcc	.+24     	; 0x2138 <_ZN9TextQueue13print_in_listEP8emstream+0x52>
	{
		p_ser_dev->putchar (' ');
    2120:	d8 01       	movw	r26, r16
    2122:	ed 91       	ld	r30, X+
    2124:	fc 91       	ld	r31, X
    2126:	02 80       	ldd	r0, Z+2	; 0x02
    2128:	f3 81       	ldd	r31, Z+3	; 0x03
    212a:	e0 2d       	mov	r30, r0
    212c:	60 e2       	ldi	r22, 0x20	; 32
    212e:	c8 01       	movw	r24, r16
    2130:	09 95       	icall

void TextQueue::print_in_list (emstream* p_ser_dev)
{
	// Print this task's name and pad it to 16 characters
	*p_ser_dev << name;
	for (uint8_t cols = strlen (name); cols < 16; cols++)
    2132:	cf 5f       	subi	r28, 0xFF	; 255
    2134:	c0 31       	cpi	r28, 0x10	; 16
    2136:	a1 f7       	brne	.-24     	; 0x2120 <_ZN9TextQueue13print_in_listEP8emstream+0x3a>
	{
		p_ser_dev->putchar (' ');
	}

	// Print the type
	p_ser_dev->puts ("txt_q\t");
    2138:	6b e1       	ldi	r22, 0x1B	; 27
    213a:	72 e0       	ldi	r23, 0x02	; 2
    213c:	c8 01       	movw	r24, r16
    213e:	95 d2       	rcall	.+1322   	; 0x266a <_ZN8emstream4putsEPKc>

	// Print the free and total number of spaces in the queue
	*p_ser_dev << uxQueueSpacesAvailable (the_queue) << '/' << buf_size << '\t';
    2140:	f7 01       	movw	r30, r14
    2142:	c6 88       	ldd	r12, Z+22	; 0x16
    2144:	d7 88       	ldd	r13, Z+23	; 0x17
    2146:	86 85       	ldd	r24, Z+14	; 0x0e
    2148:	97 85       	ldd	r25, Z+15	; 0x0f
    214a:	0e 94 2f 08 	call	0x105e	; 0x105e <uxQueueSpacesAvailable>
    214e:	68 2f       	mov	r22, r24
    2150:	c8 01       	movw	r24, r16
    2152:	7e d3       	rcall	.+1788   	; 0x2850 <_ZN8emstreamlsEh>
    2154:	ec 01       	movw	r28, r24
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2156:	e8 81       	ld	r30, Y
    2158:	f9 81       	ldd	r31, Y+1	; 0x01
    215a:	02 80       	ldd	r0, Z+2	; 0x02
    215c:	f3 81       	ldd	r31, Z+3	; 0x03
    215e:	e0 2d       	mov	r30, r0
    2160:	6f e2       	ldi	r22, 0x2F	; 47
    2162:	09 95       	icall
    2164:	b6 01       	movw	r22, r12
    2166:	ce 01       	movw	r24, r28
    2168:	fb d2       	rcall	.+1526   	; 0x2760 <_ZN8emstreamlsEj>
    216a:	dc 01       	movw	r26, r24
    216c:	ed 91       	ld	r30, X+
    216e:	fc 91       	ld	r31, X
    2170:	02 80       	ldd	r0, Z+2	; 0x02
    2172:	f3 81       	ldd	r31, Z+3	; 0x03
    2174:	e0 2d       	mov	r30, r0
    2176:	69 e0       	ldi	r22, 0x09	; 9
    2178:	09 95       	icall

	// End the line
	*p_ser_dev << endl;
    217a:	66 e0       	ldi	r22, 0x06	; 6
    217c:	c8 01       	movw	r24, r16
    217e:	ac d2       	rcall	.+1368   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	// Call the next item
	if (p_next != NULL)
    2180:	f7 01       	movw	r30, r14
    2182:	84 85       	ldd	r24, Z+12	; 0x0c
    2184:	95 85       	ldd	r25, Z+13	; 0x0d
    2186:	00 97       	sbiw	r24, 0x00	; 0
    2188:	41 f0       	breq	.+16     	; 0x219a <_ZN9TextQueue13print_in_listEP8emstream+0xb4>
	{
		p_next->print_in_list (p_ser_dev);
    218a:	dc 01       	movw	r26, r24
    218c:	ed 91       	ld	r30, X+
    218e:	fc 91       	ld	r31, X
    2190:	01 90       	ld	r0, Z+
    2192:	f0 81       	ld	r31, Z
    2194:	e0 2d       	mov	r30, r0
    2196:	b8 01       	movw	r22, r16
    2198:	09 95       	icall
	}
}
    219a:	df 91       	pop	r29
    219c:	cf 91       	pop	r28
    219e:	1f 91       	pop	r17
    21a0:	0f 91       	pop	r16
    21a2:	ff 90       	pop	r15
    21a4:	ef 90       	pop	r14
    21a6:	df 90       	pop	r13
    21a8:	cf 90       	pop	r12
    21aa:	08 95       	ret

000021ac <_ZThn6_N9TextQueue13print_in_listEP8emstream>:
    21ac:	06 97       	sbiw	r24, 0x06	; 6
    21ae:	9b cf       	rjmp	.-202    	; 0x20e6 <_ZN9TextQueue13print_in_listEP8emstream>

000021b0 <_ZN9TextQueue7getcharEv>:
 *           receiving task will not waste processor time until a character shows up.
 *  @return  The character which was received from the queue
 */

inline char TextQueue::getchar (void)
{
    21b0:	0f 93       	push	r16
    21b2:	cf 93       	push	r28
    21b4:	df 93       	push	r29
    21b6:	1f 92       	push	r1
    21b8:	cd b7       	in	r28, 0x3d	; 61
    21ba:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    21bc:	00 e0       	ldi	r16, 0x00	; 0
    21be:	2f ef       	ldi	r18, 0xFF	; 255
    21c0:	3f ef       	ldi	r19, 0xFF	; 255
    21c2:	a9 01       	movw	r20, r18
    21c4:	be 01       	movw	r22, r28
    21c6:	6f 5f       	subi	r22, 0xFF	; 255
    21c8:	7f 4f       	sbci	r23, 0xFF	; 255
    21ca:	fc 01       	movw	r30, r24
    21cc:	86 85       	ldd	r24, Z+14	; 0x0e
    21ce:	97 85       	ldd	r25, Z+15	; 0x0f
    21d0:	0e 94 6b 07 	call	0xed6	; 0xed6 <xQueueGenericReceive>
    21d4:	81 30       	cpi	r24, 0x01	; 1
    21d6:	11 f4       	brne	.+4      	; 0x21dc <_ZN9TextQueue7getcharEv+0x2c>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    21d8:	89 81       	ldd	r24, Y+1	; 0x01
    21da:	01 c0       	rjmp	.+2      	; 0x21de <_ZN9TextQueue7getcharEv+0x2e>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    21dc:	8f ef       	ldi	r24, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    21de:	0f 90       	pop	r0
    21e0:	df 91       	pop	r29
    21e2:	cf 91       	pop	r28
    21e4:	0f 91       	pop	r16
    21e6:	08 95       	ret

000021e8 <_ZN9TextQueue14check_for_charEv>:
 *  @return  True for character available, false for no character available
 */

inline bool TextQueue::check_for_char (void)
{
	return (uxQueueMessagesWaiting (the_queue));
    21e8:	fc 01       	movw	r30, r24
    21ea:	86 85       	ldd	r24, Z+14	; 0x0e
    21ec:	97 85       	ldd	r25, Z+15	; 0x0f
    21ee:	0e 94 27 08 	call	0x104e	; 0x104e <uxQueueMessagesWaiting>
    21f2:	91 e0       	ldi	r25, 0x01	; 1
    21f4:	81 11       	cpse	r24, r1
    21f6:	01 c0       	rjmp	.+2      	; 0x21fa <_ZN9TextQueue14check_for_charEv+0x12>
    21f8:	90 e0       	ldi	r25, 0x00	; 0
}
    21fa:	89 2f       	mov	r24, r25
    21fc:	08 95       	ret

000021fe <_ZN9TextQueue7putcharEc>:
 *           and return. 
 *  @param   a_char The character to be sent to the queue
 */

inline void TextQueue::putchar (char a_char)
{
    21fe:	0f 93       	push	r16
    2200:	cf 93       	push	r28
    2202:	df 93       	push	r29
    2204:	1f 92       	push	r1
    2206:	cd b7       	in	r28, 0x3d	; 61
    2208:	de b7       	in	r29, 0x3e	; 62
    220a:	69 83       	std	Y+1, r22	; 0x01
	xQueueSendToBack (the_queue, &a_char, ticks_to_wait);
    220c:	fc 01       	movw	r30, r24
    220e:	20 89       	ldd	r18, Z+16	; 0x10
    2210:	31 89       	ldd	r19, Z+17	; 0x11
    2212:	42 89       	ldd	r20, Z+18	; 0x12
    2214:	53 89       	ldd	r21, Z+19	; 0x13
    2216:	00 e0       	ldi	r16, 0x00	; 0
    2218:	be 01       	movw	r22, r28
    221a:	6f 5f       	subi	r22, 0xFF	; 255
    221c:	7f 4f       	sbci	r23, 0xFF	; 255
    221e:	86 85       	ldd	r24, Z+14	; 0x0e
    2220:	97 85       	ldd	r25, Z+15	; 0x0f
    2222:	0e 94 cf 06 	call	0xd9e	; 0xd9e <xQueueGenericSend>
}
    2226:	0f 90       	pop	r0
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	0f 91       	pop	r16
    222e:	08 95       	ret

00002230 <_ZN9TextQueueC1EjPKcP8emstreamm>:
 *                       portMAX_DELAY causes a send to block indefinitely
 *  @param   p_ser_dev A pointer which points to a serial device which can be used for
 *                     diagnostic logging or printing
 */

TextQueue::TextQueue (uint16_t queue_size, const char* p_name, emstream* p_ser_dev,
    2230:	4f 92       	push	r4
    2232:	5f 92       	push	r5
    2234:	6f 92       	push	r6
    2236:	7f 92       	push	r7
    2238:	8f 92       	push	r8
    223a:	9f 92       	push	r9
    223c:	af 92       	push	r10
    223e:	bf 92       	push	r11
    2240:	cf 92       	push	r12
    2242:	df 92       	push	r13
    2244:	ef 92       	push	r14
    2246:	ff 92       	push	r15
    2248:	0f 93       	push	r16
    224a:	1f 93       	push	r17
    224c:	cf 93       	push	r28
    224e:	df 93       	push	r29
    2250:	ec 01       	movw	r28, r24
    2252:	d6 2e       	mov	r13, r22
    2254:	c7 2e       	mov	r12, r23
    2256:	4a 01       	movw	r8, r20
    2258:	59 01       	movw	r10, r18
					  TickType_t a_wait_time)
	: emstream (), BaseShare (p_name)
    225a:	fc d1       	rcall	.+1016   	; 0x2654 <_ZN8emstreamC1Ev>
    225c:	b4 01       	movw	r22, r8
    225e:	ce 01       	movw	r24, r28
    2260:	06 96       	adiw	r24, 0x06	; 6
    2262:	c2 dc       	rcall	.-1660   	; 0x1be8 <_ZN9BaseShareC1EPKc>
    2264:	86 e2       	ldi	r24, 0x26	; 38
    2266:	92 e0       	ldi	r25, 0x02	; 2
    2268:	99 83       	std	Y+1, r25	; 0x01
    226a:	88 83       	st	Y, r24
    226c:	88 e3       	ldi	r24, 0x38	; 56
    226e:	92 e0       	ldi	r25, 0x02	; 2
    2270:	9f 83       	std	Y+7, r25	; 0x07
    2272:	8e 83       	std	Y+6, r24	; 0x06
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2274:	bd 8a       	std	Y+21, r11	; 0x15
    2276:	ac 8a       	std	Y+20, r10	; 0x14

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2278:	40 e0       	ldi	r20, 0x00	; 0
    227a:	61 e0       	ldi	r22, 0x01	; 1
    227c:	8d 2d       	mov	r24, r13
    227e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <xQueueGenericCreate>
    2282:	9f 87       	std	Y+15, r25	; 0x0f
    2284:	8e 87       	std	Y+14, r24	; 0x0e

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2286:	e8 8a       	std	Y+16, r14	; 0x10
    2288:	f9 8a       	std	Y+17, r15	; 0x11
    228a:	0a 8b       	std	Y+18, r16	; 0x12
    228c:	1b 8b       	std	Y+19, r17	; 0x13

	// Save the buffer size
	buf_size = queue_size;
    228e:	de 8a       	std	Y+22, r13	; 0x16
    2290:	cf 8a       	std	Y+23, r12	; 0x17
}
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	1f 91       	pop	r17
    2298:	0f 91       	pop	r16
    229a:	ff 90       	pop	r15
    229c:	ef 90       	pop	r14
    229e:	df 90       	pop	r13
    22a0:	cf 90       	pop	r12
    22a2:	bf 90       	pop	r11
    22a4:	af 90       	pop	r10
    22a6:	9f 90       	pop	r9
    22a8:	8f 90       	pop	r8
    22aa:	7f 90       	pop	r7
    22ac:	6f 90       	pop	r6
    22ae:	5f 90       	pop	r5
    22b0:	4f 90       	pop	r4
    22b2:	08 95       	ret

000022b4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    22b4:	cf 92       	push	r12
    22b6:	df 92       	push	r13
    22b8:	ef 92       	push	r14
    22ba:	ff 92       	push	r15
    22bc:	cf 93       	push	r28
    22be:	df 93       	push	r29
    22c0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
    22c2:	68 81       	ld	r22, Y
    22c4:	79 81       	ldd	r23, Y+1	; 0x01
    22c6:	8a 81       	ldd	r24, Y+2	; 0x02
    22c8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ca:	0f 2e       	mov	r0, r31
    22cc:	f8 ee       	ldi	r31, 0xE8	; 232
    22ce:	cf 2e       	mov	r12, r31
    22d0:	f3 e0       	ldi	r31, 0x03	; 3
    22d2:	df 2e       	mov	r13, r31
    22d4:	e1 2c       	mov	r14, r1
    22d6:	f1 2c       	mov	r15, r1
    22d8:	f0 2d       	mov	r31, r0
    22da:	a7 01       	movw	r20, r14
    22dc:	96 01       	movw	r18, r12
    22de:	0e 94 9d 19 	call	0x333a	; 0x333a <__udivmodsi4>
    22e2:	9b 01       	movw	r18, r22
    22e4:	ac 01       	movw	r20, r24
    22e6:	60 e4       	ldi	r22, 0x40	; 64
    22e8:	72 e4       	ldi	r23, 0x42	; 66
    22ea:	8f e0       	ldi	r24, 0x0F	; 15
    22ec:	90 e0       	ldi	r25, 0x00	; 0
    22ee:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <__mulsi3>
    22f2:	a7 01       	movw	r20, r14
    22f4:	96 01       	movw	r18, r12
    22f6:	0e 94 9d 19 	call	0x333a	; 0x333a <__udivmodsi4>
    22fa:	69 01       	movw	r12, r18
    22fc:	7a 01       	movw	r14, r20
			+ (int32_t)hardware_count * 1000000L 
    22fe:	ac 81       	ldd	r26, Y+4	; 0x04
    2300:	bd 81       	ldd	r27, Y+5	; 0x05
    2302:	20 e4       	ldi	r18, 0x40	; 64
    2304:	32 e4       	ldi	r19, 0x42	; 66
    2306:	4f e0       	ldi	r20, 0x0F	; 15
    2308:	50 e0       	ldi	r21, 0x00	; 0
    230a:	0e 94 e4 19 	call	0x33c8	; 0x33c8 <__muluhisi3>
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
    230e:	20 e8       	ldi	r18, 0x80	; 128
    2310:	34 e8       	ldi	r19, 0x84	; 132
    2312:	4e e1       	ldi	r20, 0x1E	; 30
    2314:	50 e0       	ldi	r21, 0x00	; 0
    2316:	0e 94 bf 19 	call	0x337e	; 0x337e <__divmodsi4>
	);
    231a:	c7 01       	movw	r24, r14
    231c:	b6 01       	movw	r22, r12
    231e:	62 0f       	add	r22, r18
    2320:	73 1f       	adc	r23, r19
    2322:	84 1f       	adc	r24, r20
    2324:	95 1f       	adc	r25, r21
}
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	ff 90       	pop	r15
    232c:	ef 90       	pop	r14
    232e:	df 90       	pop	r13
    2330:	cf 90       	pop	r12
    2332:	08 95       	ret

00002334 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2334:	cf 92       	push	r12
    2336:	df 92       	push	r13
    2338:	ef 92       	push	r14
    233a:	ff 92       	push	r15
    233c:	0f 93       	push	r16
    233e:	1f 93       	push	r17
    2340:	cf 93       	push	r28
    2342:	df 93       	push	r29
    2344:	cd b7       	in	r28, 0x3d	; 61
    2346:	de b7       	in	r29, 0x3e	; 62
    2348:	2f 97       	sbiw	r28, 0x0f	; 15
    234a:	0f b6       	in	r0, 0x3f	; 63
    234c:	f8 94       	cli
    234e:	de bf       	out	0x3e, r29	; 62
    2350:	0f be       	out	0x3f, r0	; 63
    2352:	cd bf       	out	0x3d, r28	; 61
    2354:	6c 01       	movw	r12, r24
    2356:	8b 01       	movw	r16, r22
		 *  computing the number of seconds. 
		 *  @return The number of whole seconds in the time stamp
		 */
		uint32_t get_seconds (void)
		{
			return (tick_count / configTICK_RATE_HZ);
    2358:	db 01       	movw	r26, r22
    235a:	6d 91       	ld	r22, X+
    235c:	7d 91       	ld	r23, X+
    235e:	8d 91       	ld	r24, X+
    2360:	9c 91       	ld	r25, X
    2362:	28 ee       	ldi	r18, 0xE8	; 232
    2364:	33 e0       	ldi	r19, 0x03	; 3
    2366:	40 e0       	ldi	r20, 0x00	; 0
    2368:	50 e0       	ldi	r21, 0x00	; 0
    236a:	e7 d7       	rcall	.+4046   	; 0x333a <__udivmodsi4>
    236c:	ba 01       	movw	r22, r20
    236e:	a9 01       	movw	r20, r18
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2370:	c6 01       	movw	r24, r12
    2372:	2c d2       	rcall	.+1112   	; 0x27cc <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2374:	d6 01       	movw	r26, r12
    2376:	ed 91       	ld	r30, X+
    2378:	fc 91       	ld	r31, X
    237a:	02 80       	ldd	r0, Z+2	; 0x02
    237c:	f3 81       	ldd	r31, Z+3	; 0x03
    237e:	e0 2d       	mov	r30, r0
    2380:	6e e2       	ldi	r22, 0x2E	; 46
    2382:	c6 01       	movw	r24, r12
    2384:	09 95       	icall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2386:	c8 01       	movw	r24, r16
    2388:	95 df       	rcall	.-214    	; 0x22b4 <_ZN10time_stamp12get_microsecEv>
    238a:	8e 01       	movw	r16, r28
    238c:	01 5f       	subi	r16, 0xF1	; 241
    238e:	1f 4f       	sbci	r17, 0xFF	; 255
    2390:	fe 01       	movw	r30, r28
    2392:	39 96       	adiw	r30, 0x09	; 9
    2394:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2396:	2a e0       	ldi	r18, 0x0A	; 10
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	40 e0       	ldi	r20, 0x00	; 0
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	ef d7       	rcall	.+4062   	; 0x337e <__divmodsi4>
    23a0:	e6 2f       	mov	r30, r22
    23a2:	29 83       	std	Y+1, r18	; 0x01
    23a4:	3a 83       	std	Y+2, r19	; 0x02
    23a6:	4b 83       	std	Y+3, r20	; 0x03
    23a8:	5c 83       	std	Y+4, r21	; 0x04
    23aa:	69 81       	ldd	r22, Y+1	; 0x01
    23ac:	7a 81       	ldd	r23, Y+2	; 0x02
    23ae:	8b 81       	ldd	r24, Y+3	; 0x03
    23b0:	9c 81       	ldd	r25, Y+4	; 0x04
		dig_buffer[index] = div_result.rem + '0';
    23b2:	20 e3       	ldi	r18, 0x30	; 48
    23b4:	2e 0f       	add	r18, r30
    23b6:	d8 01       	movw	r26, r16
    23b8:	2e 93       	st	-X, r18
    23ba:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    23bc:	ae 15       	cp	r26, r14
    23be:	bf 05       	cpc	r27, r15
    23c0:	51 f7       	brne	.-44     	; 0x2396 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    23c2:	1f 86       	std	Y+15, r1	; 0x0f
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    23c4:	be 01       	movw	r22, r28
    23c6:	67 5f       	subi	r22, 0xF7	; 247
    23c8:	7f 4f       	sbci	r23, 0xFF	; 255
    23ca:	c6 01       	movw	r24, r12
    23cc:	4e d1       	rcall	.+668    	; 0x266a <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    23ce:	c6 01       	movw	r24, r12
    23d0:	2f 96       	adiw	r28, 0x0f	; 15
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	f8 94       	cli
    23d6:	de bf       	out	0x3e, r29	; 62
    23d8:	0f be       	out	0x3f, r0	; 63
    23da:	cd bf       	out	0x3d, r28	; 61
    23dc:	df 91       	pop	r29
    23de:	cf 91       	pop	r28
    23e0:	1f 91       	pop	r17
    23e2:	0f 91       	pop	r16
    23e4:	ff 90       	pop	r15
    23e6:	ef 90       	pop	r14
    23e8:	df 90       	pop	r13
    23ea:	cf 90       	pop	r12
    23ec:	08 95       	ret

000023ee <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    23ee:	cf 93       	push	r28
    23f0:	df 93       	push	r29
    23f2:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    23f4:	0f b6       	in	r0, 0x3f	; 63
    23f6:	f8 94       	cli
    23f8:	0f 92       	push	r0

	// Now grab the hardware timer count. The tick count can't be updated, even if the
	// hardware timer overflows, because interrupts are disabled
	#if (defined TIMER5_COMPA_vect)
		hardware_count = TCNT5;
    23fa:	80 91 24 01 	lds	r24, 0x0124
    23fe:	90 91 25 01 	lds	r25, 0x0125
    2402:	9d 83       	std	Y+5, r25	; 0x05
    2404:	8c 83       	std	Y+4, r24	; 0x04
	#else
		hardware_count = TCNT1;
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2406:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <xTaskGetTickCount>
    240a:	68 83       	st	Y, r22
    240c:	79 83       	std	Y+1, r23	; 0x01
    240e:	8a 83       	std	Y+2, r24	; 0x02
    2410:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2412:	0f 90       	pop	r0
    2414:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2416:	ce 01       	movw	r24, r28
    2418:	df 91       	pop	r29
    241a:	cf 91       	pop	r28
    241c:	08 95       	ret

0000241e <_Z15hex_dump_memoryPhS_P8emstream>:
 *  @param p_ser_dev Pointer to the serial device on which data will be shown
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev)
{
    241e:	8f 92       	push	r8
    2420:	9f 92       	push	r9
    2422:	af 92       	push	r10
    2424:	bf 92       	push	r11
    2426:	cf 92       	push	r12
    2428:	df 92       	push	r13
    242a:	ef 92       	push	r14
    242c:	ff 92       	push	r15
    242e:	0f 93       	push	r16
    2430:	1f 93       	push	r17
    2432:	cf 93       	push	r28
    2434:	df 93       	push	r29
    2436:	6c 01       	movw	r12, r24
    2438:	5b 01       	movw	r10, r22
    243a:	ea 01       	movw	r28, r20
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    243c:	63 e0       	ldi	r22, 0x03	; 3
    243e:	ca 01       	movw	r24, r20
    2440:	4b d1       	rcall	.+662    	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2442:	ca 14       	cp	r12, r10
    2444:	db 04       	cpc	r13, r11
    2446:	08 f0       	brcs	.+2      	; 0x244a <_Z15hex_dump_memoryPhS_P8emstream+0x2c>
    2448:	5b c0       	rjmp	.+182    	; 0x2500 <_Z15hex_dump_memoryPhS_P8emstream+0xe2>
    244a:	76 01       	movw	r14, r12
    244c:	84 e1       	ldi	r24, 0x14	; 20
    244e:	e8 0e       	add	r14, r24
    2450:	f1 1c       	adc	r15, r1
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2452:	8c 2c       	mov	r8, r12
    2454:	9d 2c       	mov	r9, r13
    2456:	b6 01       	movw	r22, r12
    2458:	ce 01       	movw	r24, r28
    245a:	82 d1       	rcall	.+772    	; 0x2760 <_ZN8emstreamlsEj>
    245c:	6b e0       	ldi	r22, 0x0B	; 11
    245e:	3c d1       	rcall	.+632    	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2460:	60 e3       	ldi	r22, 0x30	; 48
    2462:	72 e0       	ldi	r23, 0x02	; 2
    2464:	02 d1       	rcall	.+516    	; 0x266a <_ZN8emstream4putsEPKc>
    2466:	86 01       	movw	r16, r12

		// Show a line full of data in hexadecimal format
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			*p_ser_dev << (uint8_t)(*start_address++);
    2468:	f8 01       	movw	r30, r16
    246a:	61 91       	ld	r22, Z+
    246c:	8f 01       	movw	r16, r30
    246e:	ce 01       	movw	r24, r28
    2470:	ef d1       	rcall	.+990    	; 0x2850 <_ZN8emstreamlsEh>
			p_ser_dev->putchar (' ');
    2472:	e8 81       	ld	r30, Y
    2474:	f9 81       	ldd	r31, Y+1	; 0x01
    2476:	02 80       	ldd	r0, Z+2	; 0x02
    2478:	f3 81       	ldd	r31, Z+3	; 0x03
    247a:	e0 2d       	mov	r30, r0
    247c:	60 e2       	ldi	r22, 0x20	; 32
    247e:	ce 01       	movw	r24, r28
    2480:	09 95       	icall
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");

		// Show a line full of data in hexadecimal format
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2482:	e0 16       	cp	r14, r16
    2484:	f1 06       	cpc	r15, r17
    2486:	81 f7       	brne	.-32     	; 0x2468 <_Z15hex_dump_memoryPhS_P8emstream+0x4a>
			*p_ser_dev << (uint8_t)(*start_address++);
			p_ser_dev->putchar (' ');
		}

		// Show the same line full of data in text format
		p_ser_dev->putchar (' ');
    2488:	e8 81       	ld	r30, Y
    248a:	f9 81       	ldd	r31, Y+1	; 0x01
    248c:	02 80       	ldd	r0, Z+2	; 0x02
    248e:	f3 81       	ldd	r31, Z+3	; 0x03
    2490:	e0 2d       	mov	r30, r0
    2492:	60 e2       	ldi	r22, 0x20	; 32
    2494:	ce 01       	movw	r24, r28
    2496:	09 95       	icall
    2498:	08 2d       	mov	r16, r8
    249a:	19 2d       	mov	r17, r9
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    249c:	f8 01       	movw	r30, r16
    249e:	61 91       	ld	r22, Z+
    24a0:	8f 01       	movw	r16, r30
			if (temp_byte == 0xA5)
    24a2:	65 3a       	cpi	r22, 0xA5	; 165
    24a4:	49 f4       	brne	.+18     	; 0x24b8 <_Z15hex_dump_memoryPhS_P8emstream+0x9a>
			{
				p_ser_dev->putchar (' ');
    24a6:	e8 81       	ld	r30, Y
    24a8:	f9 81       	ldd	r31, Y+1	; 0x01
    24aa:	02 80       	ldd	r0, Z+2	; 0x02
    24ac:	f3 81       	ldd	r31, Z+3	; 0x03
    24ae:	e0 2d       	mov	r30, r0
    24b0:	60 e2       	ldi	r22, 0x20	; 32
    24b2:	ce 01       	movw	r24, r28
    24b4:	09 95       	icall
    24b6:	14 c0       	rjmp	.+40     	; 0x24e0 <_Z15hex_dump_memoryPhS_P8emstream+0xc2>
			}
			else if (temp_byte >= ' ' && temp_byte <= '~')
    24b8:	80 ee       	ldi	r24, 0xE0	; 224
    24ba:	86 0f       	add	r24, r22
    24bc:	8f 35       	cpi	r24, 0x5F	; 95
    24be:	40 f4       	brcc	.+16     	; 0x24d0 <_Z15hex_dump_memoryPhS_P8emstream+0xb2>
			{
				p_ser_dev->putchar (temp_byte);
    24c0:	e8 81       	ld	r30, Y
    24c2:	f9 81       	ldd	r31, Y+1	; 0x01
    24c4:	02 80       	ldd	r0, Z+2	; 0x02
    24c6:	f3 81       	ldd	r31, Z+3	; 0x03
    24c8:	e0 2d       	mov	r30, r0
    24ca:	ce 01       	movw	r24, r28
    24cc:	09 95       	icall
    24ce:	08 c0       	rjmp	.+16     	; 0x24e0 <_Z15hex_dump_memoryPhS_P8emstream+0xc2>
			}
			else
			{
				p_ser_dev->putchar ('.');
    24d0:	e8 81       	ld	r30, Y
    24d2:	f9 81       	ldd	r31, Y+1	; 0x01
    24d4:	02 80       	ldd	r0, Z+2	; 0x02
    24d6:	f3 81       	ldd	r31, Z+3	; 0x03
    24d8:	e0 2d       	mov	r30, r0
    24da:	6e e2       	ldi	r22, 0x2E	; 46
    24dc:	ce 01       	movw	r24, r28
    24de:	09 95       	icall
			p_ser_dev->putchar (' ');
		}

		// Show the same line full of data in text format
		p_ser_dev->putchar (' ');
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    24e0:	e0 16       	cp	r14, r16
    24e2:	f1 06       	cpc	r15, r17
    24e4:	d9 f6       	brne	.-74     	; 0x249c <_Z15hex_dump_memoryPhS_P8emstream+0x7e>
    24e6:	f4 e1       	ldi	r31, 0x14	; 20
    24e8:	cf 0e       	add	r12, r31
    24ea:	d1 1c       	adc	r13, r1
				p_ser_dev->putchar ('.');
			}
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    24ec:	66 e0       	ldi	r22, 0x06	; 6
    24ee:	ce 01       	movw	r24, r28
    24f0:	f3 d0       	rcall	.+486    	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    24f2:	84 e1       	ldi	r24, 0x14	; 20
    24f4:	e8 0e       	add	r14, r24
    24f6:	f1 1c       	adc	r15, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    24f8:	ca 14       	cp	r12, r10
    24fa:	db 04       	cpc	r13, r11
    24fc:	08 f4       	brcc	.+2      	; 0x2500 <_Z15hex_dump_memoryPhS_P8emstream+0xe2>
    24fe:	a9 cf       	rjmp	.-174    	; 0x2452 <_Z15hex_dump_memoryPhS_P8emstream+0x34>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2500:	62 e0       	ldi	r22, 0x02	; 2
    2502:	ce 01       	movw	r24, r28
    2504:	e9 d0       	rcall	.+466    	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
}
    2506:	df 91       	pop	r29
    2508:	cf 91       	pop	r28
    250a:	1f 91       	pop	r17
    250c:	0f 91       	pop	r16
    250e:	ff 90       	pop	r15
    2510:	ef 90       	pop	r14
    2512:	df 90       	pop	r13
    2514:	cf 90       	pop	r12
    2516:	bf 90       	pop	r11
    2518:	af 90       	pop	r10
    251a:	9f 90       	pop	r9
    251c:	8f 90       	pop	r8
    251e:	08 95       	ret

00002520 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2520:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <pvPortMalloc>
    2524:	08 95       	ret

00002526 <_Znaj>:
    2526:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <pvPortMalloc>
    252a:	08 95       	ret

0000252c <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    252c:	08 95       	ret

0000252e <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    252e:	0f 93       	push	r16
    2530:	1f 93       	push	r17
    2532:	cf 93       	push	r28
    2534:	df 93       	push	r29
    2536:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    2538:	41 11       	cpse	r20, r1
    253a:	3a c0       	rjmp	.+116    	; 0x25b0 <_ZN7base232C1Ejh+0x82>
		{
			p_UDR = &UDR0;
    253c:	86 ec       	ldi	r24, 0xC6	; 198
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	99 83       	std	Y+1, r25	; 0x01
    2542:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    2544:	00 ec       	ldi	r16, 0xC0	; 192
    2546:	10 e0       	ldi	r17, 0x00	; 0
    2548:	1b 83       	std	Y+3, r17	; 0x03
    254a:	0a 83       	std	Y+2, r16	; 0x02
			p_UCR = &UCSR0B;
    254c:	e1 ec       	ldi	r30, 0xC1	; 193
    254e:	f0 e0       	ldi	r31, 0x00	; 0
    2550:	fd 83       	std	Y+5, r31	; 0x05
    2552:	ec 83       	std	Y+4, r30	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    2554:	88 e1       	ldi	r24, 0x18	; 24
    2556:	80 83       	st	Z, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    2558:	86 e0       	ldi	r24, 0x06	; 6
    255a:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    255e:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    2562:	cb 01       	movw	r24, r22
    2564:	a0 e0       	ldi	r26, 0x00	; 0
    2566:	b0 e0       	ldi	r27, 0x00	; 0
    2568:	88 0f       	add	r24, r24
    256a:	99 1f       	adc	r25, r25
    256c:	aa 1f       	adc	r26, r26
    256e:	bb 1f       	adc	r27, r27
    2570:	88 0f       	add	r24, r24
    2572:	99 1f       	adc	r25, r25
    2574:	aa 1f       	adc	r26, r26
    2576:	bb 1f       	adc	r27, r27
    2578:	9c 01       	movw	r18, r24
    257a:	ad 01       	movw	r20, r26
    257c:	22 0f       	add	r18, r18
    257e:	33 1f       	adc	r19, r19
    2580:	44 1f       	adc	r20, r20
    2582:	55 1f       	adc	r21, r21
    2584:	22 0f       	add	r18, r18
    2586:	33 1f       	adc	r19, r19
    2588:	44 1f       	adc	r20, r20
    258a:	55 1f       	adc	r21, r21
    258c:	60 e0       	ldi	r22, 0x00	; 0
    258e:	74 e2       	ldi	r23, 0x24	; 36
    2590:	84 ef       	ldi	r24, 0xF4	; 244
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	d2 d6       	rcall	.+3492   	; 0x333a <__udivmodsi4>
    2596:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    259a:	f8 01       	movw	r30, r16
    259c:	80 81       	ld	r24, Z
    259e:	81 60       	ori	r24, 0x01	; 1
    25a0:	80 83       	st	Z, r24
			#endif
			mask_UDRE = (1 << UDRE0);
    25a2:	80 e2       	ldi	r24, 0x20	; 32
    25a4:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC0);
    25a6:	80 e8       	ldi	r24, 0x80	; 128
    25a8:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC0);
    25aa:	80 e4       	ldi	r24, 0x40	; 64
    25ac:	88 87       	std	Y+8, r24	; 0x08
    25ae:	39 c0       	rjmp	.+114    	; 0x2622 <_ZN7base232C1Ejh+0xf4>
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    25b0:	8e ec       	ldi	r24, 0xCE	; 206
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	99 83       	std	Y+1, r25	; 0x01
    25b6:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    25b8:	08 ec       	ldi	r16, 0xC8	; 200
    25ba:	10 e0       	ldi	r17, 0x00	; 0
    25bc:	1b 83       	std	Y+3, r17	; 0x03
    25be:	0a 83       	std	Y+2, r16	; 0x02
			p_UCR = &UCSR1B;
    25c0:	e9 ec       	ldi	r30, 0xC9	; 201
    25c2:	f0 e0       	ldi	r31, 0x00	; 0
    25c4:	fd 83       	std	Y+5, r31	; 0x05
    25c6:	ec 83       	std	Y+4, r30	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    25c8:	88 e1       	ldi	r24, 0x18	; 24
    25ca:	80 83       	st	Z, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    25cc:	86 e0       	ldi	r24, 0x06	; 6
    25ce:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    25d2:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    25d6:	cb 01       	movw	r24, r22
    25d8:	a0 e0       	ldi	r26, 0x00	; 0
    25da:	b0 e0       	ldi	r27, 0x00	; 0
    25dc:	88 0f       	add	r24, r24
    25de:	99 1f       	adc	r25, r25
    25e0:	aa 1f       	adc	r26, r26
    25e2:	bb 1f       	adc	r27, r27
    25e4:	88 0f       	add	r24, r24
    25e6:	99 1f       	adc	r25, r25
    25e8:	aa 1f       	adc	r26, r26
    25ea:	bb 1f       	adc	r27, r27
    25ec:	9c 01       	movw	r18, r24
    25ee:	ad 01       	movw	r20, r26
    25f0:	22 0f       	add	r18, r18
    25f2:	33 1f       	adc	r19, r19
    25f4:	44 1f       	adc	r20, r20
    25f6:	55 1f       	adc	r21, r21
    25f8:	22 0f       	add	r18, r18
    25fa:	33 1f       	adc	r19, r19
    25fc:	44 1f       	adc	r20, r20
    25fe:	55 1f       	adc	r21, r21
    2600:	60 e0       	ldi	r22, 0x00	; 0
    2602:	74 e2       	ldi	r23, 0x24	; 36
    2604:	84 ef       	ldi	r24, 0xF4	; 244
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	98 d6       	rcall	.+3376   	; 0x333a <__udivmodsi4>
    260a:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    260e:	f8 01       	movw	r30, r16
    2610:	80 81       	ld	r24, Z
    2612:	81 60       	ori	r24, 0x01	; 1
    2614:	80 83       	st	Z, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    2616:	80 e2       	ldi	r24, 0x20	; 32
    2618:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    261a:	80 e8       	ldi	r24, 0x80	; 128
    261c:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    261e:	80 e4       	ldi	r24, 0x40	; 64
    2620:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    2622:	e8 81       	ld	r30, Y
    2624:	f9 81       	ldd	r31, Y+1	; 0x01
    2626:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    2628:	80 81       	ld	r24, Z
}
    262a:	df 91       	pop	r29
    262c:	cf 91       	pop	r28
    262e:	1f 91       	pop	r17
    2630:	0f 91       	pop	r16
    2632:	08 95       	ret

00002634 <_ZN8emstream13ready_to_sendEv>:
		bts_new_base = new_base;
		return (manip_set_base);
	}

	return (manip_set_base);
}
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	08 95       	ret

00002638 <_ZN8emstream7getcharEv>:
    2638:	80 e0       	ldi	r24, 0x00	; 0
    263a:	08 95       	ret

0000263c <_ZN8emstream14check_for_charEv>:
    263c:	80 e0       	ldi	r24, 0x00	; 0
    263e:	08 95       	ret

00002640 <_ZN8emstream12transmit_nowEv>:
    2640:	08 95       	ret

00002642 <_ZN8emstream12clear_screenEv>:
    2642:	dc 01       	movw	r26, r24
    2644:	ed 91       	ld	r30, X+
    2646:	fc 91       	ld	r31, X
    2648:	02 80       	ldd	r0, Z+2	; 0x02
    264a:	f3 81       	ldd	r31, Z+3	; 0x03
    264c:	e0 2d       	mov	r30, r0
    264e:	6c e0       	ldi	r22, 0x0C	; 12
    2650:	09 95       	icall
    2652:	08 95       	ret

00002654 <_ZN8emstreamC1Ev>:
    2654:	fc 01       	movw	r30, r24
    2656:	8e e3       	ldi	r24, 0x3E	; 62
    2658:	92 e0       	ldi	r25, 0x02	; 2
    265a:	91 83       	std	Z+1, r25	; 0x01
    265c:	80 83       	st	Z, r24
    265e:	8a e0       	ldi	r24, 0x0A	; 10
    2660:	82 83       	std	Z+2, r24	; 0x02
    2662:	83 e0       	ldi	r24, 0x03	; 3
    2664:	85 83       	std	Z+5, r24	; 0x05
    2666:	14 82       	std	Z+4, r1	; 0x04
    2668:	08 95       	ret

0000266a <_ZN8emstream4putsEPKc>:
    266a:	0f 93       	push	r16
    266c:	1f 93       	push	r17
    266e:	cf 93       	push	r28
    2670:	df 93       	push	r29
    2672:	8c 01       	movw	r16, r24
    2674:	fb 01       	movw	r30, r22
    2676:	dc 01       	movw	r26, r24
    2678:	14 96       	adiw	r26, 0x04	; 4
    267a:	8c 91       	ld	r24, X
    267c:	81 11       	cpse	r24, r1
    267e:	04 c0       	rjmp	.+8      	; 0x2688 <_ZN8emstream4putsEPKc+0x1e>
    2680:	60 81       	ld	r22, Z
    2682:	61 11       	cpse	r22, r1
    2684:	17 c0       	rjmp	.+46     	; 0x26b4 <_ZN8emstream4putsEPKc+0x4a>
    2686:	23 c0       	rjmp	.+70     	; 0x26ce <_ZN8emstream4putsEPKc+0x64>
    2688:	d8 01       	movw	r26, r16
    268a:	14 96       	adiw	r26, 0x04	; 4
    268c:	1c 92       	st	X, r1
    268e:	eb 01       	movw	r28, r22
    2690:	21 96       	adiw	r28, 0x01	; 1
    2692:	64 91       	lpm	r22, Z
    2694:	66 23       	and	r22, r22
    2696:	d9 f0       	breq	.+54     	; 0x26ce <_ZN8emstream4putsEPKc+0x64>
    2698:	d8 01       	movw	r26, r16
    269a:	ed 91       	ld	r30, X+
    269c:	fc 91       	ld	r31, X
    269e:	02 80       	ldd	r0, Z+2	; 0x02
    26a0:	f3 81       	ldd	r31, Z+3	; 0x03
    26a2:	e0 2d       	mov	r30, r0
    26a4:	c8 01       	movw	r24, r16
    26a6:	09 95       	icall
    26a8:	fe 01       	movw	r30, r28
    26aa:	64 91       	lpm	r22, Z
    26ac:	21 96       	adiw	r28, 0x01	; 1
    26ae:	61 11       	cpse	r22, r1
    26b0:	f3 cf       	rjmp	.-26     	; 0x2698 <_ZN8emstream4putsEPKc+0x2e>
    26b2:	0d c0       	rjmp	.+26     	; 0x26ce <_ZN8emstream4putsEPKc+0x64>
    26b4:	ef 01       	movw	r28, r30
    26b6:	21 96       	adiw	r28, 0x01	; 1
    26b8:	d8 01       	movw	r26, r16
    26ba:	ed 91       	ld	r30, X+
    26bc:	fc 91       	ld	r31, X
    26be:	02 80       	ldd	r0, Z+2	; 0x02
    26c0:	f3 81       	ldd	r31, Z+3	; 0x03
    26c2:	e0 2d       	mov	r30, r0
    26c4:	c8 01       	movw	r24, r16
    26c6:	09 95       	icall
    26c8:	69 91       	ld	r22, Y+
    26ca:	61 11       	cpse	r22, r1
    26cc:	f5 cf       	rjmp	.-22     	; 0x26b8 <_ZN8emstream4putsEPKc+0x4e>
    26ce:	df 91       	pop	r29
    26d0:	cf 91       	pop	r28
    26d2:	1f 91       	pop	r17
    26d4:	0f 91       	pop	r16
    26d6:	08 95       	ret

000026d8 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return  A reference to the serial device to which the data was printed. This
 *           reference is used to string printable items together with @c << operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    26d8:	cf 93       	push	r28
    26da:	df 93       	push	r29
    26dc:	ec 01       	movw	r28, r24
	switch (new_manip)
    26de:	46 2f       	mov	r20, r22
    26e0:	50 e0       	ldi	r21, 0x00	; 0
    26e2:	4c 30       	cpi	r20, 0x0C	; 12
    26e4:	51 05       	cpc	r21, r1
    26e6:	c0 f5       	brcc	.+112    	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
    26e8:	fa 01       	movw	r30, r20
    26ea:	ea 59       	subi	r30, 0x9A	; 154
    26ec:	ff 4f       	sbci	r31, 0xFF	; 255
    26ee:	63 c6       	rjmp	.+3270   	; 0x33b6 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    26f0:	82 e0       	ldi	r24, 0x02	; 2
    26f2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    26f4:	31 c0       	rjmp	.+98     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (oct):                         // Print integers in octal
			base = 8;
    26f6:	88 e0       	ldi	r24, 0x08	; 8
    26f8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    26fa:	2e c0       	rjmp	.+92     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (dec):                         // Print integers in decimal
			base = 10;
    26fc:	8a e0       	ldi	r24, 0x0A	; 10
    26fe:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2700:	2b c0       	rjmp	.+86     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2702:	80 e1       	ldi	r24, 0x10	; 16
    2704:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2706:	28 c0       	rjmp	.+80     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2708:	e8 81       	ld	r30, Y
    270a:	f9 81       	ldd	r31, Y+1	; 0x01
    270c:	02 80       	ldd	r0, Z+2	; 0x02
    270e:	f3 81       	ldd	r31, Z+3	; 0x03
    2710:	e0 2d       	mov	r30, r0
    2712:	6d e0       	ldi	r22, 0x0D	; 13
    2714:	09 95       	icall
    2716:	e8 81       	ld	r30, Y
    2718:	f9 81       	ldd	r31, Y+1	; 0x01
    271a:	02 80       	ldd	r0, Z+2	; 0x02
    271c:	f3 81       	ldd	r31, Z+3	; 0x03
    271e:	e0 2d       	mov	r30, r0
    2720:	6a e0       	ldi	r22, 0x0A	; 10
    2722:	ce 01       	movw	r24, r28
    2724:	09 95       	icall
			break;
    2726:	18 c0       	rjmp	.+48     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2728:	e8 81       	ld	r30, Y
    272a:	f9 81       	ldd	r31, Y+1	; 0x01
    272c:	02 84       	ldd	r0, Z+10	; 0x0a
    272e:	f3 85       	ldd	r31, Z+11	; 0x0b
    2730:	e0 2d       	mov	r30, r0
    2732:	09 95       	icall
			break;
    2734:	11 c0       	rjmp	.+34     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2736:	e8 81       	ld	r30, Y
    2738:	f9 81       	ldd	r31, Y+1	; 0x01
    273a:	00 84       	ldd	r0, Z+8	; 0x08
    273c:	f1 85       	ldd	r31, Z+9	; 0x09
    273e:	e0 2d       	mov	r30, r0
    2740:	09 95       	icall
			break;
    2742:	0a c0       	rjmp	.+20     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		#ifdef __AVR
			case (_p_str):                  // The next string is in program memory
				pgm_string = true;
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	8c 83       	std	Y+4, r24	; 0x04
				break;
    2748:	07 c0       	rjmp	.+14     	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		#endif
		case (manip_set_precision):         // Set precision for printing floats
			precision = bts_new_prec;
    274a:	80 91 07 02 	lds	r24, 0x0207
    274e:	8d 83       	std	Y+5, r24	; 0x05
			break;
    2750:	03 c0       	rjmp	.+6      	; 0x2758 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (manip_set_base):              // Set numeric base to a number 2 to 16
			base = bts_new_base;
    2752:	80 91 06 02 	lds	r24, 0x0206
    2756:	8a 83       	std	Y+2, r24	; 0x02
		default:                            // Not recognized?  Do nothing then
			break;
	};

	return (*this);
}
    2758:	ce 01       	movw	r24, r28
    275a:	df 91       	pop	r29
    275c:	cf 91       	pop	r28
    275e:	08 95       	ret

00002760 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2760:	ff 92       	push	r15
    2762:	0f 93       	push	r16
    2764:	1f 93       	push	r17
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	cd b7       	in	r28, 0x3d	; 61
    276c:	de b7       	in	r29, 0x3e	; 62
    276e:	61 97       	sbiw	r28, 0x11	; 17
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	f8 94       	cli
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	0f be       	out	0x3f, r0	; 63
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	8c 01       	movw	r16, r24
    277c:	f6 2e       	mov	r15, r22
    277e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2780:	f8 01       	movw	r30, r16
    2782:	42 81       	ldd	r20, Z+2	; 0x02
    2784:	40 31       	cpi	r20, 0x10	; 16
    2786:	21 f0       	breq	.+8      	; 0x2790 <_ZN8emstreamlsEj+0x30>
    2788:	48 30       	cpi	r20, 0x08	; 8
    278a:	11 f0       	breq	.+4      	; 0x2790 <_ZN8emstreamlsEj+0x30>
    278c:	42 30       	cpi	r20, 0x02	; 2
    278e:	31 f4       	brne	.+12     	; 0x279c <_ZN8emstreamlsEj+0x3c>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    2790:	69 2f       	mov	r22, r25
    2792:	c8 01       	movw	r24, r16
    2794:	5d d0       	rcall	.+186    	; 0x2850 <_ZN8emstreamlsEh>
    2796:	6f 2d       	mov	r22, r15
    2798:	5b d0       	rcall	.+182    	; 0x2850 <_ZN8emstreamlsEh>
    279a:	0b c0       	rjmp	.+22     	; 0x27b2 <_ZN8emstreamlsEj+0x52>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
    279c:	50 e0       	ldi	r21, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    279e:	be 01       	movw	r22, r28
    27a0:	6f 5f       	subi	r22, 0xFF	; 255
    27a2:	7f 4f       	sbci	r23, 0xFF	; 255
    27a4:	8f 2d       	mov	r24, r15
    27a6:	73 d6       	rcall	.+3302   	; 0x348e <utoa>
		puts (out_str);
    27a8:	be 01       	movw	r22, r28
    27aa:	6f 5f       	subi	r22, 0xFF	; 255
    27ac:	7f 4f       	sbci	r23, 0xFF	; 255
    27ae:	c8 01       	movw	r24, r16
    27b0:	5c df       	rcall	.-328    	; 0x266a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    27b2:	c8 01       	movw	r24, r16
    27b4:	61 96       	adiw	r28, 0x11	; 17
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	1f 91       	pop	r17
    27c6:	0f 91       	pop	r16
    27c8:	ff 90       	pop	r15
    27ca:	08 95       	ret

000027cc <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    27cc:	df 92       	push	r13
    27ce:	ef 92       	push	r14
    27d0:	ff 92       	push	r15
    27d2:	0f 93       	push	r16
    27d4:	1f 93       	push	r17
    27d6:	cf 93       	push	r28
    27d8:	df 93       	push	r29
    27da:	cd b7       	in	r28, 0x3d	; 61
    27dc:	de b7       	in	r29, 0x3e	; 62
    27de:	a1 97       	sbiw	r28, 0x21	; 33
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	cd bf       	out	0x3d, r28	; 61
    27ea:	8c 01       	movw	r16, r24
    27ec:	d4 2e       	mov	r13, r20
    27ee:	e5 2e       	mov	r14, r21
    27f0:	f6 2e       	mov	r15, r22
    27f2:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    27f4:	f8 01       	movw	r30, r16
    27f6:	22 81       	ldd	r18, Z+2	; 0x02
    27f8:	20 31       	cpi	r18, 0x10	; 16
    27fa:	21 f0       	breq	.+8      	; 0x2804 <_ZN8emstreamlsEm+0x38>
    27fc:	28 30       	cpi	r18, 0x08	; 8
    27fe:	11 f0       	breq	.+4      	; 0x2804 <_ZN8emstreamlsEm+0x38>
    2800:	22 30       	cpi	r18, 0x02	; 2
    2802:	51 f4       	brne	.+20     	; 0x2818 <_ZN8emstreamlsEm+0x4c>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    2804:	69 2f       	mov	r22, r25
    2806:	c8 01       	movw	r24, r16
    2808:	23 d0       	rcall	.+70     	; 0x2850 <_ZN8emstreamlsEh>
    280a:	6f 2d       	mov	r22, r15
    280c:	21 d0       	rcall	.+66     	; 0x2850 <_ZN8emstreamlsEh>
    280e:	6e 2d       	mov	r22, r14
    2810:	1f d0       	rcall	.+62     	; 0x2850 <_ZN8emstreamlsEh>
    2812:	6d 2d       	mov	r22, r13
    2814:	1d d0       	rcall	.+58     	; 0x2850 <_ZN8emstreamlsEh>
    2816:	0d c0       	rjmp	.+26     	; 0x2832 <_ZN8emstreamlsEm+0x66>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
    2818:	30 e0       	ldi	r19, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    281a:	ae 01       	movw	r20, r28
    281c:	4f 5f       	subi	r20, 0xFF	; 255
    281e:	5f 4f       	sbci	r21, 0xFF	; 255
    2820:	6d 2d       	mov	r22, r13
    2822:	7e 2d       	mov	r23, r14
    2824:	8f 2d       	mov	r24, r15
    2826:	08 d6       	rcall	.+3088   	; 0x3438 <ultoa>
		puts (out_str);
    2828:	be 01       	movw	r22, r28
    282a:	6f 5f       	subi	r22, 0xFF	; 255
    282c:	7f 4f       	sbci	r23, 0xFF	; 255
    282e:	c8 01       	movw	r24, r16
    2830:	1c df       	rcall	.-456    	; 0x266a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2832:	c8 01       	movw	r24, r16
    2834:	a1 96       	adiw	r28, 0x21	; 33
    2836:	0f b6       	in	r0, 0x3f	; 63
    2838:	f8 94       	cli
    283a:	de bf       	out	0x3e, r29	; 62
    283c:	0f be       	out	0x3f, r0	; 63
    283e:	cd bf       	out	0x3d, r28	; 61
    2840:	df 91       	pop	r29
    2842:	cf 91       	pop	r28
    2844:	1f 91       	pop	r17
    2846:	0f 91       	pop	r16
    2848:	ff 90       	pop	r15
    284a:	ef 90       	pop	r14
    284c:	df 90       	pop	r13
    284e:	08 95       	ret

00002850 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    2850:	cf 92       	push	r12
    2852:	df 92       	push	r13
    2854:	ef 92       	push	r14
    2856:	ff 92       	push	r15
    2858:	0f 93       	push	r16
    285a:	1f 93       	push	r17
    285c:	cf 93       	push	r28
    285e:	df 93       	push	r29
    2860:	cd b7       	in	r28, 0x3d	; 61
    2862:	de b7       	in	r29, 0x3e	; 62
    2864:	29 97       	sbiw	r28, 0x09	; 9
    2866:	0f b6       	in	r0, 0x3f	; 63
    2868:	f8 94       	cli
    286a:	de bf       	out	0x3e, r29	; 62
    286c:	0f be       	out	0x3f, r0	; 63
    286e:	cd bf       	out	0x3d, r28	; 61
    2870:	8c 01       	movw	r16, r24
    2872:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    2874:	dc 01       	movw	r26, r24
    2876:	13 96       	adiw	r26, 0x03	; 3
    2878:	8c 91       	ld	r24, X
    287a:	13 97       	sbiw	r26, 0x03	; 3
    287c:	88 23       	and	r24, r24
    287e:	41 f0       	breq	.+16     	; 0x2890 <_ZN8emstreamlsEh+0x40>
	{
		putchar (num);
    2880:	ed 91       	ld	r30, X+
    2882:	fc 91       	ld	r31, X
    2884:	02 80       	ldd	r0, Z+2	; 0x02
    2886:	f3 81       	ldd	r31, Z+3	; 0x03
    2888:	e0 2d       	mov	r30, r0
    288a:	c8 01       	movw	r24, r16
    288c:	09 95       	icall
    288e:	54 c0       	rjmp	.+168    	; 0x2938 <_ZN8emstreamlsEh+0xe8>
	}
	else if (base == 2)
    2890:	f8 01       	movw	r30, r16
    2892:	42 81       	ldd	r20, Z+2	; 0x02
    2894:	42 30       	cpi	r20, 0x02	; 2
    2896:	19 f5       	brne	.+70     	; 0x28de <_ZN8emstreamlsEh+0x8e>
    2898:	68 94       	set
    289a:	cc 24       	eor	r12, r12
    289c:	c3 f8       	bld	r12, 3
    289e:	d1 2c       	mov	r13, r1
    28a0:	68 94       	set
    28a2:	ff 24       	eor	r15, r15
    28a4:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    28a6:	8f 2d       	mov	r24, r15
    28a8:	8e 21       	and	r24, r14
    28aa:	51 f0       	breq	.+20     	; 0x28c0 <_ZN8emstreamlsEh+0x70>
    28ac:	d8 01       	movw	r26, r16
    28ae:	ed 91       	ld	r30, X+
    28b0:	fc 91       	ld	r31, X
    28b2:	02 80       	ldd	r0, Z+2	; 0x02
    28b4:	f3 81       	ldd	r31, Z+3	; 0x03
    28b6:	e0 2d       	mov	r30, r0
    28b8:	61 e3       	ldi	r22, 0x31	; 49
    28ba:	c8 01       	movw	r24, r16
    28bc:	09 95       	icall
    28be:	09 c0       	rjmp	.+18     	; 0x28d2 <_ZN8emstreamlsEh+0x82>
			else             putchar ('0');
    28c0:	d8 01       	movw	r26, r16
    28c2:	ed 91       	ld	r30, X+
    28c4:	fc 91       	ld	r31, X
    28c6:	02 80       	ldd	r0, Z+2	; 0x02
    28c8:	f3 81       	ldd	r31, Z+3	; 0x03
    28ca:	e0 2d       	mov	r30, r0
    28cc:	60 e3       	ldi	r22, 0x30	; 48
    28ce:	c8 01       	movw	r24, r16
    28d0:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    28d2:	f6 94       	lsr	r15
    28d4:	b1 e0       	ldi	r27, 0x01	; 1
    28d6:	cb 1a       	sub	r12, r27
    28d8:	d1 08       	sbc	r13, r1
    28da:	29 f7       	brne	.-54     	; 0x28a6 <_ZN8emstreamlsEh+0x56>
    28dc:	2d c0       	rjmp	.+90     	; 0x2938 <_ZN8emstreamlsEh+0xe8>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    28de:	40 31       	cpi	r20, 0x10	; 16
    28e0:	f9 f4       	brne	.+62     	; 0x2920 <_ZN8emstreamlsEh+0xd0>
	{
		temp_char = (num >> 4) & 0x0F;
    28e2:	62 95       	swap	r22
    28e4:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    28e6:	01 90       	ld	r0, Z+
    28e8:	f0 81       	ld	r31, Z
    28ea:	e0 2d       	mov	r30, r0
    28ec:	02 80       	ldd	r0, Z+2	; 0x02
    28ee:	f3 81       	ldd	r31, Z+3	; 0x03
    28f0:	e0 2d       	mov	r30, r0
    28f2:	6a 30       	cpi	r22, 0x0A	; 10
    28f4:	10 f0       	brcs	.+4      	; 0x28fa <_ZN8emstreamlsEh+0xaa>
    28f6:	69 5c       	subi	r22, 0xC9	; 201
    28f8:	01 c0       	rjmp	.+2      	; 0x28fc <_ZN8emstreamlsEh+0xac>
    28fa:	60 5d       	subi	r22, 0xD0	; 208
    28fc:	c8 01       	movw	r24, r16
    28fe:	09 95       	icall
		temp_char = num & 0x0F;
    2900:	6e 2d       	mov	r22, r14
    2902:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2904:	d8 01       	movw	r26, r16
    2906:	ed 91       	ld	r30, X+
    2908:	fc 91       	ld	r31, X
    290a:	02 80       	ldd	r0, Z+2	; 0x02
    290c:	f3 81       	ldd	r31, Z+3	; 0x03
    290e:	e0 2d       	mov	r30, r0
    2910:	6a 30       	cpi	r22, 0x0A	; 10
    2912:	10 f0       	brcs	.+4      	; 0x2918 <_ZN8emstreamlsEh+0xc8>
    2914:	69 5c       	subi	r22, 0xC9	; 201
    2916:	01 c0       	rjmp	.+2      	; 0x291a <_ZN8emstreamlsEh+0xca>
    2918:	60 5d       	subi	r22, 0xD0	; 208
    291a:	c8 01       	movw	r24, r16
    291c:	09 95       	icall
    291e:	0c c0       	rjmp	.+24     	; 0x2938 <_ZN8emstreamlsEh+0xe8>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
    2920:	50 e0       	ldi	r21, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2922:	be 01       	movw	r22, r28
    2924:	6f 5f       	subi	r22, 0xFF	; 255
    2926:	7f 4f       	sbci	r23, 0xFF	; 255
    2928:	8e 2d       	mov	r24, r14
    292a:	90 e0       	ldi	r25, 0x00	; 0
    292c:	b0 d5       	rcall	.+2912   	; 0x348e <utoa>
		puts (out_str);
    292e:	be 01       	movw	r22, r28
    2930:	6f 5f       	subi	r22, 0xFF	; 255
    2932:	7f 4f       	sbci	r23, 0xFF	; 255
    2934:	c8 01       	movw	r24, r16
    2936:	99 de       	rcall	.-718    	; 0x266a <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    2938:	c8 01       	movw	r24, r16
    293a:	29 96       	adiw	r28, 0x09	; 9
    293c:	0f b6       	in	r0, 0x3f	; 63
    293e:	f8 94       	cli
    2940:	de bf       	out	0x3e, r29	; 62
    2942:	0f be       	out	0x3f, r0	; 63
    2944:	cd bf       	out	0x3d, r28	; 61
    2946:	df 91       	pop	r29
    2948:	cf 91       	pop	r28
    294a:	1f 91       	pop	r17
    294c:	0f 91       	pop	r16
    294e:	ff 90       	pop	r15
    2950:	ef 90       	pop	r14
    2952:	df 90       	pop	r13
    2954:	cf 90       	pop	r12
    2956:	08 95       	ret

00002958 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

void rs232::putchar (char chout)
{
    2958:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    295a:	18 96       	adiw	r26, 0x08	; 8
    295c:	ed 91       	ld	r30, X+
    295e:	fc 91       	ld	r31, X
    2960:	19 97       	sbiw	r26, 0x09	; 9
    2962:	80 81       	ld	r24, Z
    2964:	1c 96       	adiw	r26, 0x0c	; 12
    2966:	4c 91       	ld	r20, X
    2968:	1c 97       	sbiw	r26, 0x0c	; 12
    296a:	84 23       	and	r24, r20
    296c:	29 f0       	breq	.+10     	; 0x2978 <_ZN5rs2327putcharEc+0x20>
    296e:	09 c0       	rjmp	.+18     	; 0x2982 <_ZN5rs2327putcharEc+0x2a>
    2970:	21 50       	subi	r18, 0x01	; 1
    2972:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    2974:	19 f4       	brne	.+6      	; 0x297c <_ZN5rs2327putcharEc+0x24>
    2976:	08 95       	ret
 */

void rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    2978:	21 e2       	ldi	r18, 0x21	; 33
    297a:	3e e4       	ldi	r19, 0x4E	; 78
    297c:	90 81       	ld	r25, Z
    297e:	94 23       	and	r25, r20
    2980:	b9 f3       	breq	.-18     	; 0x2970 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    2982:	90 81       	ld	r25, Z
    2984:	1e 96       	adiw	r26, 0x0e	; 14
    2986:	8c 91       	ld	r24, X
    2988:	1e 97       	sbiw	r26, 0x0e	; 14
    298a:	89 2b       	or	r24, r25
    298c:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    298e:	16 96       	adiw	r26, 0x06	; 6
    2990:	ed 91       	ld	r30, X+
    2992:	fc 91       	ld	r31, X
    2994:	17 97       	sbiw	r26, 0x07	; 7
    2996:	60 83       	st	Z, r22
    2998:	08 95       	ret

0000299a <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
    299a:	fc 01       	movw	r30, r24
    299c:	87 85       	ldd	r24, Z+15	; 0x0f
    299e:	81 11       	cpse	r24, r1
    29a0:	21 c0       	rjmp	.+66     	; 0x29e4 <_ZN5rs2327getcharEv+0x4a>
		{
			while (rcv0_read_index == rcv0_write_index);
    29a2:	20 91 38 1a 	lds	r18, 0x1A38
    29a6:	30 91 39 1a 	lds	r19, 0x1A39
    29aa:	80 91 36 1a 	lds	r24, 0x1A36
    29ae:	90 91 37 1a 	lds	r25, 0x1A37
    29b2:	28 17       	cp	r18, r24
    29b4:	39 07       	cpc	r19, r25
    29b6:	e9 f3       	breq	.-6      	; 0x29b2 <_ZN5rs2327getcharEv+0x18>
			recv_char = rcv0_buffer[rcv0_read_index];
    29b8:	e0 91 3a 1a 	lds	r30, 0x1A3A
    29bc:	f0 91 3b 1a 	lds	r31, 0x1A3B
    29c0:	e2 0f       	add	r30, r18
    29c2:	f3 1f       	adc	r31, r19
    29c4:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
    29c6:	2f 5f       	subi	r18, 0xFF	; 255
    29c8:	3f 4f       	sbci	r19, 0xFF	; 255
    29ca:	20 32       	cpi	r18, 0x20	; 32
    29cc:	31 05       	cpc	r19, r1
    29ce:	28 f4       	brcc	.+10     	; 0x29da <_ZN5rs2327getcharEv+0x40>
    29d0:	30 93 39 1a 	sts	0x1A39, r19
    29d4:	20 93 38 1a 	sts	0x1A38, r18
    29d8:	08 95       	ret
				rcv0_read_index = 0;
    29da:	10 92 39 1a 	sts	0x1A39, r1
    29de:	10 92 38 1a 	sts	0x1A38, r1
    29e2:	08 95       	ret
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
    29e4:	20 91 32 1a 	lds	r18, 0x1A32
    29e8:	30 91 33 1a 	lds	r19, 0x1A33
    29ec:	80 91 30 1a 	lds	r24, 0x1A30
    29f0:	90 91 31 1a 	lds	r25, 0x1A31
    29f4:	28 17       	cp	r18, r24
    29f6:	39 07       	cpc	r19, r25
    29f8:	e9 f3       	breq	.-6      	; 0x29f4 <_ZN5rs2327getcharEv+0x5a>
			recv_char = rcv1_buffer[rcv1_read_index];
    29fa:	e0 91 34 1a 	lds	r30, 0x1A34
    29fe:	f0 91 35 1a 	lds	r31, 0x1A35
    2a02:	e2 0f       	add	r30, r18
    2a04:	f3 1f       	adc	r31, r19
    2a06:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2a08:	2f 5f       	subi	r18, 0xFF	; 255
    2a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a0c:	20 32       	cpi	r18, 0x20	; 32
    2a0e:	31 05       	cpc	r19, r1
    2a10:	28 f4       	brcc	.+10     	; 0x2a1c <_ZN5rs2327getcharEv+0x82>
    2a12:	30 93 33 1a 	sts	0x1A33, r19
    2a16:	20 93 32 1a 	sts	0x1A32, r18
    2a1a:	08 95       	ret
				rcv1_read_index = 0;
    2a1c:	10 92 33 1a 	sts	0x1A33, r1
    2a20:	10 92 32 1a 	sts	0x1A32, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
    2a24:	08 95       	ret

00002a26 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
    2a26:	fc 01       	movw	r30, r24
    2a28:	87 85       	ldd	r24, Z+15	; 0x0f
    2a2a:	81 11       	cpse	r24, r1
    2a2c:	0e c0       	rjmp	.+28     	; 0x2a4a <_ZN5rs23214check_for_charEv+0x24>
			return (rcv0_read_index != rcv0_write_index);
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	40 91 38 1a 	lds	r20, 0x1A38
    2a34:	50 91 39 1a 	lds	r21, 0x1A39
    2a38:	20 91 36 1a 	lds	r18, 0x1A36
    2a3c:	30 91 37 1a 	lds	r19, 0x1A37
    2a40:	42 17       	cp	r20, r18
    2a42:	53 07       	cpc	r21, r19
    2a44:	79 f4       	brne	.+30     	; 0x2a64 <_ZN5rs23214check_for_charEv+0x3e>
    2a46:	80 e0       	ldi	r24, 0x00	; 0
    2a48:	08 95       	ret
		else
			return (rcv1_read_index != rcv1_write_index);
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	40 91 32 1a 	lds	r20, 0x1A32
    2a50:	50 91 33 1a 	lds	r21, 0x1A33
    2a54:	20 91 30 1a 	lds	r18, 0x1A30
    2a58:	30 91 31 1a 	lds	r19, 0x1A31
    2a5c:	42 17       	cp	r20, r18
    2a5e:	53 07       	cpc	r21, r19
    2a60:	09 f4       	brne	.+2      	; 0x2a64 <_ZN5rs23214check_for_charEv+0x3e>
    2a62:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
    2a64:	08 95       	ret

00002a66 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    2a66:	dc 01       	movw	r26, r24
    2a68:	ed 91       	ld	r30, X+
    2a6a:	fc 91       	ld	r31, X
    2a6c:	02 80       	ldd	r0, Z+2	; 0x02
    2a6e:	f3 81       	ldd	r31, Z+3	; 0x03
    2a70:	e0 2d       	mov	r30, r0
    2a72:	6c e0       	ldi	r22, 0x0C	; 12
    2a74:	09 95       	icall
    2a76:	08 95       	ret

00002a78 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
    2a78:	ef 92       	push	r14
    2a7a:	ff 92       	push	r15
    2a7c:	1f 93       	push	r17
    2a7e:	cf 93       	push	r28
    2a80:	df 93       	push	r29
    2a82:	ec 01       	movw	r28, r24
    2a84:	7b 01       	movw	r14, r22
    2a86:	14 2f       	mov	r17, r20
	: emstream (), base232 (baud_rate, port_number)
    2a88:	e5 dd       	rcall	.-1078   	; 0x2654 <_ZN8emstreamC1Ev>
    2a8a:	41 2f       	mov	r20, r17
    2a8c:	b7 01       	movw	r22, r14
    2a8e:	ce 01       	movw	r24, r28
    2a90:	06 96       	adiw	r24, 0x06	; 6
    2a92:	4d dd       	rcall	.-1382   	; 0x252e <_ZN7base232C1Ejh>
    2a94:	8e e4       	ldi	r24, 0x4E	; 78
    2a96:	92 e0       	ldi	r25, 0x02	; 2
    2a98:	99 83       	std	Y+1, r25	; 0x01
    2a9a:	88 83       	st	Y, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
    2a9c:	1f 87       	std	Y+15, r17	; 0x0f

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
    2a9e:	11 11       	cpse	r17, r1
    2aa0:	15 c0       	rjmp	.+42     	; 0x2acc <_ZN5rs232C1Ejh+0x54>
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
    2aa2:	e1 ec       	ldi	r30, 0xC1	; 193
    2aa4:	f0 e0       	ldi	r31, 0x00	; 0
    2aa6:	80 81       	ld	r24, Z
    2aa8:	80 68       	ori	r24, 0x80	; 128
    2aaa:	80 83       	st	Z, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
    2aac:	80 e2       	ldi	r24, 0x20	; 32
    2aae:	90 e0       	ldi	r25, 0x00	; 0
    2ab0:	3a dd       	rcall	.-1420   	; 0x2526 <_Znaj>
    2ab2:	90 93 3b 1a 	sts	0x1A3B, r25
    2ab6:	80 93 3a 1a 	sts	0x1A3A, r24
			rcv0_read_index = 0;
    2aba:	10 92 39 1a 	sts	0x1A39, r1
    2abe:	10 92 38 1a 	sts	0x1A38, r1
			rcv0_write_index = 0;
    2ac2:	10 92 37 1a 	sts	0x1A37, r1
    2ac6:	10 92 36 1a 	sts	0x1A36, r1
    2aca:	14 c0       	rjmp	.+40     	; 0x2af4 <_ZN5rs232C1Ejh+0x7c>
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
    2acc:	e9 ec       	ldi	r30, 0xC9	; 201
    2ace:	f0 e0       	ldi	r31, 0x00	; 0
    2ad0:	80 81       	ld	r24, Z
    2ad2:	80 68       	ori	r24, 0x80	; 128
    2ad4:	80 83       	st	Z, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
    2ad6:	80 e2       	ldi	r24, 0x20	; 32
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	25 dd       	rcall	.-1462   	; 0x2526 <_Znaj>
    2adc:	90 93 35 1a 	sts	0x1A35, r25
    2ae0:	80 93 34 1a 	sts	0x1A34, r24
			rcv1_read_index = 0;
    2ae4:	10 92 33 1a 	sts	0x1A33, r1
    2ae8:	10 92 32 1a 	sts	0x1A32, r1
			rcv1_write_index = 0;
    2aec:	10 92 31 1a 	sts	0x1A31, r1
    2af0:	10 92 30 1a 	sts	0x1A30, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	1f 91       	pop	r17
    2afa:	ff 90       	pop	r15
    2afc:	ef 90       	pop	r14
    2afe:	08 95       	ret

00002b00 <__vector_25>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
    2b00:	1f 92       	push	r1
    2b02:	0f 92       	push	r0
    2b04:	0f b6       	in	r0, 0x3f	; 63
    2b06:	0f 92       	push	r0
    2b08:	11 24       	eor	r1, r1
    2b0a:	0b b6       	in	r0, 0x3b	; 59
    2b0c:	0f 92       	push	r0
    2b0e:	2f 93       	push	r18
    2b10:	3f 93       	push	r19
    2b12:	8f 93       	push	r24
    2b14:	9f 93       	push	r25
    2b16:	ef 93       	push	r30
    2b18:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
    2b1a:	20 91 c6 00 	lds	r18, 0x00C6
    2b1e:	e0 91 3a 1a 	lds	r30, 0x1A3A
    2b22:	f0 91 3b 1a 	lds	r31, 0x1A3B
    2b26:	80 91 36 1a 	lds	r24, 0x1A36
    2b2a:	90 91 37 1a 	lds	r25, 0x1A37
    2b2e:	e8 0f       	add	r30, r24
    2b30:	f9 1f       	adc	r31, r25
    2b32:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
    2b34:	80 91 36 1a 	lds	r24, 0x1A36
    2b38:	90 91 37 1a 	lds	r25, 0x1A37
    2b3c:	01 96       	adiw	r24, 0x01	; 1
    2b3e:	80 32       	cpi	r24, 0x20	; 32
    2b40:	91 05       	cpc	r25, r1
    2b42:	60 f4       	brcc	.+24     	; 0x2b5c <__vector_25+0x5c>
    2b44:	90 93 37 1a 	sts	0x1A37, r25
    2b48:	80 93 36 1a 	sts	0x1A36, r24
		rcv0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    2b4c:	20 91 38 1a 	lds	r18, 0x1A38
    2b50:	30 91 39 1a 	lds	r19, 0x1A39
    2b54:	82 17       	cp	r24, r18
    2b56:	93 07       	cpc	r25, r19
    2b58:	f1 f4       	brne	.+60     	; 0x2b96 <__vector_25+0x96>
    2b5a:	0c c0       	rjmp	.+24     	; 0x2b74 <__vector_25+0x74>
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
		rcv0_write_index = 0;
    2b5c:	10 92 37 1a 	sts	0x1A37, r1
    2b60:	10 92 36 1a 	sts	0x1A36, r1

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    2b64:	80 91 38 1a 	lds	r24, 0x1A38
    2b68:	90 91 39 1a 	lds	r25, 0x1A39
    2b6c:	18 16       	cp	r1, r24
    2b6e:	19 06       	cpc	r1, r25
    2b70:	91 f4       	brne	.+36     	; 0x2b96 <__vector_25+0x96>
    2b72:	0e c0       	rjmp	.+28     	; 0x2b90 <__vector_25+0x90>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    2b74:	01 96       	adiw	r24, 0x01	; 1
    2b76:	80 32       	cpi	r24, 0x20	; 32
    2b78:	91 05       	cpc	r25, r1
    2b7a:	28 f4       	brcc	.+10     	; 0x2b86 <__vector_25+0x86>
    2b7c:	90 93 39 1a 	sts	0x1A39, r25
    2b80:	80 93 38 1a 	sts	0x1A38, r24
    2b84:	08 c0       	rjmp	.+16     	; 0x2b96 <__vector_25+0x96>
			rcv0_read_index = 0;
    2b86:	10 92 39 1a 	sts	0x1A39, r1
    2b8a:	10 92 38 1a 	sts	0x1A38, r1
    2b8e:	03 c0       	rjmp	.+6      	; 0x2b96 <__vector_25+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    2b90:	81 e0       	ldi	r24, 0x01	; 1
    2b92:	90 e0       	ldi	r25, 0x00	; 0
    2b94:	f3 cf       	rjmp	.-26     	; 0x2b7c <__vector_25+0x7c>
			rcv0_read_index = 0;
}
    2b96:	ff 91       	pop	r31
    2b98:	ef 91       	pop	r30
    2b9a:	9f 91       	pop	r25
    2b9c:	8f 91       	pop	r24
    2b9e:	3f 91       	pop	r19
    2ba0:	2f 91       	pop	r18
    2ba2:	0f 90       	pop	r0
    2ba4:	0b be       	out	0x3b, r0	; 59
    2ba6:	0f 90       	pop	r0
    2ba8:	0f be       	out	0x3f, r0	; 63
    2baa:	0f 90       	pop	r0
    2bac:	1f 90       	pop	r1
    2bae:	18 95       	reti

00002bb0 <__vector_36>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
    2bb0:	1f 92       	push	r1
    2bb2:	0f 92       	push	r0
    2bb4:	0f b6       	in	r0, 0x3f	; 63
    2bb6:	0f 92       	push	r0
    2bb8:	11 24       	eor	r1, r1
    2bba:	0b b6       	in	r0, 0x3b	; 59
    2bbc:	0f 92       	push	r0
    2bbe:	2f 93       	push	r18
    2bc0:	3f 93       	push	r19
    2bc2:	8f 93       	push	r24
    2bc4:	9f 93       	push	r25
    2bc6:	ef 93       	push	r30
    2bc8:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    2bca:	20 91 ce 00 	lds	r18, 0x00CE
    2bce:	e0 91 34 1a 	lds	r30, 0x1A34
    2bd2:	f0 91 35 1a 	lds	r31, 0x1A35
    2bd6:	80 91 30 1a 	lds	r24, 0x1A30
    2bda:	90 91 31 1a 	lds	r25, 0x1A31
    2bde:	e8 0f       	add	r30, r24
    2be0:	f9 1f       	adc	r31, r25
    2be2:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    2be4:	80 91 30 1a 	lds	r24, 0x1A30
    2be8:	90 91 31 1a 	lds	r25, 0x1A31
    2bec:	01 96       	adiw	r24, 0x01	; 1
    2bee:	80 32       	cpi	r24, 0x20	; 32
    2bf0:	91 05       	cpc	r25, r1
    2bf2:	60 f4       	brcc	.+24     	; 0x2c0c <__vector_36+0x5c>
    2bf4:	90 93 31 1a 	sts	0x1A31, r25
    2bf8:	80 93 30 1a 	sts	0x1A30, r24
			rcv1_write_index = 0;

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    2bfc:	20 91 32 1a 	lds	r18, 0x1A32
    2c00:	30 91 33 1a 	lds	r19, 0x1A33
    2c04:	82 17       	cp	r24, r18
    2c06:	93 07       	cpc	r25, r19
    2c08:	f1 f4       	brne	.+60     	; 0x2c46 <__vector_36+0x96>
    2c0a:	0c c0       	rjmp	.+24     	; 0x2c24 <__vector_36+0x74>
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
			rcv1_write_index = 0;
    2c0c:	10 92 31 1a 	sts	0x1A31, r1
    2c10:	10 92 30 1a 	sts	0x1A30, r1

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    2c14:	80 91 32 1a 	lds	r24, 0x1A32
    2c18:	90 91 33 1a 	lds	r25, 0x1A33
    2c1c:	18 16       	cp	r1, r24
    2c1e:	19 06       	cpc	r1, r25
    2c20:	91 f4       	brne	.+36     	; 0x2c46 <__vector_36+0x96>
    2c22:	0e c0       	rjmp	.+28     	; 0x2c40 <__vector_36+0x90>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2c24:	01 96       	adiw	r24, 0x01	; 1
    2c26:	80 32       	cpi	r24, 0x20	; 32
    2c28:	91 05       	cpc	r25, r1
    2c2a:	28 f4       	brcc	.+10     	; 0x2c36 <__vector_36+0x86>
    2c2c:	90 93 33 1a 	sts	0x1A33, r25
    2c30:	80 93 32 1a 	sts	0x1A32, r24
    2c34:	08 c0       	rjmp	.+16     	; 0x2c46 <__vector_36+0x96>
				rcv1_read_index = 0;
    2c36:	10 92 33 1a 	sts	0x1A33, r1
    2c3a:	10 92 32 1a 	sts	0x1A32, r1
    2c3e:	03 c0       	rjmp	.+6      	; 0x2c46 <__vector_36+0x96>

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2c40:	81 e0       	ldi	r24, 0x01	; 1
    2c42:	90 e0       	ldi	r25, 0x00	; 0
    2c44:	f3 cf       	rjmp	.-26     	; 0x2c2c <__vector_36+0x7c>
				rcv1_read_index = 0;
	}
    2c46:	ff 91       	pop	r31
    2c48:	ef 91       	pop	r30
    2c4a:	9f 91       	pop	r25
    2c4c:	8f 91       	pop	r24
    2c4e:	3f 91       	pop	r19
    2c50:	2f 91       	pop	r18
    2c52:	0f 90       	pop	r0
    2c54:	0b be       	out	0x3b, r0	; 59
    2c56:	0f 90       	pop	r0
    2c58:	0f be       	out	0x3f, r0	; 63
    2c5a:	0f 90       	pop	r0
    2c5c:	1f 90       	pop	r1
    2c5e:	18 95       	reti

00002c60 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    2c60:	cf 92       	push	r12
    2c62:	df 92       	push	r13
    2c64:	ef 92       	push	r14
    2c66:	ff 92       	push	r15
    2c68:	0f 93       	push	r16
    2c6a:	1f 93       	push	r17
    2c6c:	cf 93       	push	r28
    2c6e:	df 93       	push	r29
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	MCUSR = 0;
    2c70:	14 be       	out	0x34, r1	; 52
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "n"  (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
    2c72:	0f b6       	in	r0, 0x3f	; 63
    2c74:	f8 94       	cli
    2c76:	a8 95       	wdr
    2c78:	80 91 60 00 	lds	r24, 0x0060
    2c7c:	88 61       	ori	r24, 0x18	; 24
    2c7e:	80 93 60 00 	sts	0x0060, r24
    2c82:	10 92 60 00 	sts	0x0060, r1
    2c86:	0f be       	out	0x3f, r0	; 63

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232* p_ser_port = new rs232 (9600, 1);
    2c88:	80 e1       	ldi	r24, 0x10	; 16
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	49 dc       	rcall	.-1902   	; 0x2520 <_Znwj>
    2c8e:	ec 01       	movw	r28, r24
    2c90:	41 e0       	ldi	r20, 0x01	; 1
    2c92:	60 e8       	ldi	r22, 0x80	; 128
    2c94:	75 e2       	ldi	r23, 0x25	; 37
    2c96:	f0 de       	rcall	.-544    	; 0x2a78 <_ZN5rs232C1Ejh>
	*p_ser_port << clrscr << PMS ("ME405 Lab 1 Starting Program") << endl;
    2c98:	67 e0       	ldi	r22, 0x07	; 7
    2c9a:	ce 01       	movw	r24, r28
    2c9c:	1d dd       	rcall	.-1478   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2c9e:	6b e0       	ldi	r22, 0x0B	; 11
    2ca0:	1b dd       	rcall	.-1482   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2ca2:	6c 01       	movw	r12, r24
    2ca4:	63 e3       	ldi	r22, 0x33	; 51
    2ca6:	72 e0       	ldi	r23, 0x02	; 2
    2ca8:	e0 dc       	rcall	.-1600   	; 0x266a <_ZN8emstream4putsEPKc>
    2caa:	66 e0       	ldi	r22, 0x06	; 6
    2cac:	c6 01       	movw	r24, r12
    2cae:	14 dd       	rcall	.-1496   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

	// Create the queues and other shared data items here
	p_print_ser_queue = new TextQueue (32, "Print", p_ser_port, 10);
    2cb0:	88 e1       	ldi	r24, 0x18	; 24
    2cb2:	90 e0       	ldi	r25, 0x00	; 0
    2cb4:	35 dc       	rcall	.-1942   	; 0x2520 <_Znwj>
    2cb6:	6c 01       	movw	r12, r24
    2cb8:	1a e0       	ldi	r17, 0x0A	; 10
    2cba:	e1 2e       	mov	r14, r17
    2cbc:	f1 2c       	mov	r15, r1
    2cbe:	00 e0       	ldi	r16, 0x00	; 0
    2cc0:	10 e0       	ldi	r17, 0x00	; 0
    2cc2:	9e 01       	movw	r18, r28
    2cc4:	4a e5       	ldi	r20, 0x5A	; 90
    2cc6:	52 e0       	ldi	r21, 0x02	; 2
    2cc8:	60 e2       	ldi	r22, 0x20	; 32
    2cca:	70 e0       	ldi	r23, 0x00	; 0
    2ccc:	b1 da       	rcall	.-2718   	; 0x2230 <_ZN9TextQueueC1EjPKcP8emstreamm>
    2cce:	d0 92 3d 1a 	sts	0x1A3D, r13
    2cd2:	c0 92 3c 1a 	sts	0x1A3C, r12

	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (1), 260, p_ser_port);
    2cd6:	82 e1       	ldi	r24, 0x12	; 18
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	22 dc       	rcall	.-1980   	; 0x2520 <_Znwj>
    2cdc:	8e 01       	movw	r16, r28
    2cde:	24 e0       	ldi	r18, 0x04	; 4
    2ce0:	31 e0       	ldi	r19, 0x01	; 1
    2ce2:	41 e0       	ldi	r20, 0x01	; 1
    2ce4:	60 e6       	ldi	r22, 0x60	; 96
    2ce6:	72 e0       	ldi	r23, 0x02	; 2
    2ce8:	79 d0       	rcall	.+242    	; 0x2ddc <_ZN9task_userC1EPKchjP8emstream>

	// Create a task which reads the A/D and adjusts an LED's brightness accordingly
	new task_brightness ("Bright", task_priority (2), 280, p_ser_port);
    2cea:	82 e1       	ldi	r24, 0x12	; 18
    2cec:	90 e0       	ldi	r25, 0x00	; 0
    2cee:	18 dc       	rcall	.-2000   	; 0x2520 <_Znwj>
    2cf0:	28 e1       	ldi	r18, 0x18	; 24
    2cf2:	31 e0       	ldi	r19, 0x01	; 1
    2cf4:	42 e0       	ldi	r20, 0x02	; 2
    2cf6:	68 e6       	ldi	r22, 0x68	; 104
    2cf8:	72 e0       	ldi	r23, 0x02	; 2
    2cfa:	60 d0       	rcall	.+192    	; 0x2dbc <_ZN15task_brightnessC1EPKchjP8emstream>

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    2cfc:	0e 94 9b 09 	call	0x1336	; 0x1336 <vTaskStartScheduler>
}
    2d00:	80 e0       	ldi	r24, 0x00	; 0
    2d02:	90 e0       	ldi	r25, 0x00	; 0
    2d04:	df 91       	pop	r29
    2d06:	cf 91       	pop	r28
    2d08:	1f 91       	pop	r17
    2d0a:	0f 91       	pop	r16
    2d0c:	ff 90       	pop	r15
    2d0e:	ef 90       	pop	r14
    2d10:	df 90       	pop	r13
    2d12:	cf 90       	pop	r12
    2d14:	08 95       	ret

00002d16 <_ZN15task_brightness3runEv>:
 *  loop, it reads the A/D converter and uses the result to control the brightness of 
 *  an LED. 
 */

void task_brightness::run (void)
{
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	00 d0       	rcall	.+0      	; 0x2d1c <_ZN15task_brightness3runEv+0x6>
    2d1c:	00 d0       	rcall	.+0      	; 0x2d1e <_ZN15task_brightness3runEv+0x8>
    2d1e:	cd b7       	in	r28, 0x3d	; 61
    2d20:	de b7       	in	r29, 0x3e	; 62
    2d22:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	TickType_t previousTicks = xTaskGetTickCount ();
    2d24:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <xTaskGetTickCount>
    2d28:	69 83       	std	Y+1, r22	; 0x01
    2d2a:	7a 83       	std	Y+2, r23	; 0x02
    2d2c:	8b 83       	std	Y+3, r24	; 0x03
    2d2e:	9c 83       	std	Y+4, r25	; 0x04

	// Create an analog to digital converter driver object and a variable in which to
	// store its output. The variable p_my_adc only exists within this run() method,
	// so the A/D converter cannot be used from any other function or method
	adc* p_my_adc = new adc (p_serial);
    2d30:	82 e0       	ldi	r24, 0x02	; 2
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	f5 db       	rcall	.-2070   	; 0x2520 <_Znwj>
    2d36:	7c 01       	movw	r14, r24
    2d38:	f8 01       	movw	r30, r16
    2d3a:	66 81       	ldd	r22, Z+6	; 0x06
    2d3c:	77 81       	ldd	r23, Z+7	; 0x07
    2d3e:	0e 94 2e 02 	call	0x45c	; 0x45c <_ZN3adcC1EP8emstream>

	// Configure counter/timer 3 as a PWM for LED brightness. First set the data
	// direction register so that the pin used for the PWM will be an output. The 
	// pin is Port E pin 4, which is also OC3B (Output Compare B for Timer 3)
	DDRE = (1 << 4);
    2d42:	80 e1       	ldi	r24, 0x10	; 16
    2d44:	8d b9       	out	0x0d, r24	; 13
	// To set 8-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	TCCR3A = (1 << WGM30)
			 | (1 << COM3B1) | (1 << COM3B0);
    2d46:	81 e3       	ldi	r24, 0x31	; 49
    2d48:	80 93 90 00 	sts	0x0090, r24

	// The CS31 and CS30 bits set the prescaler for this timer/counter to run the
	// timer at F_CPU / 64
	TCCR3B = (1 << WGM32)
			 | (1 << CS31)  | (1 << CS30);
    2d4c:	8b e0       	ldi	r24, 0x0B	; 11
    2d4e:	80 93 91 00 	sts	0x0091, r24
		delay_ms(600);
		
		// Set the brightness. Since the PWM has already been set up, we only need to
		// put a new value into the duty cycle control register, which on an AVR is 
		// the output compare register for a given timer/counter
		OCR3B = duty_cycle;
    2d52:	0f 2e       	mov	r0, r31
    2d54:	fa e9       	ldi	r31, 0x9A	; 154
    2d56:	cf 2e       	mov	r12, r31
    2d58:	d1 2c       	mov	r13, r1
    2d5a:	f0 2d       	mov	r31, r0
	// This is the task loop for the brightness control task. This loop runs until the
	// power is turned off or something equally dramatic occurs
	for (;;)
	{
		// Read the A/D converter
		uint16_t a2d_reading = p_my_adc-> read_oversampled (0,6);
    2d5c:	46 e0       	ldi	r20, 0x06	; 6
    2d5e:	60 e0       	ldi	r22, 0x00	; 0
    2d60:	c7 01       	movw	r24, r14
    2d62:	0e 94 72 02 	call	0x4e4	; 0x4e4 <_ZN3adc16read_oversampledEhh>

		// Convert the A/D reading into a PWM duty cycle. The A/D reading is between 0
		// and 1023; the duty cycle should be between 0 and 255. Thus, divide by 4
		uint16_t duty_cycle = a2d_reading / 4;
    2d66:	5c 01       	movw	r10, r24
    2d68:	b6 94       	lsr	r11
    2d6a:	a7 94       	ror	r10
    2d6c:	b6 94       	lsr	r11
    2d6e:	a7 94       	ror	r10
		
		*p_serial << (*p_my_adc) << endl;
    2d70:	b7 01       	movw	r22, r14
    2d72:	f8 01       	movw	r30, r16
    2d74:	86 81       	ldd	r24, Z+6	; 0x06
    2d76:	97 81       	ldd	r25, Z+7	; 0x07
    2d78:	0e 94 af 02 	call	0x55e	; 0x55e <_ZlsR8emstreamR3adc>
    2d7c:	66 e0       	ldi	r22, 0x06	; 6
    2d7e:	ac dc       	rcall	.-1704   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param   duration_ms The duration for the task to stop in milliseconds
		 */
		void delay_ms (TickType_t duration_ms)
		{
			TickType_t ticks = ((uint32_t)duration_ms * configTICK_RATE_HZ) / 1000UL;
            vTaskDelay (ticks);
    2d80:	68 e5       	ldi	r22, 0x58	; 88
    2d82:	72 e0       	ldi	r23, 0x02	; 2
    2d84:	80 e0       	ldi	r24, 0x00	; 0
    2d86:	90 e0       	ldi	r25, 0x00	; 0
    2d88:	0e 94 c5 0b 	call	0x178a	; 0x178a <vTaskDelay>
		delay_ms(600);
		
		// Set the brightness. Since the PWM has already been set up, we only need to
		// put a new value into the duty cycle control register, which on an AVR is 
		// the output compare register for a given timer/counter
		OCR3B = duty_cycle;
    2d8c:	f6 01       	movw	r30, r12
    2d8e:	b1 82       	std	Z+1, r11	; 0x01
    2d90:	a0 82       	st	Z, r10

		// Increment the run counter. This counter belongs to the parent class and can
		// be printed out for debugging purposes
		runs++;
    2d92:	f8 01       	movw	r30, r16
    2d94:	86 85       	ldd	r24, Z+14	; 0x0e
    2d96:	97 85       	ldd	r25, Z+15	; 0x0f
    2d98:	a0 89       	ldd	r26, Z+16	; 0x10
    2d9a:	b1 89       	ldd	r27, Z+17	; 0x11
    2d9c:	01 96       	adiw	r24, 0x01	; 1
    2d9e:	a1 1d       	adc	r26, r1
    2da0:	b1 1d       	adc	r27, r1
    2da2:	86 87       	std	Z+14, r24	; 0x0e
    2da4:	97 87       	std	Z+15, r25	; 0x0f
    2da6:	a0 8b       	std	Z+16, r26	; 0x10
    2da8:	b1 8b       	std	Z+17, r27	; 0x11
         *  @param   millisec The duration of the delay interval in milliseconds
         */
        void delay_from_for_ms (TickType_t& from_ticks, TickType_t millisec)
        {
            TickType_t ticks = ((uint32_t)millisec * configTICK_RATE_HZ) / 1000UL;
            vTaskDelayUntil (&from_ticks, ticks);
    2daa:	44 e6       	ldi	r20, 0x64	; 100
    2dac:	50 e0       	ldi	r21, 0x00	; 0
    2dae:	60 e0       	ldi	r22, 0x00	; 0
    2db0:	70 e0       	ldi	r23, 0x00	; 0
    2db2:	ce 01       	movw	r24, r28
    2db4:	01 96       	adiw	r24, 0x01	; 1
    2db6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vTaskDelayUntil>
    2dba:	d0 cf       	rjmp	.-96     	; 0x2d5c <_ZN15task_brightness3runEv+0x46>

00002dbc <_ZN15task_brightnessC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_brightness::task_brightness (const char* a_name, 
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: TaskBase (a_name, a_priority, a_stack_size, p_ser_dev)
    2dc6:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <_ZN8TaskBaseC1EPKchjP8emstream>
    2dca:	83 e7       	ldi	r24, 0x73	; 115
    2dcc:	92 e0       	ldi	r25, 0x02	; 2
    2dce:	99 83       	std	Y+1, r25	; 0x01
    2dd0:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    2dd2:	df 91       	pop	r29
    2dd4:	cf 91       	pop	r28
    2dd6:	1f 91       	pop	r17
    2dd8:	0f 91       	pop	r16
    2dda:	08 95       	ret

00002ddc <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    2ddc:	0f 93       	push	r16
    2dde:	1f 93       	push	r17
    2de0:	cf 93       	push	r28
    2de2:	df 93       	push	r29
    2de4:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: TaskBase (a_name, a_priority, a_stack_size, p_ser_dev)
    2de6:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <_ZN8TaskBaseC1EPKchjP8emstream>
    2dea:	8f e7       	ldi	r24, 0x7F	; 127
    2dec:	92 e0       	ldi	r25, 0x02	; 2
    2dee:	99 83       	std	Y+1, r25	; 0x01
    2df0:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	1f 91       	pop	r17
    2df8:	0f 91       	pop	r16
    2dfa:	08 95       	ret

00002dfc <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    2dfc:	0f 93       	push	r16
    2dfe:	1f 93       	push	r17
    2e00:	cf 93       	push	r28
    2e02:	df 93       	push	r29
    2e04:	ec 01       	movw	r28, r24
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    2e06:	6b e0       	ldi	r22, 0x0B	; 11
    2e08:	8e 81       	ldd	r24, Y+6	; 0x06
    2e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e0c:	65 dc       	rcall	.-1846   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e0e:	8c 01       	movw	r16, r24
    2e10:	6e e4       	ldi	r22, 0x4E	; 78
    2e12:	73 e0       	ldi	r23, 0x03	; 3
    2e14:	2a dc       	rcall	.-1964   	; 0x266a <_ZN8emstream4putsEPKc>
    2e16:	6b e0       	ldi	r22, 0x0B	; 11
    2e18:	c8 01       	movw	r24, r16
    2e1a:	5e dc       	rcall	.-1860   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e1c:	8c 01       	movw	r16, r24
    2e1e:	64 e7       	ldi	r22, 0x74	; 116
    2e20:	73 e0       	ldi	r23, 0x03	; 3
    2e22:	23 dc       	rcall	.-1978   	; 0x266a <_ZN8emstream4putsEPKc>
    2e24:	66 e0       	ldi	r22, 0x06	; 6
    2e26:	c8 01       	movw	r24, r16
    2e28:	57 dc       	rcall	.-1874   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  t:     Show the time right now") << endl;
    2e2a:	6b e0       	ldi	r22, 0x0B	; 11
    2e2c:	8e 81       	ldd	r24, Y+6	; 0x06
    2e2e:	9f 81       	ldd	r25, Y+7	; 0x07
    2e30:	53 dc       	rcall	.-1882   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e32:	8c 01       	movw	r16, r24
    2e34:	6d e2       	ldi	r22, 0x2D	; 45
    2e36:	73 e0       	ldi	r23, 0x03	; 3
    2e38:	18 dc       	rcall	.-2000   	; 0x266a <_ZN8emstream4putsEPKc>
    2e3a:	66 e0       	ldi	r22, 0x06	; 6
    2e3c:	c8 01       	movw	r24, r16
    2e3e:	4c dc       	rcall	.-1896   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  s:     Version and setup information") << endl;
    2e40:	6b e0       	ldi	r22, 0x0B	; 11
    2e42:	8e 81       	ldd	r24, Y+6	; 0x06
    2e44:	9f 81       	ldd	r25, Y+7	; 0x07
    2e46:	48 dc       	rcall	.-1904   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e48:	8c 01       	movw	r16, r24
    2e4a:	66 e0       	ldi	r22, 0x06	; 6
    2e4c:	73 e0       	ldi	r23, 0x03	; 3
    2e4e:	0d dc       	rcall	.-2022   	; 0x266a <_ZN8emstream4putsEPKc>
    2e50:	66 e0       	ldi	r22, 0x06	; 6
    2e52:	c8 01       	movw	r24, r16
    2e54:	41 dc       	rcall	.-1918   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  d:     Stack dump for tasks") << endl;
    2e56:	6b e0       	ldi	r22, 0x0B	; 11
    2e58:	8e 81       	ldd	r24, Y+6	; 0x06
    2e5a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e5c:	3d dc       	rcall	.-1926   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e5e:	8c 01       	movw	r16, r24
    2e60:	68 ee       	ldi	r22, 0xE8	; 232
    2e62:	72 e0       	ldi	r23, 0x02	; 2
    2e64:	02 dc       	rcall	.-2044   	; 0x266a <_ZN8emstream4putsEPKc>
    2e66:	66 e0       	ldi	r22, 0x06	; 6
    2e68:	c8 01       	movw	r24, r16
    2e6a:	36 dc       	rcall	.-1940   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  n:     Enter a number (demo)") << endl;
    2e6c:	6b e0       	ldi	r22, 0x0B	; 11
    2e6e:	8e 81       	ldd	r24, Y+6	; 0x06
    2e70:	9f 81       	ldd	r25, Y+7	; 0x07
    2e72:	32 dc       	rcall	.-1948   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e74:	8c 01       	movw	r16, r24
    2e76:	69 ec       	ldi	r22, 0xC9	; 201
    2e78:	72 e0       	ldi	r23, 0x02	; 2
    2e7a:	f7 db       	rcall	.-2066   	; 0x266a <_ZN8emstream4putsEPKc>
    2e7c:	66 e0       	ldi	r22, 0x06	; 6
    2e7e:	c8 01       	movw	r24, r16
    2e80:	2b dc       	rcall	.-1962   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    2e82:	6b e0       	ldi	r22, 0x0B	; 11
    2e84:	8e 81       	ldd	r24, Y+6	; 0x06
    2e86:	9f 81       	ldd	r25, Y+7	; 0x07
    2e88:	27 dc       	rcall	.-1970   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2e8a:	8c 01       	movw	r16, r24
    2e8c:	62 eb       	ldi	r22, 0xB2	; 178
    2e8e:	72 e0       	ldi	r23, 0x02	; 2
    2e90:	ec db       	rcall	.-2088   	; 0x266a <_ZN8emstream4putsEPKc>
    2e92:	66 e0       	ldi	r22, 0x06	; 6
    2e94:	c8 01       	movw	r24, r16
    2e96:	20 dc       	rcall	.-1984   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  h:     HALP!") << endl;
    2e98:	6b e0       	ldi	r22, 0x0B	; 11
    2e9a:	8e 81       	ldd	r24, Y+6	; 0x06
    2e9c:	9f 81       	ldd	r25, Y+7	; 0x07
    2e9e:	1c dc       	rcall	.-1992   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2ea0:	ec 01       	movw	r28, r24
    2ea2:	63 ea       	ldi	r22, 0xA3	; 163
    2ea4:	72 e0       	ldi	r23, 0x02	; 2
    2ea6:	e1 db       	rcall	.-2110   	; 0x266a <_ZN8emstream4putsEPKc>
    2ea8:	66 e0       	ldi	r22, 0x06	; 6
    2eaa:	ce 01       	movw	r24, r28
    2eac:	15 dc       	rcall	.-2006   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
}
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	1f 91       	pop	r17
    2eb4:	0f 91       	pop	r16
    2eb6:	08 95       	ret

00002eb8 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    2eb8:	8f 92       	push	r8
    2eba:	9f 92       	push	r9
    2ebc:	af 92       	push	r10
    2ebe:	bf 92       	push	r11
    2ec0:	cf 92       	push	r12
    2ec2:	df 92       	push	r13
    2ec4:	ef 92       	push	r14
    2ec6:	ff 92       	push	r15
    2ec8:	0f 93       	push	r16
    2eca:	1f 93       	push	r17
    2ecc:	cf 93       	push	r28
    2ece:	df 93       	push	r29
    2ed0:	00 d0       	rcall	.+0      	; 0x2ed2 <_ZN9task_user11show_statusEv+0x1a>
    2ed2:	00 d0       	rcall	.+0      	; 0x2ed4 <_ZN9task_user11show_statusEv+0x1c>
    2ed4:	00 d0       	rcall	.+0      	; 0x2ed6 <_ZN9task_user11show_statusEv+0x1e>
    2ed6:	cd b7       	in	r28, 0x3d	; 61
    2ed8:	de b7       	in	r29, 0x3e	; 62
    2eda:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    2edc:	19 82       	std	Y+1, r1	; 0x01
    2ede:	1a 82       	std	Y+2, r1	; 0x02
    2ee0:	1b 82       	std	Y+3, r1	; 0x03
    2ee2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    2ee4:	1e 82       	std	Y+6, r1	; 0x06
    2ee6:	1d 82       	std	Y+5, r1	; 0x05
	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("System time: ") << the_time.set_to_now ()
			  << PMS (", Heap: ") << heap_left() << "/" << configTOTAL_HEAP_SIZE
			  #ifdef OCR5A
				<< PMS (", OCR5A: ") << OCR5A << endl << endl;
    2ee8:	c0 90 28 01 	lds	r12, 0x0128
    2eec:	d0 90 29 01 	lds	r13, 0x0129
		 *           available for allocation. 
		 *  @return  The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    2ef0:	0e 94 ac 03 	call	0x758	; 0x758 <xPortGetFreeHeapSize>
    2ef4:	5c 01       	movw	r10, r24
{
	time_stamp the_time;					// Holds current time for printing

	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("System time: ") << the_time.set_to_now ()
    2ef6:	ce 01       	movw	r24, r28
    2ef8:	01 96       	adiw	r24, 0x01	; 1
    2efa:	79 da       	rcall	.-2830   	; 0x23ee <_ZN10time_stamp10set_to_nowEv>
    2efc:	4c 01       	movw	r8, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    2efe:	66 e0       	ldi	r22, 0x06	; 6
    2f00:	f8 01       	movw	r30, r16
    2f02:	86 81       	ldd	r24, Z+6	; 0x06
    2f04:	97 81       	ldd	r25, Z+7	; 0x07
    2f06:	e8 db       	rcall	.-2096   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f08:	6b e0       	ldi	r22, 0x0B	; 11
    2f0a:	e6 db       	rcall	.-2100   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f0c:	7c 01       	movw	r14, r24
    2f0e:	60 e5       	ldi	r22, 0x50	; 80
    2f10:	72 e0       	ldi	r23, 0x02	; 2
    2f12:	ab db       	rcall	.-2218   	; 0x266a <_ZN8emstream4putsEPKc>
    2f14:	6b e0       	ldi	r22, 0x0B	; 11
    2f16:	c7 01       	movw	r24, r14
    2f18:	df db       	rcall	.-2114   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f1a:	7c 01       	movw	r14, r24
    2f1c:	66 e7       	ldi	r22, 0x76	; 118
    2f1e:	72 e0       	ldi	r23, 0x02	; 2
    2f20:	a4 db       	rcall	.-2232   	; 0x266a <_ZN8emstream4putsEPKc>
    2f22:	66 e0       	ldi	r22, 0x06	; 6
    2f24:	c7 01       	movw	r24, r14
    2f26:	d8 db       	rcall	.-2128   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("System time: ") << the_time.set_to_now ()
    2f28:	6b e0       	ldi	r22, 0x0B	; 11
    2f2a:	d6 db       	rcall	.-2132   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f2c:	7c 01       	movw	r14, r24
    2f2e:	62 e8       	ldi	r22, 0x82	; 130
    2f30:	72 e0       	ldi	r23, 0x02	; 2
    2f32:	9b db       	rcall	.-2250   	; 0x266a <_ZN8emstream4putsEPKc>
    2f34:	b4 01       	movw	r22, r8
    2f36:	c7 01       	movw	r24, r14
    2f38:	fd d9       	rcall	.-3078   	; 0x2334 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap: ") << heap_left() << "/" << configTOTAL_HEAP_SIZE
    2f3a:	6b e0       	ldi	r22, 0x0B	; 11
    2f3c:	cd db       	rcall	.-2150   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f3e:	7c 01       	movw	r14, r24
    2f40:	60 e9       	ldi	r22, 0x90	; 144
    2f42:	72 e0       	ldi	r23, 0x02	; 2
    2f44:	92 db       	rcall	.-2268   	; 0x266a <_ZN8emstream4putsEPKc>
    2f46:	b5 01       	movw	r22, r10
    2f48:	c7 01       	movw	r24, r14
    2f4a:	0a dc       	rcall	.-2028   	; 0x2760 <_ZN8emstreamlsEj>
    2f4c:	7c 01       	movw	r14, r24
    2f4e:	67 e7       	ldi	r22, 0x77	; 119
    2f50:	72 e0       	ldi	r23, 0x02	; 2
    2f52:	8b db       	rcall	.-2282   	; 0x266a <_ZN8emstream4putsEPKc>
    2f54:	48 e3       	ldi	r20, 0x38	; 56
    2f56:	57 e1       	ldi	r21, 0x17	; 23
    2f58:	60 e0       	ldi	r22, 0x00	; 0
    2f5a:	70 e0       	ldi	r23, 0x00	; 0
    2f5c:	c7 01       	movw	r24, r14
    2f5e:	36 dc       	rcall	.-1940   	; 0x27cc <_ZN8emstreamlsEm>
			  #ifdef OCR5A
				<< PMS (", OCR5A: ") << OCR5A << endl << endl;
    2f60:	6b e0       	ldi	r22, 0x0B	; 11
    2f62:	ba db       	rcall	.-2188   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f64:	7c 01       	movw	r14, r24
    2f66:	69 e9       	ldi	r22, 0x99	; 153
    2f68:	72 e0       	ldi	r23, 0x02	; 2
    2f6a:	7f db       	rcall	.-2306   	; 0x266a <_ZN8emstream4putsEPKc>
    2f6c:	b6 01       	movw	r22, r12
    2f6e:	c7 01       	movw	r24, r14
    2f70:	f7 db       	rcall	.-2066   	; 0x2760 <_ZN8emstreamlsEj>
    2f72:	66 e0       	ldi	r22, 0x06	; 6
    2f74:	b1 db       	rcall	.-2206   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2f76:	66 e0       	ldi	r22, 0x06	; 6
    2f78:	af db       	rcall	.-2210   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
			  #else
				<< PMS (", OCR1A: ") << OCR1A << endl << endl;
			  #endif

	// Have the tasks print their status; then the same for the shared data items
	print_task_list (p_serial);
    2f7a:	f8 01       	movw	r30, r16
    2f7c:	86 81       	ldd	r24, Z+6	; 0x06
    2f7e:	97 81       	ldd	r25, Z+7	; 0x07
    2f80:	40 d8       	rcall	.-3968   	; 0x2002 <_Z15print_task_listP8emstream>
	*p_serial << endl;
    2f82:	66 e0       	ldi	r22, 0x06	; 6
    2f84:	f8 01       	movw	r30, r16
    2f86:	86 81       	ldd	r24, Z+6	; 0x06
    2f88:	97 81       	ldd	r25, Z+7	; 0x07
    2f8a:	a6 db       	rcall	.-2228   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
	print_all_shares (p_serial);
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	86 81       	ldd	r24, Z+6	; 0x06
    2f90:	97 81       	ldd	r25, Z+7	; 0x07
    2f92:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <_Z16print_all_sharesP8emstream>
}
    2f96:	26 96       	adiw	r28, 0x06	; 6
    2f98:	0f b6       	in	r0, 0x3f	; 63
    2f9a:	f8 94       	cli
    2f9c:	de bf       	out	0x3e, r29	; 62
    2f9e:	0f be       	out	0x3f, r0	; 63
    2fa0:	cd bf       	out	0x3d, r28	; 61
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	1f 91       	pop	r17
    2fa8:	0f 91       	pop	r16
    2faa:	ff 90       	pop	r15
    2fac:	ef 90       	pop	r14
    2fae:	df 90       	pop	r13
    2fb0:	cf 90       	pop	r12
    2fb2:	bf 90       	pop	r11
    2fb4:	af 90       	pop	r10
    2fb6:	9f 90       	pop	r9
    2fb8:	8f 90       	pop	r8
    2fba:	08 95       	ret

00002fbc <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    2fbc:	cf 93       	push	r28
    2fbe:	df 93       	push	r29
    2fc0:	00 d0       	rcall	.+0      	; 0x2fc2 <_ZN9task_user3runEv+0x6>
    2fc2:	00 d0       	rcall	.+0      	; 0x2fc4 <_ZN9task_user3runEv+0x8>
    2fc4:	00 d0       	rcall	.+0      	; 0x2fc6 <_ZN9task_user3runEv+0xa>
    2fc6:	cd b7       	in	r28, 0x3d	; 61
    2fc8:	de b7       	in	r29, 0x3e	; 62
    2fca:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    2fcc:	19 82       	std	Y+1, r1	; 0x01
    2fce:	1a 82       	std	Y+2, r1	; 0x02
    2fd0:	1b 82       	std	Y+3, r1	; 0x03
    2fd2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    2fd4:	1e 82       	std	Y+6, r1	; 0x06
    2fd6:	1d 82       	std	Y+5, r1	; 0x05
	time_stamp a_time;                      // Holds the time so it can be displayed
	uint32_t number_entered = 0;            // Holds a number being entered by user

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press 'h' or '?' for help") << endl;
    2fd8:	6b e0       	ldi	r22, 0x0B	; 11
    2fda:	dc 01       	movw	r26, r24
    2fdc:	16 96       	adiw	r26, 0x06	; 6
    2fde:	8d 91       	ld	r24, X+
    2fe0:	9c 91       	ld	r25, X
    2fe2:	17 97       	sbiw	r26, 0x07	; 7
    2fe4:	79 db       	rcall	.-2318   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    2fe6:	7c 01       	movw	r14, r24
    2fe8:	62 e0       	ldi	r22, 0x02	; 2
    2fea:	74 e0       	ldi	r23, 0x04	; 4
    2fec:	3e db       	rcall	.-2436   	; 0x266a <_ZN8emstream4putsEPKc>
    2fee:	66 e0       	ldi	r22, 0x06	; 6
    2ff0:	c7 01       	movw	r24, r14
    2ff2:	72 db       	rcall	.-2332   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>

void task_user::run (void)
{
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed
	uint32_t number_entered = 0;            // Holds a number being entered by user
    2ff4:	c1 2c       	mov	r12, r1
    2ff6:	d1 2c       	mov	r13, r1
    2ff8:	76 01       	movw	r14, r12

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
							             "then RETURN or ESC") << endl;
							number_entered = 0;
    2ffa:	51 2c       	mov	r5, r1
    2ffc:	61 2c       	mov	r6, r1
    2ffe:	71 2c       	mov	r7, r1
    3000:	81 2c       	mov	r8, r1
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by parent class
		switch (state)
    3002:	f8 01       	movw	r30, r16
    3004:	84 85       	ldd	r24, Z+12	; 0x0c
    3006:	88 23       	and	r24, r24
    3008:	21 f0       	breq	.+8      	; 0x3012 <_ZN9task_user3runEv+0x56>
    300a:	81 30       	cpi	r24, 0x01	; 1
    300c:	09 f4       	brne	.+2      	; 0x3010 <_ZN9task_user3runEv+0x54>
    300e:	9a c0       	rjmp	.+308    	; 0x3144 <_ZN9task_user3runEv+0x188>
    3010:	48 c1       	rjmp	.+656    	; 0x32a2 <_ZN9task_user3runEv+0x2e6>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we're in command mode, so when the user types characters, 
			// the characters are interpreted as commands to do something
			case (0):
				if (p_serial->check_for_char ())            // If the user typed a
    3012:	86 81       	ldd	r24, Z+6	; 0x06
    3014:	97 81       	ldd	r25, Z+7	; 0x07
    3016:	dc 01       	movw	r26, r24
    3018:	ed 91       	ld	r30, X+
    301a:	fc 91       	ld	r31, X
    301c:	04 80       	ldd	r0, Z+4	; 0x04
    301e:	f5 81       	ldd	r31, Z+5	; 0x05
    3020:	e0 2d       	mov	r30, r0
    3022:	09 95       	icall
    3024:	88 23       	and	r24, r24
    3026:	09 f4       	brne	.+2      	; 0x302a <_ZN9task_user3runEv+0x6e>
    3028:	52 c1       	rjmp	.+676    	; 0x32ce <_ZN9task_user3runEv+0x312>
				{                                           // character, read
					char_in = p_serial->getchar ();         // the character
    302a:	f8 01       	movw	r30, r16
    302c:	86 81       	ldd	r24, Z+6	; 0x06
    302e:	97 81       	ldd	r25, Z+7	; 0x07
    3030:	dc 01       	movw	r26, r24
    3032:	ed 91       	ld	r30, X+
    3034:	fc 91       	ld	r31, X
    3036:	06 80       	ldd	r0, Z+6	; 0x06
    3038:	f7 81       	ldd	r31, Z+7	; 0x07
    303a:	e0 2d       	mov	r30, r0
    303c:	09 95       	icall
    303e:	98 2e       	mov	r9, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    3040:	b8 e6       	ldi	r27, 0x68	; 104
    3042:	8b 17       	cp	r24, r27
    3044:	61 f1       	breq	.+88     	; 0x309e <_ZN9task_user3runEv+0xe2>
    3046:	b8 17       	cp	r27, r24
    3048:	50 f0       	brcs	.+20     	; 0x305e <_ZN9task_user3runEv+0xa2>
    304a:	ef e3       	ldi	r30, 0x3F	; 63
    304c:	8e 17       	cp	r24, r30
    304e:	39 f1       	breq	.+78     	; 0x309e <_ZN9task_user3runEv+0xe2>
    3050:	f4 e6       	ldi	r31, 0x64	; 100
    3052:	8f 17       	cp	r24, r31
    3054:	f1 f0       	breq	.+60     	; 0x3092 <_ZN9task_user3runEv+0xd6>
    3056:	83 e0       	ldi	r24, 0x03	; 3
    3058:	98 12       	cpse	r9, r24
    305a:	52 c0       	rjmp	.+164    	; 0x3100 <_ZN9task_user3runEv+0x144>
    305c:	3a c0       	rjmp	.+116    	; 0x30d2 <_ZN9task_user3runEv+0x116>
    305e:	a3 e7       	ldi	r26, 0x73	; 115
    3060:	8a 17       	cp	r24, r26
    3062:	a1 f0       	breq	.+40     	; 0x308c <_ZN9task_user3runEv+0xd0>
    3064:	b4 e7       	ldi	r27, 0x74	; 116
    3066:	8b 17       	cp	r24, r27
    3068:	21 f0       	breq	.+8      	; 0x3072 <_ZN9task_user3runEv+0xb6>
    306a:	ee e6       	ldi	r30, 0x6E	; 110
    306c:	8e 13       	cpse	r24, r30
    306e:	48 c0       	rjmp	.+144    	; 0x3100 <_ZN9task_user3runEv+0x144>
    3070:	19 c0       	rjmp	.+50     	; 0x30a4 <_ZN9task_user3runEv+0xe8>
					{
						// The 't' command asks what time it is right now
						case ('t'):
							*p_serial << (a_time.set_to_now ()) << endl;
    3072:	ce 01       	movw	r24, r28
    3074:	01 96       	adiw	r24, 0x01	; 1
    3076:	bb d9       	rcall	.-3210   	; 0x23ee <_ZN10time_stamp10set_to_nowEv>
    3078:	bc 01       	movw	r22, r24
    307a:	d8 01       	movw	r26, r16
    307c:	16 96       	adiw	r26, 0x06	; 6
    307e:	8d 91       	ld	r24, X+
    3080:	9c 91       	ld	r25, X
    3082:	17 97       	sbiw	r26, 0x07	; 7
    3084:	57 d9       	rcall	.-3410   	; 0x2334 <_ZlsR8emstreamR10time_stamp>
    3086:	66 e0       	ldi	r22, 0x06	; 6
    3088:	27 db       	rcall	.-2482   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    308a:	21 c1       	rjmp	.+578    	; 0x32ce <_ZN9task_user3runEv+0x312>

						// The 's' command asks for version and status information
						case ('s'):
							show_status ();
    308c:	c8 01       	movw	r24, r16
    308e:	14 df       	rcall	.-472    	; 0x2eb8 <_ZN9task_user11show_statusEv>
							break;
    3090:	1e c1       	rjmp	.+572    	; 0x32ce <_ZN9task_user3runEv+0x312>

						// The 'd' command has all the tasks dump their stacks
						case ('d'):
							print_task_stacks (p_serial);
    3092:	f8 01       	movw	r30, r16
    3094:	86 81       	ldd	r24, Z+6	; 0x06
    3096:	97 81       	ldd	r25, Z+7	; 0x07
    3098:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <_Z17print_task_stacksP8emstream>
							break;
    309c:	18 c1       	rjmp	.+560    	; 0x32ce <_ZN9task_user3runEv+0x312>

						// The 'h' command is a plea for help; '?' works also
						case ('h'):
						case ('?'):
							print_help_message ();
    309e:	c8 01       	movw	r24, r16
    30a0:	ad de       	rcall	.-678    	; 0x2dfc <_ZN9task_user18print_help_messageEv>
							break;
    30a2:	15 c1       	rjmp	.+554    	; 0x32ce <_ZN9task_user3runEv+0x312>

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
    30a4:	6b e0       	ldi	r22, 0x0B	; 11
    30a6:	d8 01       	movw	r26, r16
    30a8:	16 96       	adiw	r26, 0x06	; 6
    30aa:	8d 91       	ld	r24, X+
    30ac:	9c 91       	ld	r25, X
    30ae:	17 97       	sbiw	r26, 0x07	; 7
    30b0:	13 db       	rcall	.-2522   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    30b2:	7c 01       	movw	r14, r24
    30b4:	61 ed       	ldi	r22, 0xD1	; 209
    30b6:	73 e0       	ldi	r23, 0x03	; 3
    30b8:	d8 da       	rcall	.-2640   	; 0x266a <_ZN8emstream4putsEPKc>
							             "then RETURN or ESC") << endl;
    30ba:	66 e0       	ldi	r22, 0x06	; 6
    30bc:	c7 01       	movw	r24, r14
    30be:	0c db       	rcall	.-2536   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
							number_entered = 0;
							transition_to (1);
    30c0:	61 e0       	ldi	r22, 0x01	; 1
    30c2:	c8 01       	movw	r24, r16
    30c4:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <_ZN8TaskBase13transition_toEh>

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
							             "then RETURN or ESC") << endl;
							number_entered = 0;
    30c8:	c5 2c       	mov	r12, r5
    30ca:	d6 2c       	mov	r13, r6
    30cc:	e7 2c       	mov	r14, r7
    30ce:	f8 2c       	mov	r15, r8
							transition_to (1);
							break;
    30d0:	fe c0       	rjmp	.+508    	; 0x32ce <_ZN9task_user3runEv+0x312>

						// A control-C character causes the CPU to restart
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    30d2:	6b e0       	ldi	r22, 0x0B	; 11
    30d4:	f8 01       	movw	r30, r16
    30d6:	86 81       	ldd	r24, Z+6	; 0x06
    30d8:	97 81       	ldd	r25, Z+7	; 0x07
    30da:	fe da       	rcall	.-2564   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    30dc:	8c 01       	movw	r16, r24
    30de:	63 ec       	ldi	r22, 0xC3	; 195
    30e0:	73 e0       	ldi	r23, 0x03	; 3
    30e2:	c3 da       	rcall	.-2682   	; 0x266a <_ZN8emstream4putsEPKc>
    30e4:	66 e0       	ldi	r22, 0x06	; 6
    30e6:	c8 01       	movw	r24, r16
    30e8:	f7 da       	rcall	.-2578   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
    30ea:	9b e0       	ldi	r25, 0x0B	; 11
    30ec:	88 e1       	ldi	r24, 0x18	; 24
    30ee:	0f b6       	in	r0, 0x3f	; 63
    30f0:	f8 94       	cli
    30f2:	a8 95       	wdr
    30f4:	80 93 60 00 	sts	0x0060, r24
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	90 93 60 00 	sts	0x0060, r25
							break;

						// If character isn't recognized, ask What's That Function?
						default:
							*p_serial << '"' << char_in << PMS ("\": WTF?") << endl;
							break;
    30fe:	ff cf       	rjmp	.-2      	; 0x30fe <_ZN9task_user3runEv+0x142>
							for (;;);
							break;

						// If character isn't recognized, ask What's That Function?
						default:
							*p_serial << '"' << char_in << PMS ("\": WTF?") << endl;
    3100:	d8 01       	movw	r26, r16
    3102:	16 96       	adiw	r26, 0x06	; 6
    3104:	ad 90       	ld	r10, X+
    3106:	bc 90       	ld	r11, X
    3108:	17 97       	sbiw	r26, 0x07	; 7
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    310a:	d5 01       	movw	r26, r10
    310c:	ed 91       	ld	r30, X+
    310e:	fc 91       	ld	r31, X
    3110:	02 80       	ldd	r0, Z+2	; 0x02
    3112:	f3 81       	ldd	r31, Z+3	; 0x03
    3114:	e0 2d       	mov	r30, r0
    3116:	62 e2       	ldi	r22, 0x22	; 34
    3118:	c5 01       	movw	r24, r10
    311a:	09 95       	icall
    311c:	d5 01       	movw	r26, r10
    311e:	ed 91       	ld	r30, X+
    3120:	fc 91       	ld	r31, X
    3122:	02 80       	ldd	r0, Z+2	; 0x02
    3124:	f3 81       	ldd	r31, Z+3	; 0x03
    3126:	e0 2d       	mov	r30, r0
    3128:	69 2d       	mov	r22, r9
    312a:	c5 01       	movw	r24, r10
    312c:	09 95       	icall
    312e:	6b e0       	ldi	r22, 0x0B	; 11
    3130:	c5 01       	movw	r24, r10
    3132:	d2 da       	rcall	.-2652   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    3134:	5c 01       	movw	r10, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3136:	6b eb       	ldi	r22, 0xBB	; 187
    3138:	73 e0       	ldi	r23, 0x03	; 3
    313a:	97 da       	rcall	.-2770   	; 0x266a <_ZN8emstream4putsEPKc>
    313c:	66 e0       	ldi	r22, 0x06	; 6
    313e:	c5 01       	movw	r24, r10
    3140:	cb da       	rcall	.-2666   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    3142:	c5 c0       	rjmp	.+394    	; 0x32ce <_ZN9task_user3runEv+0x312>
				break; // End of state 0

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, wait for user to enter digits and build 'em into a number
			case (1):
				if (p_serial->check_for_char ())        // If the user typed a
    3144:	f8 01       	movw	r30, r16
    3146:	86 81       	ldd	r24, Z+6	; 0x06
    3148:	97 81       	ldd	r25, Z+7	; 0x07
    314a:	dc 01       	movw	r26, r24
    314c:	ed 91       	ld	r30, X+
    314e:	fc 91       	ld	r31, X
    3150:	04 80       	ldd	r0, Z+4	; 0x04
    3152:	f5 81       	ldd	r31, Z+5	; 0x05
    3154:	e0 2d       	mov	r30, r0
    3156:	09 95       	icall
    3158:	88 23       	and	r24, r24
    315a:	09 f4       	brne	.+2      	; 0x315e <_ZN9task_user3runEv+0x1a2>
    315c:	79 c0       	rjmp	.+242    	; 0x3250 <_ZN9task_user3runEv+0x294>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    315e:	f8 01       	movw	r30, r16
    3160:	86 81       	ldd	r24, Z+6	; 0x06
    3162:	97 81       	ldd	r25, Z+7	; 0x07
    3164:	dc 01       	movw	r26, r24
    3166:	ed 91       	ld	r30, X+
    3168:	fc 91       	ld	r31, X
    316a:	06 80       	ldd	r0, Z+6	; 0x06
    316c:	f7 81       	ldd	r31, Z+7	; 0x07
    316e:	e0 2d       	mov	r30, r0
    3170:	09 95       	icall
    3172:	98 2e       	mov	r9, r24

					// Respond to numeric characters, Enter or Esc only. Numbers are
					// put into the numeric value we're building up
					if (char_in >= '0' && char_in <= '9')
    3174:	80 ed       	ldi	r24, 0xD0	; 208
    3176:	89 0d       	add	r24, r9
    3178:	8a 30       	cpi	r24, 0x0A	; 10
    317a:	48 f5       	brcc	.+82     	; 0x31ce <_ZN9task_user3runEv+0x212>
					{
						*p_serial << char_in;
    317c:	f8 01       	movw	r30, r16
    317e:	86 81       	ldd	r24, Z+6	; 0x06
    3180:	97 81       	ldd	r25, Z+7	; 0x07
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3182:	dc 01       	movw	r26, r24
    3184:	ed 91       	ld	r30, X+
    3186:	fc 91       	ld	r31, X
    3188:	02 80       	ldd	r0, Z+2	; 0x02
    318a:	f3 81       	ldd	r31, Z+3	; 0x03
    318c:	e0 2d       	mov	r30, r0
    318e:	69 2d       	mov	r22, r9
    3190:	09 95       	icall
						number_entered *= 10;
    3192:	cc 0c       	add	r12, r12
    3194:	dd 1c       	adc	r13, r13
    3196:	ee 1c       	adc	r14, r14
    3198:	ff 1c       	adc	r15, r15
    319a:	d7 01       	movw	r26, r14
    319c:	c6 01       	movw	r24, r12
    319e:	88 0f       	add	r24, r24
    31a0:	99 1f       	adc	r25, r25
    31a2:	aa 1f       	adc	r26, r26
    31a4:	bb 1f       	adc	r27, r27
    31a6:	88 0f       	add	r24, r24
    31a8:	99 1f       	adc	r25, r25
    31aa:	aa 1f       	adc	r26, r26
    31ac:	bb 1f       	adc	r27, r27
    31ae:	c8 0e       	add	r12, r24
    31b0:	d9 1e       	adc	r13, r25
    31b2:	ea 1e       	adc	r14, r26
    31b4:	fb 1e       	adc	r15, r27
						number_entered += char_in - '0';
    31b6:	89 2d       	mov	r24, r9
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	c0 97       	sbiw	r24, 0x30	; 48
    31bc:	09 2e       	mov	r0, r25
    31be:	00 0c       	add	r0, r0
    31c0:	aa 0b       	sbc	r26, r26
    31c2:	bb 0b       	sbc	r27, r27
    31c4:	c8 0e       	add	r12, r24
    31c6:	d9 1e       	adc	r13, r25
    31c8:	ea 1e       	adc	r14, r26
    31ca:	fb 1e       	adc	r15, r27
    31cc:	80 c0       	rjmp	.+256    	; 0x32ce <_ZN9task_user3runEv+0x312>
					}
					// Carriage return is ignored; the newline character ends the entry
					else if (char_in == 10)
    31ce:	ba e0       	ldi	r27, 0x0A	; 10
    31d0:	9b 12       	cpse	r9, r27
    31d2:	07 c0       	rjmp	.+14     	; 0x31e2 <_ZN9task_user3runEv+0x226>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    31d4:	69 e7       	ldi	r22, 0x79	; 121
    31d6:	72 e0       	ldi	r23, 0x02	; 2
    31d8:	f8 01       	movw	r30, r16
    31da:	86 81       	ldd	r24, Z+6	; 0x06
    31dc:	97 81       	ldd	r25, Z+7	; 0x07
    31de:	45 da       	rcall	.-2934   	; 0x266a <_ZN8emstream4putsEPKc>
    31e0:	76 c0       	rjmp	.+236    	; 0x32ce <_ZN9task_user3runEv+0x312>
					{
						*p_serial << "\r";
					}
					// Carriage return or Escape ends numeric entry
					else if (char_in == 13 || char_in == 27)
    31e2:	fd e0       	ldi	r31, 0x0D	; 13
    31e4:	9f 16       	cp	r9, r31
    31e6:	19 f0       	breq	.+6      	; 0x31ee <_ZN9task_user3runEv+0x232>
    31e8:	8b e1       	ldi	r24, 0x1B	; 27
    31ea:	98 12       	cpse	r9, r24
    31ec:	18 c0       	rjmp	.+48     	; 0x321e <_ZN9task_user3runEv+0x262>
					{
						*p_serial << endl << PMS ("Number entered: ") 
    31ee:	66 e0       	ldi	r22, 0x06	; 6
    31f0:	d8 01       	movw	r26, r16
    31f2:	16 96       	adiw	r26, 0x06	; 6
    31f4:	8d 91       	ld	r24, X+
    31f6:	9c 91       	ld	r25, X
    31f8:	17 97       	sbiw	r26, 0x07	; 7
    31fa:	6e da       	rcall	.-2852   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    31fc:	6b e0       	ldi	r22, 0x0B	; 11
    31fe:	6c da       	rcall	.-2856   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    3200:	5c 01       	movw	r10, r24
    3202:	6a ea       	ldi	r22, 0xAA	; 170
    3204:	73 e0       	ldi	r23, 0x03	; 3
    3206:	31 da       	rcall	.-2974   	; 0x266a <_ZN8emstream4putsEPKc>
								  << number_entered << endl;
    3208:	b7 01       	movw	r22, r14
    320a:	a6 01       	movw	r20, r12
    320c:	c5 01       	movw	r24, r10
    320e:	de da       	rcall	.-2628   	; 0x27cc <_ZN8emstreamlsEm>
    3210:	66 e0       	ldi	r22, 0x06	; 6
    3212:	62 da       	rcall	.-2876   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
						transition_to (0);
    3214:	60 e0       	ldi	r22, 0x00	; 0
    3216:	c8 01       	movw	r24, r16
    3218:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <_ZN8TaskBase13transition_toEh>
    321c:	58 c0       	rjmp	.+176    	; 0x32ce <_ZN9task_user3runEv+0x312>
					}
					else
					{
						*p_serial << PMS ("<invalid char \"") << char_in 
    321e:	6b e0       	ldi	r22, 0x0B	; 11
    3220:	f8 01       	movw	r30, r16
    3222:	86 81       	ldd	r24, Z+6	; 0x06
    3224:	97 81       	ldd	r25, Z+7	; 0x07
    3226:	58 da       	rcall	.-2896   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    3228:	5c 01       	movw	r10, r24
    322a:	67 e9       	ldi	r22, 0x97	; 151
    322c:	73 e0       	ldi	r23, 0x03	; 3
    322e:	1d da       	rcall	.-3014   	; 0x266a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3230:	d5 01       	movw	r26, r10
    3232:	ed 91       	ld	r30, X+
    3234:	fc 91       	ld	r31, X
    3236:	02 80       	ldd	r0, Z+2	; 0x02
    3238:	f3 81       	ldd	r31, Z+3	; 0x03
    323a:	e0 2d       	mov	r30, r0
    323c:	69 2d       	mov	r22, r9
    323e:	c5 01       	movw	r24, r10
    3240:	09 95       	icall
								  << PMS ("\">");
    3242:	6b e0       	ldi	r22, 0x0B	; 11
    3244:	c5 01       	movw	r24, r10
    3246:	48 da       	rcall	.-2928   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3248:	67 ea       	ldi	r22, 0xA7	; 167
    324a:	73 e0       	ldi	r23, 0x03	; 3
    324c:	0e da       	rcall	.-3044   	; 0x266a <_ZN8emstream4putsEPKc>
    324e:	3f c0       	rjmp	.+126    	; 0x32ce <_ZN9task_user3runEv+0x312>
					}
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (p_print_ser_queue->check_for_char ())
    3250:	80 91 3c 1a 	lds	r24, 0x1A3C
    3254:	90 91 3d 1a 	lds	r25, 0x1A3D
    3258:	dc 01       	movw	r26, r24
    325a:	ed 91       	ld	r30, X+
    325c:	fc 91       	ld	r31, X
    325e:	04 80       	ldd	r0, Z+4	; 0x04
    3260:	f5 81       	ldd	r31, Z+5	; 0x05
    3262:	e0 2d       	mov	r30, r0
    3264:	09 95       	icall
    3266:	88 23       	and	r24, r24
    3268:	91 f1       	breq	.+100    	; 0x32ce <_ZN9task_user3runEv+0x312>
				{
					p_serial->putchar (p_print_ser_queue->getchar ());
    326a:	d8 01       	movw	r26, r16
    326c:	16 96       	adiw	r26, 0x06	; 6
    326e:	ed 91       	ld	r30, X+
    3270:	fc 91       	ld	r31, X
    3272:	17 97       	sbiw	r26, 0x07	; 7
    3274:	01 90       	ld	r0, Z+
    3276:	f0 81       	ld	r31, Z
    3278:	e0 2d       	mov	r30, r0
    327a:	a2 80       	ldd	r10, Z+2	; 0x02
    327c:	b3 80       	ldd	r11, Z+3	; 0x03
    327e:	80 91 3c 1a 	lds	r24, 0x1A3C
    3282:	90 91 3d 1a 	lds	r25, 0x1A3D
    3286:	dc 01       	movw	r26, r24
    3288:	ed 91       	ld	r30, X+
    328a:	fc 91       	ld	r31, X
    328c:	06 80       	ldd	r0, Z+6	; 0x06
    328e:	f7 81       	ldd	r31, Z+7	; 0x07
    3290:	e0 2d       	mov	r30, r0
    3292:	09 95       	icall
    3294:	68 2f       	mov	r22, r24
    3296:	f8 01       	movw	r30, r16
    3298:	86 81       	ldd	r24, Z+6	; 0x06
    329a:	97 81       	ldd	r25, Z+7	; 0x07
    329c:	f5 01       	movw	r30, r10
    329e:	09 95       	icall
    32a0:	16 c0       	rjmp	.+44     	; 0x32ce <_ZN9task_user3runEv+0x312>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    32a2:	6b e0       	ldi	r22, 0x0B	; 11
    32a4:	86 81       	ldd	r24, Z+6	; 0x06
    32a6:	97 81       	ldd	r25, Z+7	; 0x07
    32a8:	17 da       	rcall	.-3026   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    32aa:	8c 01       	movw	r16, r24
    32ac:	6a e7       	ldi	r22, 0x7A	; 122
    32ae:	73 e0       	ldi	r23, 0x03	; 3
    32b0:	dc d9       	rcall	.-3144   	; 0x266a <_ZN8emstream4putsEPKc>
    32b2:	66 e0       	ldi	r22, 0x06	; 6
    32b4:	c8 01       	movw	r24, r16
    32b6:	10 da       	rcall	.-3040   	; 0x26d8 <_ZN8emstreamlsE15ser_manipulator>
    32b8:	9b e0       	ldi	r25, 0x0B	; 11
    32ba:	88 e1       	ldi	r24, 0x18	; 24
    32bc:	0f b6       	in	r0, 0x3f	; 63
    32be:	f8 94       	cli
    32c0:	a8 95       	wdr
    32c2:	80 93 60 00 	sts	0x0060, r24
    32c6:	0f be       	out	0x3f, r0	; 63
    32c8:	90 93 60 00 	sts	0x0060, r25
				wdt_enable (WDTO_120MS);
				for (;;);
				break;
    32cc:	ff cf       	rjmp	.-2      	; 0x32cc <_ZN9task_user3runEv+0x310>

		} // End switch state

		runs++;                             // Increment counter for debugging
    32ce:	f8 01       	movw	r30, r16
    32d0:	86 85       	ldd	r24, Z+14	; 0x0e
    32d2:	97 85       	ldd	r25, Z+15	; 0x0f
    32d4:	a0 89       	ldd	r26, Z+16	; 0x10
    32d6:	b1 89       	ldd	r27, Z+17	; 0x11
    32d8:	01 96       	adiw	r24, 0x01	; 1
    32da:	a1 1d       	adc	r26, r1
    32dc:	b1 1d       	adc	r27, r1
    32de:	86 87       	std	Z+14, r24	; 0x0e
    32e0:	97 87       	std	Z+15, r25	; 0x0f
    32e2:	a0 8b       	std	Z+16, r26	; 0x10
    32e4:	b1 8b       	std	Z+17, r27	; 0x11
		 *  @param   duration_ms The duration for the task to stop in milliseconds
		 */
		void delay_ms (TickType_t duration_ms)
		{
			TickType_t ticks = ((uint32_t)duration_ms * configTICK_RATE_HZ) / 1000UL;
            vTaskDelay (ticks);
    32e6:	61 e0       	ldi	r22, 0x01	; 1
    32e8:	70 e0       	ldi	r23, 0x00	; 0
    32ea:	80 e0       	ldi	r24, 0x00	; 0
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	0e 94 c5 0b 	call	0x178a	; 0x178a <vTaskDelay>
    32f2:	87 ce       	rjmp	.-754    	; 0x3002 <_ZN9task_user3runEv+0x46>

000032f4 <__mulsi3>:
    32f4:	db 01       	movw	r26, r22
    32f6:	8f 93       	push	r24
    32f8:	9f 93       	push	r25
    32fa:	66 d0       	rcall	.+204    	; 0x33c8 <__muluhisi3>
    32fc:	bf 91       	pop	r27
    32fe:	af 91       	pop	r26
    3300:	a2 9f       	mul	r26, r18
    3302:	80 0d       	add	r24, r0
    3304:	91 1d       	adc	r25, r1
    3306:	a3 9f       	mul	r26, r19
    3308:	90 0d       	add	r25, r0
    330a:	b2 9f       	mul	r27, r18
    330c:	90 0d       	add	r25, r0
    330e:	11 24       	eor	r1, r1
    3310:	08 95       	ret

00003312 <__udivmodhi4>:
    3312:	aa 1b       	sub	r26, r26
    3314:	bb 1b       	sub	r27, r27
    3316:	51 e1       	ldi	r21, 0x11	; 17
    3318:	07 c0       	rjmp	.+14     	; 0x3328 <__udivmodhi4_ep>

0000331a <__udivmodhi4_loop>:
    331a:	aa 1f       	adc	r26, r26
    331c:	bb 1f       	adc	r27, r27
    331e:	a6 17       	cp	r26, r22
    3320:	b7 07       	cpc	r27, r23
    3322:	10 f0       	brcs	.+4      	; 0x3328 <__udivmodhi4_ep>
    3324:	a6 1b       	sub	r26, r22
    3326:	b7 0b       	sbc	r27, r23

00003328 <__udivmodhi4_ep>:
    3328:	88 1f       	adc	r24, r24
    332a:	99 1f       	adc	r25, r25
    332c:	5a 95       	dec	r21
    332e:	a9 f7       	brne	.-22     	; 0x331a <__udivmodhi4_loop>
    3330:	80 95       	com	r24
    3332:	90 95       	com	r25
    3334:	bc 01       	movw	r22, r24
    3336:	cd 01       	movw	r24, r26
    3338:	08 95       	ret

0000333a <__udivmodsi4>:
    333a:	a1 e2       	ldi	r26, 0x21	; 33
    333c:	1a 2e       	mov	r1, r26
    333e:	aa 1b       	sub	r26, r26
    3340:	bb 1b       	sub	r27, r27
    3342:	fd 01       	movw	r30, r26
    3344:	0d c0       	rjmp	.+26     	; 0x3360 <__udivmodsi4_ep>

00003346 <__udivmodsi4_loop>:
    3346:	aa 1f       	adc	r26, r26
    3348:	bb 1f       	adc	r27, r27
    334a:	ee 1f       	adc	r30, r30
    334c:	ff 1f       	adc	r31, r31
    334e:	a2 17       	cp	r26, r18
    3350:	b3 07       	cpc	r27, r19
    3352:	e4 07       	cpc	r30, r20
    3354:	f5 07       	cpc	r31, r21
    3356:	20 f0       	brcs	.+8      	; 0x3360 <__udivmodsi4_ep>
    3358:	a2 1b       	sub	r26, r18
    335a:	b3 0b       	sbc	r27, r19
    335c:	e4 0b       	sbc	r30, r20
    335e:	f5 0b       	sbc	r31, r21

00003360 <__udivmodsi4_ep>:
    3360:	66 1f       	adc	r22, r22
    3362:	77 1f       	adc	r23, r23
    3364:	88 1f       	adc	r24, r24
    3366:	99 1f       	adc	r25, r25
    3368:	1a 94       	dec	r1
    336a:	69 f7       	brne	.-38     	; 0x3346 <__udivmodsi4_loop>
    336c:	60 95       	com	r22
    336e:	70 95       	com	r23
    3370:	80 95       	com	r24
    3372:	90 95       	com	r25
    3374:	9b 01       	movw	r18, r22
    3376:	ac 01       	movw	r20, r24
    3378:	bd 01       	movw	r22, r26
    337a:	cf 01       	movw	r24, r30
    337c:	08 95       	ret

0000337e <__divmodsi4>:
    337e:	05 2e       	mov	r0, r21
    3380:	97 fb       	bst	r25, 7
    3382:	16 f4       	brtc	.+4      	; 0x3388 <__divmodsi4+0xa>
    3384:	00 94       	com	r0
    3386:	0f d0       	rcall	.+30     	; 0x33a6 <__negsi2>
    3388:	57 fd       	sbrc	r21, 7
    338a:	05 d0       	rcall	.+10     	; 0x3396 <__divmodsi4_neg2>
    338c:	d6 df       	rcall	.-84     	; 0x333a <__udivmodsi4>
    338e:	07 fc       	sbrc	r0, 7
    3390:	02 d0       	rcall	.+4      	; 0x3396 <__divmodsi4_neg2>
    3392:	46 f4       	brtc	.+16     	; 0x33a4 <__divmodsi4_exit>
    3394:	08 c0       	rjmp	.+16     	; 0x33a6 <__negsi2>

00003396 <__divmodsi4_neg2>:
    3396:	50 95       	com	r21
    3398:	40 95       	com	r20
    339a:	30 95       	com	r19
    339c:	21 95       	neg	r18
    339e:	3f 4f       	sbci	r19, 0xFF	; 255
    33a0:	4f 4f       	sbci	r20, 0xFF	; 255
    33a2:	5f 4f       	sbci	r21, 0xFF	; 255

000033a4 <__divmodsi4_exit>:
    33a4:	08 95       	ret

000033a6 <__negsi2>:
    33a6:	90 95       	com	r25
    33a8:	80 95       	com	r24
    33aa:	70 95       	com	r23
    33ac:	61 95       	neg	r22
    33ae:	7f 4f       	sbci	r23, 0xFF	; 255
    33b0:	8f 4f       	sbci	r24, 0xFF	; 255
    33b2:	9f 4f       	sbci	r25, 0xFF	; 255
    33b4:	08 95       	ret

000033b6 <__tablejump2__>:
    33b6:	ee 0f       	add	r30, r30
    33b8:	ff 1f       	adc	r31, r31
    33ba:	00 24       	eor	r0, r0
    33bc:	00 1c       	adc	r0, r0
    33be:	0b be       	out	0x3b, r0	; 59
    33c0:	07 90       	elpm	r0, Z+
    33c2:	f6 91       	elpm	r31, Z
    33c4:	e0 2d       	mov	r30, r0
    33c6:	09 94       	ijmp

000033c8 <__muluhisi3>:
    33c8:	09 d0       	rcall	.+18     	; 0x33dc <__umulhisi3>
    33ca:	a5 9f       	mul	r26, r21
    33cc:	90 0d       	add	r25, r0
    33ce:	b4 9f       	mul	r27, r20
    33d0:	90 0d       	add	r25, r0
    33d2:	a4 9f       	mul	r26, r20
    33d4:	80 0d       	add	r24, r0
    33d6:	91 1d       	adc	r25, r1
    33d8:	11 24       	eor	r1, r1
    33da:	08 95       	ret

000033dc <__umulhisi3>:
    33dc:	a2 9f       	mul	r26, r18
    33de:	b0 01       	movw	r22, r0
    33e0:	b3 9f       	mul	r27, r19
    33e2:	c0 01       	movw	r24, r0
    33e4:	a3 9f       	mul	r26, r19
    33e6:	70 0d       	add	r23, r0
    33e8:	81 1d       	adc	r24, r1
    33ea:	11 24       	eor	r1, r1
    33ec:	91 1d       	adc	r25, r1
    33ee:	b2 9f       	mul	r27, r18
    33f0:	70 0d       	add	r23, r0
    33f2:	81 1d       	adc	r24, r1
    33f4:	11 24       	eor	r1, r1
    33f6:	91 1d       	adc	r25, r1
    33f8:	08 95       	ret

000033fa <memcpy>:
    33fa:	fb 01       	movw	r30, r22
    33fc:	dc 01       	movw	r26, r24
    33fe:	02 c0       	rjmp	.+4      	; 0x3404 <memcpy+0xa>
    3400:	01 90       	ld	r0, Z+
    3402:	0d 92       	st	X+, r0
    3404:	41 50       	subi	r20, 0x01	; 1
    3406:	50 40       	sbci	r21, 0x00	; 0
    3408:	d8 f7       	brcc	.-10     	; 0x3400 <memcpy+0x6>
    340a:	08 95       	ret

0000340c <memset>:
    340c:	dc 01       	movw	r26, r24
    340e:	01 c0       	rjmp	.+2      	; 0x3412 <memset+0x6>
    3410:	6d 93       	st	X+, r22
    3412:	41 50       	subi	r20, 0x01	; 1
    3414:	50 40       	sbci	r21, 0x00	; 0
    3416:	e0 f7       	brcc	.-8      	; 0x3410 <memset+0x4>
    3418:	08 95       	ret

0000341a <strncpy>:
    341a:	fb 01       	movw	r30, r22
    341c:	dc 01       	movw	r26, r24
    341e:	41 50       	subi	r20, 0x01	; 1
    3420:	50 40       	sbci	r21, 0x00	; 0
    3422:	48 f0       	brcs	.+18     	; 0x3436 <strncpy+0x1c>
    3424:	01 90       	ld	r0, Z+
    3426:	0d 92       	st	X+, r0
    3428:	00 20       	and	r0, r0
    342a:	c9 f7       	brne	.-14     	; 0x341e <strncpy+0x4>
    342c:	01 c0       	rjmp	.+2      	; 0x3430 <strncpy+0x16>
    342e:	1d 92       	st	X+, r1
    3430:	41 50       	subi	r20, 0x01	; 1
    3432:	50 40       	sbci	r21, 0x00	; 0
    3434:	e0 f7       	brcc	.-8      	; 0x342e <strncpy+0x14>
    3436:	08 95       	ret

00003438 <ultoa>:
    3438:	25 32       	cpi	r18, 0x25	; 37
    343a:	31 05       	cpc	r19, r1
    343c:	18 f4       	brcc	.+6      	; 0x3444 <ultoa+0xc>
    343e:	22 30       	cpi	r18, 0x02	; 2
    3440:	08 f0       	brcs	.+2      	; 0x3444 <ultoa+0xc>
    3442:	04 c0       	rjmp	.+8      	; 0x344c <__ultoa_ncheck>
    3444:	fa 01       	movw	r30, r20
    3446:	10 82       	st	Z, r1
    3448:	ca 01       	movw	r24, r20
    344a:	08 95       	ret

0000344c <__ultoa_ncheck>:
    344c:	bb 27       	eor	r27, r27

0000344e <__ultoa_common>:
    344e:	fa 01       	movw	r30, r20
    3450:	a6 2f       	mov	r26, r22
    3452:	62 17       	cp	r22, r18
    3454:	71 05       	cpc	r23, r1
    3456:	81 05       	cpc	r24, r1
    3458:	91 05       	cpc	r25, r1
    345a:	33 0b       	sbc	r19, r19
    345c:	30 fb       	bst	r19, 0
    345e:	66 f0       	brts	.+24     	; 0x3478 <__ultoa_common+0x2a>
    3460:	aa 27       	eor	r26, r26
    3462:	66 0f       	add	r22, r22
    3464:	77 1f       	adc	r23, r23
    3466:	88 1f       	adc	r24, r24
    3468:	99 1f       	adc	r25, r25
    346a:	aa 1f       	adc	r26, r26
    346c:	a2 17       	cp	r26, r18
    346e:	10 f0       	brcs	.+4      	; 0x3474 <__ultoa_common+0x26>
    3470:	a2 1b       	sub	r26, r18
    3472:	63 95       	inc	r22
    3474:	38 50       	subi	r19, 0x08	; 8
    3476:	a9 f7       	brne	.-22     	; 0x3462 <__ultoa_common+0x14>
    3478:	a0 5d       	subi	r26, 0xD0	; 208
    347a:	aa 33       	cpi	r26, 0x3A	; 58
    347c:	08 f0       	brcs	.+2      	; 0x3480 <__ultoa_common+0x32>
    347e:	a9 5d       	subi	r26, 0xD9	; 217
    3480:	a1 93       	st	Z+, r26
    3482:	36 f7       	brtc	.-52     	; 0x3450 <__ultoa_common+0x2>
    3484:	b1 11       	cpse	r27, r1
    3486:	b1 93       	st	Z+, r27
    3488:	10 82       	st	Z, r1
    348a:	ca 01       	movw	r24, r20
    348c:	23 c0       	rjmp	.+70     	; 0x34d4 <strrev>

0000348e <utoa>:
    348e:	45 32       	cpi	r20, 0x25	; 37
    3490:	51 05       	cpc	r21, r1
    3492:	18 f4       	brcc	.+6      	; 0x349a <utoa+0xc>
    3494:	42 30       	cpi	r20, 0x02	; 2
    3496:	08 f0       	brcs	.+2      	; 0x349a <utoa+0xc>
    3498:	04 c0       	rjmp	.+8      	; 0x34a2 <__utoa_ncheck>
    349a:	fb 01       	movw	r30, r22
    349c:	10 82       	st	Z, r1
    349e:	cb 01       	movw	r24, r22
    34a0:	08 95       	ret

000034a2 <__utoa_ncheck>:
    34a2:	bb 27       	eor	r27, r27

000034a4 <__utoa_common>:
    34a4:	fb 01       	movw	r30, r22
    34a6:	55 27       	eor	r21, r21
    34a8:	aa 27       	eor	r26, r26
    34aa:	88 0f       	add	r24, r24
    34ac:	99 1f       	adc	r25, r25
    34ae:	aa 1f       	adc	r26, r26
    34b0:	a4 17       	cp	r26, r20
    34b2:	10 f0       	brcs	.+4      	; 0x34b8 <__utoa_common+0x14>
    34b4:	a4 1b       	sub	r26, r20
    34b6:	83 95       	inc	r24
    34b8:	50 51       	subi	r21, 0x10	; 16
    34ba:	b9 f7       	brne	.-18     	; 0x34aa <__utoa_common+0x6>
    34bc:	a0 5d       	subi	r26, 0xD0	; 208
    34be:	aa 33       	cpi	r26, 0x3A	; 58
    34c0:	08 f0       	brcs	.+2      	; 0x34c4 <__utoa_common+0x20>
    34c2:	a9 5d       	subi	r26, 0xD9	; 217
    34c4:	a1 93       	st	Z+, r26
    34c6:	00 97       	sbiw	r24, 0x00	; 0
    34c8:	79 f7       	brne	.-34     	; 0x34a8 <__utoa_common+0x4>
    34ca:	b1 11       	cpse	r27, r1
    34cc:	b1 93       	st	Z+, r27
    34ce:	11 92       	st	Z+, r1
    34d0:	cb 01       	movw	r24, r22
    34d2:	00 c0       	rjmp	.+0      	; 0x34d4 <strrev>

000034d4 <strrev>:
    34d4:	dc 01       	movw	r26, r24
    34d6:	fc 01       	movw	r30, r24
    34d8:	67 2f       	mov	r22, r23
    34da:	71 91       	ld	r23, Z+
    34dc:	77 23       	and	r23, r23
    34de:	e1 f7       	brne	.-8      	; 0x34d8 <strrev+0x4>
    34e0:	32 97       	sbiw	r30, 0x02	; 2
    34e2:	04 c0       	rjmp	.+8      	; 0x34ec <strrev+0x18>
    34e4:	7c 91       	ld	r23, X
    34e6:	6d 93       	st	X+, r22
    34e8:	70 83       	st	Z, r23
    34ea:	62 91       	ld	r22, -Z
    34ec:	ae 17       	cp	r26, r30
    34ee:	bf 07       	cpc	r27, r31
    34f0:	c8 f3       	brcs	.-14     	; 0x34e4 <strrev+0x10>
    34f2:	08 95       	ret

000034f4 <_exit>:
    34f4:	f8 94       	cli

000034f6 <__stop_program>:
    34f6:	ff cf       	rjmp	.-2      	; 0x34f6 <__stop_program>
