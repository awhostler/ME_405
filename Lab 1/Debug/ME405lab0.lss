
ME405lab0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000084  00800200  0000344c  000034e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000344c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000017ba  00800284  00800284  00003564  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003564  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003594  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000658  00000000  00000000  000035d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000acc8  00000000  00000000  00003c2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003714  00000000  00000000  0000e8f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000437c  00000000  00000000  00012008  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000122c  00000000  00000000  00016384  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000266c  00000000  00000000  000175b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005f4f  00000000  00000000  00019c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000528  00000000  00000000  0001fb6b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f6 c1       	rjmp	.+1004   	; 0x3ee <__ctors_end>
       2:	00 00       	nop
       4:	13 c2       	rjmp	.+1062   	; 0x42c <__bad_interrupt>
       6:	00 00       	nop
       8:	11 c2       	rjmp	.+1058   	; 0x42c <__bad_interrupt>
       a:	00 00       	nop
       c:	0f c2       	rjmp	.+1054   	; 0x42c <__bad_interrupt>
       e:	00 00       	nop
      10:	0d c2       	rjmp	.+1050   	; 0x42c <__bad_interrupt>
      12:	00 00       	nop
      14:	0b c2       	rjmp	.+1046   	; 0x42c <__bad_interrupt>
      16:	00 00       	nop
      18:	09 c2       	rjmp	.+1042   	; 0x42c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	07 c2       	rjmp	.+1038   	; 0x42c <__bad_interrupt>
      1e:	00 00       	nop
      20:	05 c2       	rjmp	.+1034   	; 0x42c <__bad_interrupt>
      22:	00 00       	nop
      24:	03 c2       	rjmp	.+1030   	; 0x42c <__bad_interrupt>
      26:	00 00       	nop
      28:	01 c2       	rjmp	.+1026   	; 0x42c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	ff c1       	rjmp	.+1022   	; 0x42c <__bad_interrupt>
      2e:	00 00       	nop
      30:	fd c1       	rjmp	.+1018   	; 0x42c <__bad_interrupt>
      32:	00 00       	nop
      34:	fb c1       	rjmp	.+1014   	; 0x42c <__bad_interrupt>
      36:	00 00       	nop
      38:	f9 c1       	rjmp	.+1010   	; 0x42c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f7 c1       	rjmp	.+1006   	; 0x42c <__bad_interrupt>
      3e:	00 00       	nop
      40:	f5 c1       	rjmp	.+1002   	; 0x42c <__bad_interrupt>
      42:	00 00       	nop
      44:	f3 c1       	rjmp	.+998    	; 0x42c <__bad_interrupt>
      46:	00 00       	nop
      48:	f1 c1       	rjmp	.+994    	; 0x42c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ef c1       	rjmp	.+990    	; 0x42c <__bad_interrupt>
      4e:	00 00       	nop
      50:	ed c1       	rjmp	.+986    	; 0x42c <__bad_interrupt>
      52:	00 00       	nop
      54:	eb c1       	rjmp	.+982    	; 0x42c <__bad_interrupt>
      56:	00 00       	nop
      58:	e9 c1       	rjmp	.+978    	; 0x42c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e7 c1       	rjmp	.+974    	; 0x42c <__bad_interrupt>
      5e:	00 00       	nop
      60:	e5 c1       	rjmp	.+970    	; 0x42c <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 26 15 	jmp	0x2a4c	; 0x2a4c <__vector_25>
      68:	e1 c1       	rjmp	.+962    	; 0x42c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	df c1       	rjmp	.+958    	; 0x42c <__bad_interrupt>
      6e:	00 00       	nop
      70:	dd c1       	rjmp	.+954    	; 0x42c <__bad_interrupt>
      72:	00 00       	nop
      74:	db c1       	rjmp	.+950    	; 0x42c <__bad_interrupt>
      76:	00 00       	nop
      78:	d9 c1       	rjmp	.+946    	; 0x42c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d7 c1       	rjmp	.+942    	; 0x42c <__bad_interrupt>
      7e:	00 00       	nop
      80:	d5 c1       	rjmp	.+938    	; 0x42c <__bad_interrupt>
      82:	00 00       	nop
      84:	d3 c1       	rjmp	.+934    	; 0x42c <__bad_interrupt>
      86:	00 00       	nop
      88:	d1 c1       	rjmp	.+930    	; 0x42c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cf c1       	rjmp	.+926    	; 0x42c <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 7e 15 	jmp	0x2afc	; 0x2afc <__vector_36>
      94:	cb c1       	rjmp	.+918    	; 0x42c <__bad_interrupt>
      96:	00 00       	nop
      98:	c9 c1       	rjmp	.+914    	; 0x42c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c7 c1       	rjmp	.+910    	; 0x42c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c5 c1       	rjmp	.+906    	; 0x42c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c3 c1       	rjmp	.+902    	; 0x42c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	c1 c1       	rjmp	.+898    	; 0x42c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bf c1       	rjmp	.+894    	; 0x42c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	bd c1       	rjmp	.+890    	; 0x42c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	bb c1       	rjmp	.+886    	; 0x42c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b9 c1       	rjmp	.+882    	; 0x42c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	ef c4       	rjmp	.+2526   	; 0xa9c <__vector_47>
      be:	00 00       	nop
      c0:	b5 c1       	rjmp	.+874    	; 0x42c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b3 c1       	rjmp	.+870    	; 0x42c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	b1 c1       	rjmp	.+866    	; 0x42c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	1e 13       	cpse	r17, r30
      ce:	21 13       	cpse	r18, r17
      d0:	24 13       	cpse	r18, r20
      d2:	27 13       	cpse	r18, r23
      d4:	52 13       	cpse	r21, r18
      d6:	52 13       	cpse	r21, r18
      d8:	2a 13       	cpse	r18, r26
      da:	3a 13       	cpse	r19, r26
      dc:	41 13       	cpse	r20, r17
      de:	4b 13       	cpse	r20, r27
      e0:	4f 13       	cpse	r20, r31
      e2:	48 13       	cpse	r20, r24

000000e4 <__trampolines_end>:
      e4:	4e 6f       	ori	r20, 0xFE	; 254
      e6:	20 73       	andi	r18, 0x30	; 48
      e8:	68 61       	ori	r22, 0x18	; 24
      ea:	72 65       	ori	r23, 0x52	; 82
      ec:	64 20       	and	r6, r4
      ee:	64 61       	ori	r22, 0x14	; 20
      f0:	74 61       	ori	r23, 0x14	; 20
      f2:	20 69       	ori	r18, 0x90	; 144
      f4:	74 65       	ori	r23, 0x54	; 84
      f6:	6d 73       	andi	r22, 0x3D	; 61
      f8:	20 74       	andi	r18, 0x40	; 64
      fa:	6f 20       	and	r6, r15
      fc:	70 72       	andi	r23, 0x20	; 32
      fe:	69 6e       	ori	r22, 0xE9	; 233
     100:	74 00       	.word	0x0074	; ????

00000102 <_ZZ16print_all_sharesP8emstreamE3__c_0>:
     102:	2d 2d 2d 2d 20 20 20 20 20 20 20 20 20 20 20 20     ----            
     112:	2d 2d 2d 2d 20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d     ----    --------
     122:	2d 2d 00                                            --.

00000125 <_ZZ16print_all_sharesP8emstreamE3__c>:
     125:	53 68 61 72 65 2f 51 75 65 75 65 20 20 20 20 20     Share/Queue     
     135:	54 79 70 65 20 20 20 20 46 72 65 65 2f 54 6f 74     Type    Free/Tot
     145:	61 6c 00                                            al.

00000148 <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c_1>:
     148:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     158:	61 73 6b 20 22 00                                   ask ".

0000015e <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c>:
     15e:	54 61 73 6b 20 22 00                                Task ".

00000165 <_ZZN8TaskBaseC4EPKchjP8emstreamE3__c_0>:
     165:	22 20 63 72 65 61 74 65 64 2c 20 73 74 61 63 6b     " created, stack
     175:	20 61 74 20 30 78 00                                 at 0x.

0000017c <_ZZN8TaskBase19print_stack_in_listEP8emstreamE3__c>:
     17c:	54 61 73 6b 3a 20 00                                Task: .

00000183 <_ZZ17print_task_stacksP8emstreamE3__c>:
     183:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

0000018e <_ZZ15print_task_listP8emstreamE3__c_7>:
     18e:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

00000199 <_ZZ15print_task_listP8emstreamE3__c_8>:
     199:	2f 00                                               /.

0000019b <_ZZ15print_task_listP8emstreamE3__c_9>:
     19b:	09 09 2d 00                                         ..-.

0000019f <_ZZ15print_task_listP8emstreamE3__c_4>:
     19f:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000001b0 <_ZZ15print_task_listP8emstreamE3__c_5>:
     1b0:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000001bc <_ZZ15print_task_listP8emstreamE3__c_6>:
     1bc:	09 2d 2d 2d 2d 00                                   .----.

000001c2 <_ZZ15print_task_listP8emstreamE3__c_1>:
     1c2:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000001d3 <_ZZ15print_task_listP8emstreamE3__c_2>:
     1d3:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000001df <_ZZ15print_task_listP8emstreamE3__c_3>:
     1df:	09 52 75 6e 73 00                                   .Runs.

000001e5 <_ZZ15print_task_listP8emstreamE3__c>:
     1e5:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000001f0 <_ZZ15print_task_listP8emstreamE3__c_0>:
     1f0:	09 53 74 61 63 6b 00                                .Stack.

000001f7 <_ZZN8TaskBase12print_statusER8emstreamE3__c>:
     1f7:	09 00                                               ..

000001f9 <_ZZN8TaskBase12print_statusER8emstreamE3__c_0>:
     1f9:	09 00                                               ..

000001fb <_ZZN8TaskBase12print_statusER8emstreamE3__c_1>:
     1fb:	2f 00                                               /.

000001fd <_ZZN8TaskBase12print_statusER8emstreamE3__c_2>:
     1fd:	09 00                                               ..

000001ff <_ZZN8TaskBase12print_statusER8emstreamE3__c_3>:
     1ff:	09 00                                               ..

00000201 <_ZZ15hex_dump_memoryPhS_P8emstreamE3__c>:
     201:	20 20 00                                              .

00000204 <_ZZ4mainE3__c>:
     204:	4d 45 34 30 35 20 4c 61 62 20 31 20 53 74 61 72     ME405 Lab 1 Star
     214:	74 69 6e 67 20 50 72 6f 67 72 61 6d 00              ting Program.

00000221 <_ZZN9task_user11show_statusEvE3__c>:
     221:	4d 45 34 30 35 20 4c 61 62 20 31 20 55 6e 6d 6f     ME405 Lab 1 Unmo
     231:	64 69 66 69 65 64 20 50 72 6f 67 72 61 6d 20 56     dified Program V
     241:	30 2e 30 31 20 00                                   0.01 .

00000247 <_ZZN9task_user11show_statusEvE3__c_0>:
     247:	4d 61 72 20 33 30 20 32 30 31 36 00                 Mar 30 2016.

00000253 <_ZZN9task_user11show_statusEvE3__c_1>:
     253:	53 79 73 74 65 6d 20 74 69 6d 65 3a 20 00           System time: .

00000261 <_ZZN9task_user11show_statusEvE3__c_2>:
     261:	2c 20 48 65 61 70 3a 20 00                          , Heap: .

0000026a <_ZZN9task_user11show_statusEvE3__c_3>:
     26a:	2c 20 4f 43 52 35 41 3a 20 00                       , OCR5A: .

00000274 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     274:	20 20 68 3a 20 20 20 20 20 48 41 4c 50 21 00          h:     HALP!.

00000283 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     283:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     293:	68 65 20 41 56 52 00                                he AVR.

0000029a <_ZZN9task_user18print_help_messageEvE3__c_4>:
     29a:	20 20 6e 3a 20 20 20 20 20 45 6e 74 65 72 20 61       n:     Enter a
     2aa:	20 6e 75 6d 62 65 72 20 28 64 65 6d 6f 29 00         number (demo).

000002b9 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     2b9:	20 20 64 3a 20 20 20 20 20 53 74 61 63 6b 20 64       d:     Stack d
     2c9:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000002d7 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     2d7:	20 20 73 3a 20 20 20 20 20 56 65 72 73 69 6f 6e       s:     Version
     2e7:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     2f7:	6d 61 74 69 6f 6e 00                                mation.

000002fe <_ZZN9task_user18print_help_messageEvE3__c_1>:
     2fe:	20 20 74 3a 20 20 20 20 20 53 68 6f 77 20 74 68       t:     Show th
     30e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000031f <_ZZN9task_user18print_help_messageEvE3__c>:
     31f:	4d 45 34 30 35 20 4c 61 62 20 31 20 55 6e 6d 6f     ME405 Lab 1 Unmo
     32f:	64 69 66 69 65 64 20 50 72 6f 67 72 61 6d 20 56     dified Program V
     33f:	30 2e 30 31 20 00                                   0.01 .

00000345 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     345:	20 68 65 6c 70 00                                    help.

0000034b <_ZZN9task_user3runEvE3__c_6>:
     34b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     35b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000368 <_ZZN9task_user3runEvE3__c_4>:
     368:	3c 69 6e 76 61 6c 69 64 20 63 68 61 72 20 22 00     <invalid char ".

00000378 <_ZZN9task_user3runEvE3__c_5>:
     378:	22 3e 00                                            ">.

0000037b <_ZZN9task_user3runEvE3__c_3>:
     37b:	4e 75 6d 62 65 72 20 65 6e 74 65 72 65 64 3a 20     Number entered: 
	...

0000038c <_ZZN9task_user3runEvE3__c_2>:
     38c:	22 3a 20 57 54 46 3f 00                             ": WTF?.

00000394 <_ZZN9task_user3runEvE3__c_1>:
     394:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000003a2 <_ZZN9task_user3runEvE3__c_0>:
     3a2:	45 6e 74 65 72 20 64 65 63 69 6d 61 6c 20 6e 75     Enter decimal nu
     3b2:	6d 65 72 69 63 20 64 69 67 69 74 73 2c 20 74 68     meric digits, th
     3c2:	65 6e 20 52 45 54 55 52 4e 20 6f 72 20 45 53 43     en RETURN or ESC
	...

000003d3 <_ZZN9task_user3runEvE3__c>:
     3d3:	50 72 65 73 73 20 27 68 27 20 6f 72 20 27 3f 27     Press 'h' or '?'
     3e3:	20 66 6f 72 20 68 65 6c 70 00 00                     for help..

000003ee <__ctors_end>:
     3ee:	11 24       	eor	r1, r1
     3f0:	1f be       	out	0x3f, r1	; 63
     3f2:	cf ef       	ldi	r28, 0xFF	; 255
     3f4:	d1 e2       	ldi	r29, 0x21	; 33
     3f6:	de bf       	out	0x3e, r29	; 62
     3f8:	cd bf       	out	0x3d, r28	; 61

000003fa <__do_copy_data>:
     3fa:	12 e0       	ldi	r17, 0x02	; 2
     3fc:	a0 e0       	ldi	r26, 0x00	; 0
     3fe:	b2 e0       	ldi	r27, 0x02	; 2
     400:	ec e4       	ldi	r30, 0x4C	; 76
     402:	f4 e3       	ldi	r31, 0x34	; 52
     404:	00 e0       	ldi	r16, 0x00	; 0
     406:	0b bf       	out	0x3b, r16	; 59
     408:	02 c0       	rjmp	.+4      	; 0x40e <__do_copy_data+0x14>
     40a:	07 90       	elpm	r0, Z+
     40c:	0d 92       	st	X+, r0
     40e:	a4 38       	cpi	r26, 0x84	; 132
     410:	b1 07       	cpc	r27, r17
     412:	d9 f7       	brne	.-10     	; 0x40a <__do_copy_data+0x10>

00000414 <__do_clear_bss>:
     414:	2a e1       	ldi	r18, 0x1A	; 26
     416:	a4 e8       	ldi	r26, 0x84	; 132
     418:	b2 e0       	ldi	r27, 0x02	; 2
     41a:	01 c0       	rjmp	.+2      	; 0x41e <.do_clear_bss_start>

0000041c <.do_clear_bss_loop>:
     41c:	1d 92       	st	X+, r1

0000041e <.do_clear_bss_start>:
     41e:	ae 33       	cpi	r26, 0x3E	; 62
     420:	b2 07       	cpc	r27, r18
     422:	e1 f7       	brne	.-8      	; 0x41c <.do_clear_bss_loop>
     424:	0e 94 d6 15 	call	0x2bac	; 0x2bac <main>
     428:	0c 94 24 1a 	jmp	0x3448	; 0x3448 <_exit>

0000042c <__bad_interrupt>:
     42c:	e9 cd       	rjmp	.-1070   	; 0x0 <__vectors>

0000042e <_ZN3adcC1EP8emstream>:
 *  @param p_serial_port A pointer to the serial port which writes debugging info. 
 */

adc::adc (emstream* p_serial_port)
{
	ptr_to_serial = p_serial_port;
     42e:	fc 01       	movw	r30, r24
     430:	71 83       	std	Z+1, r23	; 0x01
     432:	60 83       	st	Z, r22
	// Do A/D configuration in weird non-readable ways. The student's job is to redo 
	// this by writing good, readable, sensible code rather than obfuscated malarkey.
	//
	// Please do NOT waste time trying to reverse engineer this code; doing so is a
	// complete waste of time! It's easier and quicker to start from scratch. 
	ADMUX = 0b00000000; //clear settings
     434:	ec e7       	ldi	r30, 0x7C	; 124
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	10 82       	st	Z, r1
	ADMUX |= (1<<REFS0); // SETS COMPARATOR REFERENCE TO VCC
     43a:	80 81       	ld	r24, Z
     43c:	80 64       	ori	r24, 0x40	; 64
     43e:	80 83       	st	Z, r24
	
	ADCSRA= (0b00000000)|(1<<ADEN); // Clear settings, but enable A/D converter hardware
     440:	ea e7       	ldi	r30, 0x7A	; 122
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	80 e8       	ldi	r24, 0x80	; 128
     446:	80 83       	st	Z, r24
	ADCSRA|= (1<<ADPS0)|(1<<ADPS2); // Set A/D clock prescaler to 32
     448:	80 81       	ld	r24, Z
     44a:	85 60       	ori	r24, 0x05	; 5
     44c:	80 83       	st	Z, r24
     44e:	08 95       	ret

00000450 <_ZN3adc9read_onceEh>:
uint16_t adc::read_once (uint8_t ch)
{
	// Since writing A/D code is part of an assignment, here's an undocumented mess. 
	// The student's job is to read the ATmegaXX documentation and write this properly.
	//
	if(!(ch&0b00001111))DBG (ptr_to_serial, "A/D input invalid" << endl); // Check input is valid
     450:	86 2f       	mov	r24, r22
     452:	8f 70       	andi	r24, 0x0F	; 15
     454:	09 f0       	breq	.+2      	; 0x458 <_ZN3adc9read_onceEh+0x8>
	else ch &= 0b00001111; // Mask 4 lsb of input (just in case)
     456:	68 2f       	mov	r22, r24
	ADMUX &= ~(1<<MUX0|1<<MUX1|1<<MUX2|1<<MUX3); //Change mux selection to zero 
     458:	ec e7       	ldi	r30, 0x7C	; 124
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	80 81       	ld	r24, Z
     45e:	80 7f       	andi	r24, 0xF0	; 240
     460:	80 83       	st	Z, r24
	ADMUX = (ADMUX&0b11100000)|ch; //Set lower bits of ADMUX to match input
     462:	80 81       	ld	r24, Z
     464:	80 7e       	andi	r24, 0xE0	; 224
     466:	68 2b       	or	r22, r24
     468:	60 83       	st	Z, r22
	ADCSRA &= ~(1<<ADATE); //turn off conversion triggering
     46a:	ea e7       	ldi	r30, 0x7A	; 122
     46c:	f0 e0       	ldi	r31, 0x00	; 0
     46e:	80 81       	ld	r24, Z
     470:	8f 7d       	andi	r24, 0xDF	; 223
     472:	80 83       	st	Z, r24
	
	ADCSRA |= (1<<ADSC); //use ADSC to start conversion
     474:	80 81       	ld	r24, Z
     476:	80 64       	ori	r24, 0x40	; 64
     478:	80 83       	st	Z, r24
	
	while((time<10000)&&(ADCSRA&(~1<<ADSC)))
     47a:	20 91 84 02 	lds	r18, 0x0284
     47e:	30 91 85 02 	lds	r19, 0x0285
     482:	20 31       	cpi	r18, 0x10	; 16
     484:	87 e2       	ldi	r24, 0x27	; 39
     486:	38 07       	cpc	r19, r24
     488:	2c f4       	brge	.+10     	; 0x494 <_ZN3adc9read_onceEh+0x44>
     48a:	80 81       	ld	r24, Z
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	80 78       	andi	r24, 0x80	; 128
     490:	89 2b       	or	r24, r25
     492:	b9 f7       	brne	.-18     	; 0x482 <_ZN3adc9read_onceEh+0x32>
	{
	;
	}
	
	return (ADCH<<8)|(ADCL);
     494:	20 91 79 00 	lds	r18, 0x0079
     498:	80 91 78 00 	lds	r24, 0x0078
     49c:	90 e0       	ldi	r25, 0x00	; 0
	 
	// voltage = VCC * adc / 1024
	
	// *HXD&=248;*HXD|=ch&7;*R_D|=(1<<6);for(;(*R_D)&(0x40););return(*(uint16_t*)(R_D-2));
}
     49e:	92 2b       	or	r25, r18
     4a0:	08 95       	ret

000004a2 <_ZN3adc16read_oversampledEhh>:
 *  @param   waffles
 *  @return  Is it Tuesday yet? (Answer: a Boolean value.)
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples)
{
     4a2:	df 92       	push	r13
     4a4:	ef 92       	push	r14
     4a6:	ff 92       	push	r15
     4a8:	0f 93       	push	r16
     4aa:	1f 93       	push	r17
     4ac:	cf 93       	push	r28
     4ae:	df 93       	push	r29
	DBG (ptr_to_serial, "All your readings are belong to us" << endl);
	
	sampleavg = 0;
     4b0:	10 92 87 02 	sts	0x0287, r1
     4b4:	10 92 86 02 	sts	0x0286, r1
	for(int i = 0; i < samples;i ++)
     4b8:	04 2f       	mov	r16, r20
     4ba:	10 e0       	ldi	r17, 0x00	; 0
     4bc:	10 16       	cp	r1, r16
     4be:	11 06       	cpc	r1, r17
     4c0:	ac f4       	brge	.+42     	; 0x4ec <_ZN3adc16read_oversampledEhh+0x4a>
     4c2:	d6 2e       	mov	r13, r22
     4c4:	7c 01       	movw	r14, r24
     4c6:	c0 e0       	ldi	r28, 0x00	; 0
     4c8:	d0 e0       	ldi	r29, 0x00	; 0
	{
		sampleavg += read_once(channel);
     4ca:	6d 2d       	mov	r22, r13
     4cc:	c7 01       	movw	r24, r14
     4ce:	c0 df       	rcall	.-128    	; 0x450 <_ZN3adc9read_onceEh>
     4d0:	20 91 86 02 	lds	r18, 0x0286
     4d4:	30 91 87 02 	lds	r19, 0x0287
     4d8:	82 0f       	add	r24, r18
     4da:	93 1f       	adc	r25, r19
     4dc:	90 93 87 02 	sts	0x0287, r25
     4e0:	80 93 86 02 	sts	0x0286, r24
uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples)
{
	DBG (ptr_to_serial, "All your readings are belong to us" << endl);
	
	sampleavg = 0;
	for(int i = 0; i < samples;i ++)
     4e4:	21 96       	adiw	r28, 0x01	; 1
     4e6:	c0 17       	cp	r28, r16
     4e8:	d1 07       	cpc	r29, r17
     4ea:	79 f7       	brne	.-34     	; 0x4ca <_ZN3adc16read_oversampledEhh+0x28>
	{
		sampleavg += read_once(channel);
	}
	sampleavg /= samples;
     4ec:	80 91 86 02 	lds	r24, 0x0286
     4f0:	90 91 87 02 	lds	r25, 0x0287
     4f4:	b8 01       	movw	r22, r16
     4f6:	0e 94 20 19 	call	0x3240	; 0x3240 <__divmodhi4>
     4fa:	cb 01       	movw	r24, r22
     4fc:	70 93 87 02 	sts	0x0287, r23
     500:	60 93 86 02 	sts	0x0286, r22
	
	return (sampleavg);
}
     504:	df 91       	pop	r29
     506:	cf 91       	pop	r28
     508:	1f 91       	pop	r17
     50a:	0f 91       	pop	r16
     50c:	ff 90       	pop	r15
     50e:	ef 90       	pop	r14
     510:	df 90       	pop	r13
     512:	08 95       	ret

00000514 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     514:	0f 93       	push	r16
     516:	1f 93       	push	r17
     518:	cf 93       	push	r28
     51a:	df 93       	push	r29
     51c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     51e:	e3 d6       	rcall	.+3526   	; 0x12e6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     520:	80 91 88 02 	lds	r24, 0x0288
     524:	81 11       	cpse	r24, r1
     526:	1d c0       	rjmp	.+58     	; 0x562 <pvPortMalloc+0x4e>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     528:	ed e8       	ldi	r30, 0x8D	; 141
     52a:	f2 e0       	ldi	r31, 0x02	; 2
     52c:	82 e9       	ldi	r24, 0x92	; 146
     52e:	92 e0       	ldi	r25, 0x02	; 2
     530:	91 83       	std	Z+1, r25	; 0x01
     532:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     534:	13 82       	std	Z+3, r1	; 0x03
     536:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     538:	e9 e8       	ldi	r30, 0x89	; 137
     53a:	f2 e0       	ldi	r31, 0x02	; 2
     53c:	87 e3       	ldi	r24, 0x37	; 55
     53e:	97 e1       	ldi	r25, 0x17	; 23
     540:	93 83       	std	Z+3, r25	; 0x03
     542:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     544:	11 82       	std	Z+1, r1	; 0x01
     546:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     548:	a1 e9       	ldi	r26, 0x91	; 145
     54a:	b2 e0       	ldi	r27, 0x02	; 2
     54c:	14 96       	adiw	r26, 0x04	; 4
     54e:	9c 93       	st	X, r25
     550:	8e 93       	st	-X, r24
     552:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     554:	12 96       	adiw	r26, 0x02	; 2
     556:	fc 93       	st	X, r31
     558:	ee 93       	st	-X, r30
     55a:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	80 93 88 02 	sts	0x0288, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     562:	20 97       	sbiw	r28, 0x00	; 0
     564:	09 f4       	brne	.+2      	; 0x568 <pvPortMalloc+0x54>
     566:	5f c0       	rjmp	.+190    	; 0x626 <pvPortMalloc+0x112>
		{
			xWantedSize += heapSTRUCT_SIZE;
     568:	9e 01       	movw	r18, r28
     56a:	2c 5f       	subi	r18, 0xFC	; 252
     56c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     56e:	23 96       	adiw	r28, 0x03	; 3
     570:	c6 33       	cpi	r28, 0x36	; 54
     572:	d7 41       	sbci	r29, 0x17	; 23
     574:	08 f0       	brcs	.+2      	; 0x578 <pvPortMalloc+0x64>
     576:	5a c0       	rjmp	.+180    	; 0x62c <pvPortMalloc+0x118>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     578:	e0 91 8d 02 	lds	r30, 0x028D
     57c:	f0 91 8e 02 	lds	r31, 0x028E

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     580:	ad e8       	ldi	r26, 0x8D	; 141
     582:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     584:	02 c0       	rjmp	.+4      	; 0x58a <pvPortMalloc+0x76>
     586:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     588:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     58a:	82 81       	ldd	r24, Z+2	; 0x02
     58c:	93 81       	ldd	r25, Z+3	; 0x03
     58e:	82 17       	cp	r24, r18
     590:	93 07       	cpc	r25, r19
     592:	20 f4       	brcc	.+8      	; 0x59c <pvPortMalloc+0x88>
     594:	80 81       	ld	r24, Z
     596:	91 81       	ldd	r25, Z+1	; 0x01
     598:	00 97       	sbiw	r24, 0x00	; 0
     59a:	a9 f7       	brne	.-22     	; 0x586 <pvPortMalloc+0x72>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     59c:	c2 e0       	ldi	r28, 0x02	; 2
     59e:	e9 38       	cpi	r30, 0x89	; 137
     5a0:	fc 07       	cpc	r31, r28
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <pvPortMalloc+0x92>
     5a4:	46 c0       	rjmp	.+140    	; 0x632 <pvPortMalloc+0x11e>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     5a6:	cd 91       	ld	r28, X+
     5a8:	dc 91       	ld	r29, X
     5aa:	11 97       	sbiw	r26, 0x01	; 1
     5ac:	8e 01       	movw	r16, r28
     5ae:	0c 5f       	subi	r16, 0xFC	; 252
     5b0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5b2:	80 81       	ld	r24, Z
     5b4:	91 81       	ldd	r25, Z+1	; 0x01
     5b6:	8d 93       	st	X+, r24
     5b8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5ba:	82 81       	ldd	r24, Z+2	; 0x02
     5bc:	93 81       	ldd	r25, Z+3	; 0x03
     5be:	82 1b       	sub	r24, r18
     5c0:	93 0b       	sbc	r25, r19
     5c2:	89 30       	cpi	r24, 0x09	; 9
     5c4:	91 05       	cpc	r25, r1
     5c6:	10 f1       	brcs	.+68     	; 0x60c <pvPortMalloc+0xf8>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5c8:	bf 01       	movw	r22, r30
     5ca:	62 0f       	add	r22, r18
     5cc:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5ce:	db 01       	movw	r26, r22
     5d0:	13 96       	adiw	r26, 0x03	; 3
     5d2:	9c 93       	st	X, r25
     5d4:	8e 93       	st	-X, r24
     5d6:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     5d8:	33 83       	std	Z+3, r19	; 0x03
     5da:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     5dc:	12 96       	adiw	r26, 0x02	; 2
     5de:	4d 91       	ld	r20, X+
     5e0:	5c 91       	ld	r21, X
     5e2:	13 97       	sbiw	r26, 0x03	; 3
     5e4:	8d e8       	ldi	r24, 0x8D	; 141
     5e6:	92 e0       	ldi	r25, 0x02	; 2
     5e8:	01 c0       	rjmp	.+2      	; 0x5ec <pvPortMalloc+0xd8>
     5ea:	cd 01       	movw	r24, r26
     5ec:	ec 01       	movw	r28, r24
     5ee:	a8 81       	ld	r26, Y
     5f0:	b9 81       	ldd	r27, Y+1	; 0x01
     5f2:	12 96       	adiw	r26, 0x02	; 2
     5f4:	2d 91       	ld	r18, X+
     5f6:	3c 91       	ld	r19, X
     5f8:	13 97       	sbiw	r26, 0x03	; 3
     5fa:	24 17       	cp	r18, r20
     5fc:	35 07       	cpc	r19, r21
     5fe:	a8 f3       	brcs	.-22     	; 0x5ea <pvPortMalloc+0xd6>
     600:	eb 01       	movw	r28, r22
     602:	b9 83       	std	Y+1, r27	; 0x01
     604:	a8 83       	st	Y, r26
     606:	dc 01       	movw	r26, r24
     608:	6d 93       	st	X+, r22
     60a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     60c:	80 91 00 02 	lds	r24, 0x0200
     610:	90 91 01 02 	lds	r25, 0x0201
     614:	22 81       	ldd	r18, Z+2	; 0x02
     616:	33 81       	ldd	r19, Z+3	; 0x03
     618:	82 1b       	sub	r24, r18
     61a:	93 0b       	sbc	r25, r19
     61c:	90 93 01 02 	sts	0x0201, r25
     620:	80 93 00 02 	sts	0x0200, r24
     624:	08 c0       	rjmp	.+16     	; 0x636 <pvPortMalloc+0x122>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     626:	00 e0       	ldi	r16, 0x00	; 0
     628:	10 e0       	ldi	r17, 0x00	; 0
     62a:	05 c0       	rjmp	.+10     	; 0x636 <pvPortMalloc+0x122>
     62c:	00 e0       	ldi	r16, 0x00	; 0
     62e:	10 e0       	ldi	r17, 0x00	; 0
     630:	02 c0       	rjmp	.+4      	; 0x636 <pvPortMalloc+0x122>
     632:	00 e0       	ldi	r16, 0x00	; 0
     634:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     636:	78 d7       	rcall	.+3824   	; 0x1528 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     638:	c8 01       	movw	r24, r16
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	1f 91       	pop	r17
     640:	0f 91       	pop	r16
     642:	08 95       	ret

00000644 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     644:	0f 93       	push	r16
     646:	1f 93       	push	r17
     648:	cf 93       	push	r28
     64a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	31 f1       	breq	.+76     	; 0x69c <vPortFree+0x58>
     650:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     652:	8c 01       	movw	r16, r24
     654:	04 50       	subi	r16, 0x04	; 4
     656:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     658:	46 d6       	rcall	.+3212   	; 0x12e6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     65a:	f8 01       	movw	r30, r16
     65c:	42 81       	ldd	r20, Z+2	; 0x02
     65e:	53 81       	ldd	r21, Z+3	; 0x03
     660:	ad e8       	ldi	r26, 0x8D	; 141
     662:	b2 e0       	ldi	r27, 0x02	; 2
     664:	01 c0       	rjmp	.+2      	; 0x668 <vPortFree+0x24>
     666:	df 01       	movw	r26, r30
     668:	ed 91       	ld	r30, X+
     66a:	fc 91       	ld	r31, X
     66c:	11 97       	sbiw	r26, 0x01	; 1
     66e:	22 81       	ldd	r18, Z+2	; 0x02
     670:	33 81       	ldd	r19, Z+3	; 0x03
     672:	24 17       	cp	r18, r20
     674:	35 07       	cpc	r19, r21
     676:	b8 f3       	brcs	.-18     	; 0x666 <vPortFree+0x22>
     678:	24 97       	sbiw	r28, 0x04	; 4
     67a:	f9 83       	std	Y+1, r31	; 0x01
     67c:	e8 83       	st	Y, r30
     67e:	0d 93       	st	X+, r16
     680:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     682:	20 91 00 02 	lds	r18, 0x0200
     686:	30 91 01 02 	lds	r19, 0x0201
     68a:	8a 81       	ldd	r24, Y+2	; 0x02
     68c:	9b 81       	ldd	r25, Y+3	; 0x03
     68e:	82 0f       	add	r24, r18
     690:	93 1f       	adc	r25, r19
     692:	90 93 01 02 	sts	0x0201, r25
     696:	80 93 00 02 	sts	0x0200, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     69a:	46 d7       	rcall	.+3724   	; 0x1528 <xTaskResumeAll>
	}
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	08 95       	ret

000006a6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     6a6:	80 91 00 02 	lds	r24, 0x0200
     6aa:	90 91 01 02 	lds	r25, 0x0201
     6ae:	08 95       	ret

000006b0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6b0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6b2:	03 96       	adiw	r24, 0x03	; 3
     6b4:	92 83       	std	Z+2, r25	; 0x02
     6b6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6b8:	4f ef       	ldi	r20, 0xFF	; 255
     6ba:	5f ef       	ldi	r21, 0xFF	; 255
     6bc:	ba 01       	movw	r22, r20
     6be:	43 83       	std	Z+3, r20	; 0x03
     6c0:	54 83       	std	Z+4, r21	; 0x04
     6c2:	65 83       	std	Z+5, r22	; 0x05
     6c4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6c6:	90 87       	std	Z+8, r25	; 0x08
     6c8:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ca:	92 87       	std	Z+10, r25	; 0x0a
     6cc:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6ce:	10 82       	st	Z, r1
     6d0:	08 95       	ret

000006d2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6d2:	fc 01       	movw	r30, r24
     6d4:	13 86       	std	Z+11, r1	; 0x0b
     6d6:	12 86       	std	Z+10, r1	; 0x0a
     6d8:	08 95       	ret

000006da <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	9c 01       	movw	r18, r24
     6e0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6e2:	dc 01       	movw	r26, r24
     6e4:	11 96       	adiw	r26, 0x01	; 1
     6e6:	cd 91       	ld	r28, X+
     6e8:	dc 91       	ld	r29, X
     6ea:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6ec:	d5 83       	std	Z+5, r29	; 0x05
     6ee:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6f0:	8e 81       	ldd	r24, Y+6	; 0x06
     6f2:	9f 81       	ldd	r25, Y+7	; 0x07
     6f4:	97 83       	std	Z+7, r25	; 0x07
     6f6:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6f8:	8e 81       	ldd	r24, Y+6	; 0x06
     6fa:	9f 81       	ldd	r25, Y+7	; 0x07
     6fc:	dc 01       	movw	r26, r24
     6fe:	15 96       	adiw	r26, 0x05	; 5
     700:	7c 93       	st	X, r23
     702:	6e 93       	st	-X, r22
     704:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     706:	7f 83       	std	Y+7, r23	; 0x07
     708:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     70a:	33 87       	std	Z+11, r19	; 0x0b
     70c:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     70e:	f9 01       	movw	r30, r18
     710:	80 81       	ld	r24, Z
     712:	8f 5f       	subi	r24, 0xFF	; 255
     714:	80 83       	st	Z, r24
}
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	08 95       	ret

0000071c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     71c:	0f 93       	push	r16
     71e:	1f 93       	push	r17
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     726:	08 81       	ld	r16, Y
     728:	19 81       	ldd	r17, Y+1	; 0x01
     72a:	2a 81       	ldd	r18, Y+2	; 0x02
     72c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     72e:	0f 3f       	cpi	r16, 0xFF	; 255
     730:	4f ef       	ldi	r20, 0xFF	; 255
     732:	14 07       	cpc	r17, r20
     734:	24 07       	cpc	r18, r20
     736:	34 07       	cpc	r19, r20
     738:	21 f4       	brne	.+8      	; 0x742 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     73a:	fc 01       	movw	r30, r24
     73c:	a1 85       	ldd	r26, Z+9	; 0x09
     73e:	b2 85       	ldd	r27, Z+10	; 0x0a
     740:	11 c0       	rjmp	.+34     	; 0x764 <vListInsert+0x48>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     742:	dc 01       	movw	r26, r24
     744:	13 96       	adiw	r26, 0x03	; 3
     746:	01 c0       	rjmp	.+2      	; 0x74a <vListInsert+0x2e>
     748:	df 01       	movw	r26, r30
     74a:	14 96       	adiw	r26, 0x04	; 4
     74c:	ed 91       	ld	r30, X+
     74e:	fc 91       	ld	r31, X
     750:	15 97       	sbiw	r26, 0x05	; 5
     752:	40 81       	ld	r20, Z
     754:	51 81       	ldd	r21, Z+1	; 0x01
     756:	62 81       	ldd	r22, Z+2	; 0x02
     758:	73 81       	ldd	r23, Z+3	; 0x03
     75a:	04 17       	cp	r16, r20
     75c:	15 07       	cpc	r17, r21
     75e:	26 07       	cpc	r18, r22
     760:	37 07       	cpc	r19, r23
     762:	90 f7       	brcc	.-28     	; 0x748 <vListInsert+0x2c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     764:	14 96       	adiw	r26, 0x04	; 4
     766:	ed 91       	ld	r30, X+
     768:	fc 91       	ld	r31, X
     76a:	15 97       	sbiw	r26, 0x05	; 5
     76c:	fd 83       	std	Y+5, r31	; 0x05
     76e:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     770:	d7 83       	std	Z+7, r29	; 0x07
     772:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     774:	bf 83       	std	Y+7, r27	; 0x07
     776:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     778:	15 96       	adiw	r26, 0x05	; 5
     77a:	dc 93       	st	X, r29
     77c:	ce 93       	st	-X, r28
     77e:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     780:	9b 87       	std	Y+11, r25	; 0x0b
     782:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     784:	fc 01       	movw	r30, r24
     786:	20 81       	ld	r18, Z
     788:	2f 5f       	subi	r18, 0xFF	; 255
     78a:	20 83       	st	Z, r18
}
     78c:	df 91       	pop	r29
     78e:	cf 91       	pop	r28
     790:	1f 91       	pop	r17
     792:	0f 91       	pop	r16
     794:	08 95       	ret

00000796 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     79c:	a2 85       	ldd	r26, Z+10	; 0x0a
     79e:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7a0:	c4 81       	ldd	r28, Z+4	; 0x04
     7a2:	d5 81       	ldd	r29, Z+5	; 0x05
     7a4:	86 81       	ldd	r24, Z+6	; 0x06
     7a6:	97 81       	ldd	r25, Z+7	; 0x07
     7a8:	9f 83       	std	Y+7, r25	; 0x07
     7aa:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7ac:	c6 81       	ldd	r28, Z+6	; 0x06
     7ae:	d7 81       	ldd	r29, Z+7	; 0x07
     7b0:	84 81       	ldd	r24, Z+4	; 0x04
     7b2:	95 81       	ldd	r25, Z+5	; 0x05
     7b4:	9d 83       	std	Y+5, r25	; 0x05
     7b6:	8c 83       	std	Y+4, r24	; 0x04

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7b8:	11 96       	adiw	r26, 0x01	; 1
     7ba:	cd 91       	ld	r28, X+
     7bc:	dc 91       	ld	r29, X
     7be:	12 97       	sbiw	r26, 0x02	; 2
     7c0:	ce 17       	cp	r28, r30
     7c2:	df 07       	cpc	r29, r31
     7c4:	31 f4       	brne	.+12     	; 0x7d2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7c6:	8e 81       	ldd	r24, Y+6	; 0x06
     7c8:	9f 81       	ldd	r25, Y+7	; 0x07
     7ca:	12 96       	adiw	r26, 0x02	; 2
     7cc:	9c 93       	st	X, r25
     7ce:	8e 93       	st	-X, r24
     7d0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7d2:	13 86       	std	Z+11, r1	; 0x0b
     7d4:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     7d6:	8c 91       	ld	r24, X
     7d8:	81 50       	subi	r24, 0x01	; 1
     7da:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     7e2:	90 93 3d 1a 	sts	0x1A3D, r25
     7e6:	80 93 3c 1a 	sts	0x1A3C, r24
     7ea:	31 e1       	ldi	r19, 0x11	; 17
     7ec:	fc 01       	movw	r30, r24
     7ee:	30 83       	st	Z, r19
     7f0:	31 97       	sbiw	r30, 0x01	; 1
     7f2:	22 e2       	ldi	r18, 0x22	; 34
     7f4:	20 83       	st	Z, r18
     7f6:	31 97       	sbiw	r30, 0x01	; 1
     7f8:	a3 e3       	ldi	r26, 0x33	; 51
     7fa:	a0 83       	st	Z, r26
     7fc:	31 97       	sbiw	r30, 0x01	; 1
     7fe:	60 83       	st	Z, r22
     800:	31 97       	sbiw	r30, 0x01	; 1
     802:	70 83       	st	Z, r23
     804:	31 97       	sbiw	r30, 0x01	; 1
     806:	10 82       	st	Z, r1
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	60 e8       	ldi	r22, 0x80	; 128
     80c:	60 83       	st	Z, r22
     80e:	31 97       	sbiw	r30, 0x01	; 1
     810:	10 82       	st	Z, r1
     812:	31 97       	sbiw	r30, 0x01	; 1
     814:	62 e0       	ldi	r22, 0x02	; 2
     816:	60 83       	st	Z, r22
     818:	31 97       	sbiw	r30, 0x01	; 1
     81a:	63 e0       	ldi	r22, 0x03	; 3
     81c:	60 83       	st	Z, r22
     81e:	31 97       	sbiw	r30, 0x01	; 1
     820:	64 e0       	ldi	r22, 0x04	; 4
     822:	60 83       	st	Z, r22
     824:	31 97       	sbiw	r30, 0x01	; 1
     826:	65 e0       	ldi	r22, 0x05	; 5
     828:	60 83       	st	Z, r22
     82a:	31 97       	sbiw	r30, 0x01	; 1
     82c:	66 e0       	ldi	r22, 0x06	; 6
     82e:	60 83       	st	Z, r22
     830:	31 97       	sbiw	r30, 0x01	; 1
     832:	67 e0       	ldi	r22, 0x07	; 7
     834:	60 83       	st	Z, r22
     836:	31 97       	sbiw	r30, 0x01	; 1
     838:	68 e0       	ldi	r22, 0x08	; 8
     83a:	60 83       	st	Z, r22
     83c:	31 97       	sbiw	r30, 0x01	; 1
     83e:	69 e0       	ldi	r22, 0x09	; 9
     840:	60 83       	st	Z, r22
     842:	31 97       	sbiw	r30, 0x01	; 1
     844:	60 e1       	ldi	r22, 0x10	; 16
     846:	60 83       	st	Z, r22
     848:	31 97       	sbiw	r30, 0x01	; 1
     84a:	30 83       	st	Z, r19
     84c:	31 97       	sbiw	r30, 0x01	; 1
     84e:	32 e1       	ldi	r19, 0x12	; 18
     850:	30 83       	st	Z, r19
     852:	31 97       	sbiw	r30, 0x01	; 1
     854:	33 e1       	ldi	r19, 0x13	; 19
     856:	30 83       	st	Z, r19
     858:	31 97       	sbiw	r30, 0x01	; 1
     85a:	34 e1       	ldi	r19, 0x14	; 20
     85c:	30 83       	st	Z, r19
     85e:	31 97       	sbiw	r30, 0x01	; 1
     860:	35 e1       	ldi	r19, 0x15	; 21
     862:	30 83       	st	Z, r19
     864:	31 97       	sbiw	r30, 0x01	; 1
     866:	36 e1       	ldi	r19, 0x16	; 22
     868:	30 83       	st	Z, r19
     86a:	31 97       	sbiw	r30, 0x01	; 1
     86c:	37 e1       	ldi	r19, 0x17	; 23
     86e:	30 83       	st	Z, r19
     870:	31 97       	sbiw	r30, 0x01	; 1
     872:	38 e1       	ldi	r19, 0x18	; 24
     874:	30 83       	st	Z, r19
     876:	31 97       	sbiw	r30, 0x01	; 1
     878:	39 e1       	ldi	r19, 0x19	; 25
     87a:	30 83       	st	Z, r19
     87c:	31 97       	sbiw	r30, 0x01	; 1
     87e:	30 e2       	ldi	r19, 0x20	; 32
     880:	30 83       	st	Z, r19
     882:	31 97       	sbiw	r30, 0x01	; 1
     884:	31 e2       	ldi	r19, 0x21	; 33
     886:	30 83       	st	Z, r19
     888:	31 97       	sbiw	r30, 0x01	; 1
     88a:	20 83       	st	Z, r18
     88c:	31 97       	sbiw	r30, 0x01	; 1
     88e:	23 e2       	ldi	r18, 0x23	; 35
     890:	20 83       	st	Z, r18
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	40 83       	st	Z, r20
     896:	31 97       	sbiw	r30, 0x01	; 1
     898:	50 83       	st	Z, r21
     89a:	31 97       	sbiw	r30, 0x01	; 1
     89c:	26 e2       	ldi	r18, 0x26	; 38
     89e:	20 83       	st	Z, r18
     8a0:	31 97       	sbiw	r30, 0x01	; 1
     8a2:	27 e2       	ldi	r18, 0x27	; 39
     8a4:	20 83       	st	Z, r18
     8a6:	31 97       	sbiw	r30, 0x01	; 1
     8a8:	28 e2       	ldi	r18, 0x28	; 40
     8aa:	20 83       	st	Z, r18
     8ac:	31 97       	sbiw	r30, 0x01	; 1
     8ae:	29 e2       	ldi	r18, 0x29	; 41
     8b0:	20 83       	st	Z, r18
     8b2:	31 97       	sbiw	r30, 0x01	; 1
     8b4:	20 e3       	ldi	r18, 0x30	; 48
     8b6:	20 83       	st	Z, r18
     8b8:	31 97       	sbiw	r30, 0x01	; 1
     8ba:	21 e3       	ldi	r18, 0x31	; 49
     8bc:	20 83       	st	Z, r18
     8be:	86 97       	sbiw	r24, 0x26	; 38
     8c0:	08 95       	ret

000008c2 <xPortStartScheduler>:
     8c2:	87 e0       	ldi	r24, 0x07	; 7
     8c4:	80 93 29 01 	sts	0x0129, r24
     8c8:	8f ec       	ldi	r24, 0xCF	; 207
     8ca:	80 93 28 01 	sts	0x0128, r24
     8ce:	8a e0       	ldi	r24, 0x0A	; 10
     8d0:	80 93 21 01 	sts	0x0121, r24
     8d4:	e3 e7       	ldi	r30, 0x73	; 115
     8d6:	f0 e0       	ldi	r31, 0x00	; 0
     8d8:	80 81       	ld	r24, Z
     8da:	82 60       	ori	r24, 0x02	; 2
     8dc:	80 83       	st	Z, r24
     8de:	a0 91 28 1a 	lds	r26, 0x1A28
     8e2:	b0 91 29 1a 	lds	r27, 0x1A29
     8e6:	cd 91       	ld	r28, X+
     8e8:	cd bf       	out	0x3d, r28	; 61
     8ea:	dd 91       	ld	r29, X+
     8ec:	de bf       	out	0x3e, r29	; 62
     8ee:	ff 91       	pop	r31
     8f0:	ef 91       	pop	r30
     8f2:	df 91       	pop	r29
     8f4:	cf 91       	pop	r28
     8f6:	bf 91       	pop	r27
     8f8:	af 91       	pop	r26
     8fa:	9f 91       	pop	r25
     8fc:	8f 91       	pop	r24
     8fe:	7f 91       	pop	r23
     900:	6f 91       	pop	r22
     902:	5f 91       	pop	r21
     904:	4f 91       	pop	r20
     906:	3f 91       	pop	r19
     908:	2f 91       	pop	r18
     90a:	1f 91       	pop	r17
     90c:	0f 91       	pop	r16
     90e:	ff 90       	pop	r15
     910:	ef 90       	pop	r14
     912:	df 90       	pop	r13
     914:	cf 90       	pop	r12
     916:	bf 90       	pop	r11
     918:	af 90       	pop	r10
     91a:	9f 90       	pop	r9
     91c:	8f 90       	pop	r8
     91e:	7f 90       	pop	r7
     920:	6f 90       	pop	r6
     922:	5f 90       	pop	r5
     924:	4f 90       	pop	r4
     926:	3f 90       	pop	r3
     928:	2f 90       	pop	r2
     92a:	1f 90       	pop	r1
     92c:	0f 90       	pop	r0
     92e:	0f be       	out	0x3f, r0	; 63
     930:	0f 90       	pop	r0
     932:	08 95       	ret
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	08 95       	ret

00000938 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     938:	0f 92       	push	r0
     93a:	0f b6       	in	r0, 0x3f	; 63
     93c:	f8 94       	cli
     93e:	0f 92       	push	r0
     940:	1f 92       	push	r1
     942:	11 24       	eor	r1, r1
     944:	2f 92       	push	r2
     946:	3f 92       	push	r3
     948:	4f 92       	push	r4
     94a:	5f 92       	push	r5
     94c:	6f 92       	push	r6
     94e:	7f 92       	push	r7
     950:	8f 92       	push	r8
     952:	9f 92       	push	r9
     954:	af 92       	push	r10
     956:	bf 92       	push	r11
     958:	cf 92       	push	r12
     95a:	df 92       	push	r13
     95c:	ef 92       	push	r14
     95e:	ff 92       	push	r15
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	2f 93       	push	r18
     966:	3f 93       	push	r19
     968:	4f 93       	push	r20
     96a:	5f 93       	push	r21
     96c:	6f 93       	push	r22
     96e:	7f 93       	push	r23
     970:	8f 93       	push	r24
     972:	9f 93       	push	r25
     974:	af 93       	push	r26
     976:	bf 93       	push	r27
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	ef 93       	push	r30
     97e:	ff 93       	push	r31
     980:	a0 91 28 1a 	lds	r26, 0x1A28
     984:	b0 91 29 1a 	lds	r27, 0x1A29
     988:	0d b6       	in	r0, 0x3d	; 61
     98a:	0d 92       	st	X+, r0
     98c:	0e b6       	in	r0, 0x3e	; 62
     98e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     990:	cc d6       	rcall	.+3480   	; 0x172a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     992:	a0 91 28 1a 	lds	r26, 0x1A28
     996:	b0 91 29 1a 	lds	r27, 0x1A29
     99a:	cd 91       	ld	r28, X+
     99c:	cd bf       	out	0x3d, r28	; 61
     99e:	dd 91       	ld	r29, X+
     9a0:	de bf       	out	0x3e, r29	; 62
     9a2:	ff 91       	pop	r31
     9a4:	ef 91       	pop	r30
     9a6:	df 91       	pop	r29
     9a8:	cf 91       	pop	r28
     9aa:	bf 91       	pop	r27
     9ac:	af 91       	pop	r26
     9ae:	9f 91       	pop	r25
     9b0:	8f 91       	pop	r24
     9b2:	7f 91       	pop	r23
     9b4:	6f 91       	pop	r22
     9b6:	5f 91       	pop	r21
     9b8:	4f 91       	pop	r20
     9ba:	3f 91       	pop	r19
     9bc:	2f 91       	pop	r18
     9be:	1f 91       	pop	r17
     9c0:	0f 91       	pop	r16
     9c2:	ff 90       	pop	r15
     9c4:	ef 90       	pop	r14
     9c6:	df 90       	pop	r13
     9c8:	cf 90       	pop	r12
     9ca:	bf 90       	pop	r11
     9cc:	af 90       	pop	r10
     9ce:	9f 90       	pop	r9
     9d0:	8f 90       	pop	r8
     9d2:	7f 90       	pop	r7
     9d4:	6f 90       	pop	r6
     9d6:	5f 90       	pop	r5
     9d8:	4f 90       	pop	r4
     9da:	3f 90       	pop	r3
     9dc:	2f 90       	pop	r2
     9de:	1f 90       	pop	r1
     9e0:	0f 90       	pop	r0
     9e2:	0f be       	out	0x3f, r0	; 63
     9e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9e6:	08 95       	ret

000009e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     9e8:	0f 92       	push	r0
     9ea:	0f b6       	in	r0, 0x3f	; 63
     9ec:	f8 94       	cli
     9ee:	0f 92       	push	r0
     9f0:	1f 92       	push	r1
     9f2:	11 24       	eor	r1, r1
     9f4:	2f 92       	push	r2
     9f6:	3f 92       	push	r3
     9f8:	4f 92       	push	r4
     9fa:	5f 92       	push	r5
     9fc:	6f 92       	push	r6
     9fe:	7f 92       	push	r7
     a00:	8f 92       	push	r8
     a02:	9f 92       	push	r9
     a04:	af 92       	push	r10
     a06:	bf 92       	push	r11
     a08:	cf 92       	push	r12
     a0a:	df 92       	push	r13
     a0c:	ef 92       	push	r14
     a0e:	ff 92       	push	r15
     a10:	0f 93       	push	r16
     a12:	1f 93       	push	r17
     a14:	2f 93       	push	r18
     a16:	3f 93       	push	r19
     a18:	4f 93       	push	r20
     a1a:	5f 93       	push	r21
     a1c:	6f 93       	push	r22
     a1e:	7f 93       	push	r23
     a20:	8f 93       	push	r24
     a22:	9f 93       	push	r25
     a24:	af 93       	push	r26
     a26:	bf 93       	push	r27
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	ef 93       	push	r30
     a2e:	ff 93       	push	r31
     a30:	a0 91 28 1a 	lds	r26, 0x1A28
     a34:	b0 91 29 1a 	lds	r27, 0x1A29
     a38:	0d b6       	in	r0, 0x3d	; 61
     a3a:	0d 92       	st	X+, r0
     a3c:	0e b6       	in	r0, 0x3e	; 62
     a3e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     a40:	73 d4       	rcall	.+2278   	; 0x1328 <xTaskIncrementTick>
     a42:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     a44:	72 d6       	rcall	.+3300   	; 0x172a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     a46:	a0 91 28 1a 	lds	r26, 0x1A28
     a4a:	b0 91 29 1a 	lds	r27, 0x1A29
     a4e:	cd 91       	ld	r28, X+
     a50:	cd bf       	out	0x3d, r28	; 61
     a52:	dd 91       	ld	r29, X+
     a54:	de bf       	out	0x3e, r29	; 62
     a56:	ff 91       	pop	r31
     a58:	ef 91       	pop	r30
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	bf 91       	pop	r27
     a60:	af 91       	pop	r26
     a62:	9f 91       	pop	r25
     a64:	8f 91       	pop	r24
     a66:	7f 91       	pop	r23
     a68:	6f 91       	pop	r22
     a6a:	5f 91       	pop	r21
     a6c:	4f 91       	pop	r20
     a6e:	3f 91       	pop	r19
     a70:	2f 91       	pop	r18
     a72:	1f 91       	pop	r17
     a74:	0f 91       	pop	r16
     a76:	ff 90       	pop	r15
     a78:	ef 90       	pop	r14
     a7a:	df 90       	pop	r13
     a7c:	cf 90       	pop	r12
     a7e:	bf 90       	pop	r11
     a80:	af 90       	pop	r10
     a82:	9f 90       	pop	r9
     a84:	8f 90       	pop	r8
     a86:	7f 90       	pop	r7
     a88:	6f 90       	pop	r6
     a8a:	5f 90       	pop	r5
     a8c:	4f 90       	pop	r4
     a8e:	3f 90       	pop	r3
     a90:	2f 90       	pop	r2
     a92:	1f 90       	pop	r1
     a94:	0f 90       	pop	r0
     a96:	0f be       	out	0x3f, r0	; 63
     a98:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a9a:	08 95       	ret

00000a9c <__vector_47>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
     a9c:	a5 df       	rcall	.-182    	; 0x9e8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a9e:	18 95       	reti

00000aa0 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     aa0:	1f 93       	push	r17
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	ec 01       	movw	r28, r24
     aa8:	14 2f       	mov	r17, r20
     aaa:	88 a1       	ldd	r24, Y+32	; 0x20
     aac:	81 11       	cpse	r24, r1
     aae:	0b c0       	rjmp	.+22     	; 0xac6 <prvCopyDataToQueue+0x26>
     ab0:	88 81       	ld	r24, Y
     ab2:	99 81       	ldd	r25, Y+1	; 0x01
     ab4:	89 2b       	or	r24, r25
     ab6:	09 f0       	breq	.+2      	; 0xaba <prvCopyDataToQueue+0x1a>
     ab8:	46 c0       	rjmp	.+140    	; 0xb46 <prvCopyDataToQueue+0xa6>
     aba:	8a 81       	ldd	r24, Y+2	; 0x02
     abc:	9b 81       	ldd	r25, Y+3	; 0x03
     abe:	e9 d7       	rcall	.+4050   	; 0x1a92 <xTaskPriorityDisinherit>
     ac0:	1b 82       	std	Y+3, r1	; 0x03
     ac2:	1a 82       	std	Y+2, r1	; 0x02
     ac4:	47 c0       	rjmp	.+142    	; 0xb54 <prvCopyDataToQueue+0xb4>
     ac6:	41 11       	cpse	r20, r1
     ac8:	18 c0       	rjmp	.+48     	; 0xafa <prvCopyDataToQueue+0x5a>
     aca:	48 2f       	mov	r20, r24
     acc:	50 e0       	ldi	r21, 0x00	; 0
     ace:	8c 81       	ldd	r24, Y+4	; 0x04
     ad0:	9d 81       	ldd	r25, Y+5	; 0x05
     ad2:	0e 94 a7 19 	call	0x334e	; 0x334e <memcpy>
     ad6:	28 a1       	ldd	r18, Y+32	; 0x20
     ad8:	8c 81       	ldd	r24, Y+4	; 0x04
     ada:	9d 81       	ldd	r25, Y+5	; 0x05
     adc:	82 0f       	add	r24, r18
     ade:	91 1d       	adc	r25, r1
     ae0:	9d 83       	std	Y+5, r25	; 0x05
     ae2:	8c 83       	std	Y+4, r24	; 0x04
     ae4:	2a 81       	ldd	r18, Y+2	; 0x02
     ae6:	3b 81       	ldd	r19, Y+3	; 0x03
     ae8:	82 17       	cp	r24, r18
     aea:	93 07       	cpc	r25, r19
     aec:	70 f1       	brcs	.+92     	; 0xb4a <prvCopyDataToQueue+0xaa>
     aee:	88 81       	ld	r24, Y
     af0:	99 81       	ldd	r25, Y+1	; 0x01
     af2:	9d 83       	std	Y+5, r25	; 0x05
     af4:	8c 83       	std	Y+4, r24	; 0x04
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	2d c0       	rjmp	.+90     	; 0xb54 <prvCopyDataToQueue+0xb4>
     afa:	48 2f       	mov	r20, r24
     afc:	50 e0       	ldi	r21, 0x00	; 0
     afe:	8e 81       	ldd	r24, Y+6	; 0x06
     b00:	9f 81       	ldd	r25, Y+7	; 0x07
     b02:	0e 94 a7 19 	call	0x334e	; 0x334e <memcpy>
     b06:	88 a1       	ldd	r24, Y+32	; 0x20
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	91 95       	neg	r25
     b0c:	81 95       	neg	r24
     b0e:	91 09       	sbc	r25, r1
     b10:	2e 81       	ldd	r18, Y+6	; 0x06
     b12:	3f 81       	ldd	r19, Y+7	; 0x07
     b14:	28 0f       	add	r18, r24
     b16:	39 1f       	adc	r19, r25
     b18:	3f 83       	std	Y+7, r19	; 0x07
     b1a:	2e 83       	std	Y+6, r18	; 0x06
     b1c:	48 81       	ld	r20, Y
     b1e:	59 81       	ldd	r21, Y+1	; 0x01
     b20:	24 17       	cp	r18, r20
     b22:	35 07       	cpc	r19, r21
     b24:	30 f4       	brcc	.+12     	; 0xb32 <prvCopyDataToQueue+0x92>
     b26:	2a 81       	ldd	r18, Y+2	; 0x02
     b28:	3b 81       	ldd	r19, Y+3	; 0x03
     b2a:	82 0f       	add	r24, r18
     b2c:	93 1f       	adc	r25, r19
     b2e:	9f 83       	std	Y+7, r25	; 0x07
     b30:	8e 83       	std	Y+6, r24	; 0x06
     b32:	12 30       	cpi	r17, 0x02	; 2
     b34:	61 f4       	brne	.+24     	; 0xb4e <prvCopyDataToQueue+0xae>
     b36:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b38:	88 23       	and	r24, r24
     b3a:	59 f0       	breq	.+22     	; 0xb52 <prvCopyDataToQueue+0xb2>
     b3c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b3e:	81 50       	subi	r24, 0x01	; 1
     b40:	8e 8f       	std	Y+30, r24	; 0x1e
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	07 c0       	rjmp	.+14     	; 0xb54 <prvCopyDataToQueue+0xb4>
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	05 c0       	rjmp	.+10     	; 0xb54 <prvCopyDataToQueue+0xb4>
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	03 c0       	rjmp	.+6      	; 0xb54 <prvCopyDataToQueue+0xb4>
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	01 c0       	rjmp	.+2      	; 0xb54 <prvCopyDataToQueue+0xb4>
     b52:	80 e0       	ldi	r24, 0x00	; 0
     b54:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b56:	9f 5f       	subi	r25, 0xFF	; 255
     b58:	9e 8f       	std	Y+30, r25	; 0x1e
     b5a:	df 91       	pop	r29
     b5c:	cf 91       	pop	r28
     b5e:	1f 91       	pop	r17
     b60:	08 95       	ret

00000b62 <prvCopyDataFromQueue>:
     b62:	fc 01       	movw	r30, r24
     b64:	40 a1       	ldd	r20, Z+32	; 0x20
     b66:	44 23       	and	r20, r20
     b68:	a9 f0       	breq	.+42     	; 0xb94 <prvCopyDataFromQueue+0x32>
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	26 81       	ldd	r18, Z+6	; 0x06
     b6e:	37 81       	ldd	r19, Z+7	; 0x07
     b70:	24 0f       	add	r18, r20
     b72:	35 1f       	adc	r19, r21
     b74:	37 83       	std	Z+7, r19	; 0x07
     b76:	26 83       	std	Z+6, r18	; 0x06
     b78:	82 81       	ldd	r24, Z+2	; 0x02
     b7a:	93 81       	ldd	r25, Z+3	; 0x03
     b7c:	28 17       	cp	r18, r24
     b7e:	39 07       	cpc	r19, r25
     b80:	20 f0       	brcs	.+8      	; 0xb8a <prvCopyDataFromQueue+0x28>
     b82:	80 81       	ld	r24, Z
     b84:	91 81       	ldd	r25, Z+1	; 0x01
     b86:	97 83       	std	Z+7, r25	; 0x07
     b88:	86 83       	std	Z+6, r24	; 0x06
     b8a:	cb 01       	movw	r24, r22
     b8c:	66 81       	ldd	r22, Z+6	; 0x06
     b8e:	77 81       	ldd	r23, Z+7	; 0x07
     b90:	0c 94 a7 19 	jmp	0x334e	; 0x334e <memcpy>
     b94:	08 95       	ret

00000b96 <prvUnlockQueue>:
     b96:	0f 93       	push	r16
     b98:	1f 93       	push	r17
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	ec 01       	movw	r28, r24
     ba0:	0f b6       	in	r0, 0x3f	; 63
     ba2:	f8 94       	cli
     ba4:	0f 92       	push	r0
     ba6:	8a a1       	ldd	r24, Y+34	; 0x22
     ba8:	18 16       	cp	r1, r24
     baa:	ac f4       	brge	.+42     	; 0xbd6 <prvUnlockQueue+0x40>
     bac:	8b 89       	ldd	r24, Y+19	; 0x13
     bae:	81 11       	cpse	r24, r1
     bb0:	05 c0       	rjmp	.+10     	; 0xbbc <prvUnlockQueue+0x26>
     bb2:	11 c0       	rjmp	.+34     	; 0xbd6 <prvUnlockQueue+0x40>
     bb4:	9b 89       	ldd	r25, Y+19	; 0x13
     bb6:	91 11       	cpse	r25, r1
     bb8:	04 c0       	rjmp	.+8      	; 0xbc2 <prvUnlockQueue+0x2c>
     bba:	0d c0       	rjmp	.+26     	; 0xbd6 <prvUnlockQueue+0x40>
     bbc:	8e 01       	movw	r16, r28
     bbe:	0d 5e       	subi	r16, 0xED	; 237
     bc0:	1f 4f       	sbci	r17, 0xFF	; 255
     bc2:	c8 01       	movw	r24, r16
     bc4:	3a d6       	rcall	.+3188   	; 0x183a <xTaskRemoveFromEventList>
     bc6:	81 11       	cpse	r24, r1
     bc8:	e5 d6       	rcall	.+3530   	; 0x1994 <vTaskMissedYield>
     bca:	9a a1       	ldd	r25, Y+34	; 0x22
     bcc:	91 50       	subi	r25, 0x01	; 1
     bce:	9a a3       	std	Y+34, r25	; 0x22
     bd0:	9a a1       	ldd	r25, Y+34	; 0x22
     bd2:	19 16       	cp	r1, r25
     bd4:	7c f3       	brlt	.-34     	; 0xbb4 <prvUnlockQueue+0x1e>
     bd6:	8f ef       	ldi	r24, 0xFF	; 255
     bd8:	8a a3       	std	Y+34, r24	; 0x22
     bda:	0f 90       	pop	r0
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	0f b6       	in	r0, 0x3f	; 63
     be0:	f8 94       	cli
     be2:	0f 92       	push	r0
     be4:	89 a1       	ldd	r24, Y+33	; 0x21
     be6:	18 16       	cp	r1, r24
     be8:	ac f4       	brge	.+42     	; 0xc14 <prvUnlockQueue+0x7e>
     bea:	88 85       	ldd	r24, Y+8	; 0x08
     bec:	81 11       	cpse	r24, r1
     bee:	05 c0       	rjmp	.+10     	; 0xbfa <prvUnlockQueue+0x64>
     bf0:	11 c0       	rjmp	.+34     	; 0xc14 <prvUnlockQueue+0x7e>
     bf2:	98 85       	ldd	r25, Y+8	; 0x08
     bf4:	91 11       	cpse	r25, r1
     bf6:	04 c0       	rjmp	.+8      	; 0xc00 <prvUnlockQueue+0x6a>
     bf8:	0d c0       	rjmp	.+26     	; 0xc14 <prvUnlockQueue+0x7e>
     bfa:	8e 01       	movw	r16, r28
     bfc:	08 5f       	subi	r16, 0xF8	; 248
     bfe:	1f 4f       	sbci	r17, 0xFF	; 255
     c00:	c8 01       	movw	r24, r16
     c02:	1b d6       	rcall	.+3126   	; 0x183a <xTaskRemoveFromEventList>
     c04:	81 11       	cpse	r24, r1
     c06:	c6 d6       	rcall	.+3468   	; 0x1994 <vTaskMissedYield>
     c08:	99 a1       	ldd	r25, Y+33	; 0x21
     c0a:	91 50       	subi	r25, 0x01	; 1
     c0c:	99 a3       	std	Y+33, r25	; 0x21
     c0e:	99 a1       	ldd	r25, Y+33	; 0x21
     c10:	19 16       	cp	r1, r25
     c12:	7c f3       	brlt	.-34     	; 0xbf2 <prvUnlockQueue+0x5c>
     c14:	8f ef       	ldi	r24, 0xFF	; 255
     c16:	89 a3       	std	Y+33, r24	; 0x21
     c18:	0f 90       	pop	r0
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

00000c26 <xQueueGenericReset>:
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	ec 01       	movw	r28, r24
     c2c:	0f b6       	in	r0, 0x3f	; 63
     c2e:	f8 94       	cli
     c30:	0f 92       	push	r0
     c32:	48 81       	ld	r20, Y
     c34:	59 81       	ldd	r21, Y+1	; 0x01
     c36:	28 a1       	ldd	r18, Y+32	; 0x20
     c38:	30 e0       	ldi	r19, 0x00	; 0
     c3a:	7f 8d       	ldd	r23, Y+31	; 0x1f
     c3c:	72 9f       	mul	r23, r18
     c3e:	c0 01       	movw	r24, r0
     c40:	73 9f       	mul	r23, r19
     c42:	90 0d       	add	r25, r0
     c44:	11 24       	eor	r1, r1
     c46:	fa 01       	movw	r30, r20
     c48:	e8 0f       	add	r30, r24
     c4a:	f9 1f       	adc	r31, r25
     c4c:	fb 83       	std	Y+3, r31	; 0x03
     c4e:	ea 83       	std	Y+2, r30	; 0x02
     c50:	1e 8e       	std	Y+30, r1	; 0x1e
     c52:	5d 83       	std	Y+5, r21	; 0x05
     c54:	4c 83       	std	Y+4, r20	; 0x04
     c56:	82 1b       	sub	r24, r18
     c58:	93 0b       	sbc	r25, r19
     c5a:	84 0f       	add	r24, r20
     c5c:	95 1f       	adc	r25, r21
     c5e:	9f 83       	std	Y+7, r25	; 0x07
     c60:	8e 83       	std	Y+6, r24	; 0x06
     c62:	8f ef       	ldi	r24, 0xFF	; 255
     c64:	89 a3       	std	Y+33, r24	; 0x21
     c66:	8a a3       	std	Y+34, r24	; 0x22
     c68:	61 11       	cpse	r22, r1
     c6a:	0a c0       	rjmp	.+20     	; 0xc80 <xQueueGenericReset+0x5a>
     c6c:	88 85       	ldd	r24, Y+8	; 0x08
     c6e:	88 23       	and	r24, r24
     c70:	69 f0       	breq	.+26     	; 0xc8c <xQueueGenericReset+0x66>
     c72:	ce 01       	movw	r24, r28
     c74:	08 96       	adiw	r24, 0x08	; 8
     c76:	e1 d5       	rcall	.+3010   	; 0x183a <xTaskRemoveFromEventList>
     c78:	81 30       	cpi	r24, 0x01	; 1
     c7a:	41 f4       	brne	.+16     	; 0xc8c <xQueueGenericReset+0x66>
     c7c:	5d de       	rcall	.-838    	; 0x938 <vPortYield>
     c7e:	06 c0       	rjmp	.+12     	; 0xc8c <xQueueGenericReset+0x66>
     c80:	ce 01       	movw	r24, r28
     c82:	08 96       	adiw	r24, 0x08	; 8
     c84:	15 dd       	rcall	.-1494   	; 0x6b0 <vListInitialise>
     c86:	ce 01       	movw	r24, r28
     c88:	43 96       	adiw	r24, 0x13	; 19
     c8a:	12 dd       	rcall	.-1500   	; 0x6b0 <vListInitialise>
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	08 95       	ret

00000c98 <xQueueGenericCreate>:
     c98:	0f 93       	push	r16
     c9a:	1f 93       	push	r17
     c9c:	cf 93       	push	r28
     c9e:	df 93       	push	r29
     ca0:	88 23       	and	r24, r24
     ca2:	e1 f0       	breq	.+56     	; 0xcdc <xQueueGenericCreate+0x44>
     ca4:	06 2f       	mov	r16, r22
     ca6:	18 2f       	mov	r17, r24
     ca8:	83 e2       	ldi	r24, 0x23	; 35
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	33 dc       	rcall	.-1946   	; 0x514 <pvPortMalloc>
     cae:	ec 01       	movw	r28, r24
     cb0:	89 2b       	or	r24, r25
     cb2:	b1 f0       	breq	.+44     	; 0xce0 <xQueueGenericCreate+0x48>
     cb4:	10 9f       	mul	r17, r16
     cb6:	c0 01       	movw	r24, r0
     cb8:	11 24       	eor	r1, r1
     cba:	01 96       	adiw	r24, 0x01	; 1
     cbc:	2b dc       	rcall	.-1962   	; 0x514 <pvPortMalloc>
     cbe:	99 83       	std	Y+1, r25	; 0x01
     cc0:	88 83       	st	Y, r24
     cc2:	89 2b       	or	r24, r25
     cc4:	31 f0       	breq	.+12     	; 0xcd2 <xQueueGenericCreate+0x3a>
     cc6:	1f 8f       	std	Y+31, r17	; 0x1f
     cc8:	08 a3       	std	Y+32, r16	; 0x20
     cca:	61 e0       	ldi	r22, 0x01	; 1
     ccc:	ce 01       	movw	r24, r28
     cce:	ab df       	rcall	.-170    	; 0xc26 <xQueueGenericReset>
     cd0:	07 c0       	rjmp	.+14     	; 0xce0 <xQueueGenericCreate+0x48>
     cd2:	ce 01       	movw	r24, r28
     cd4:	b7 dc       	rcall	.-1682   	; 0x644 <vPortFree>
     cd6:	c0 e0       	ldi	r28, 0x00	; 0
     cd8:	d0 e0       	ldi	r29, 0x00	; 0
     cda:	02 c0       	rjmp	.+4      	; 0xce0 <xQueueGenericCreate+0x48>
     cdc:	c0 e0       	ldi	r28, 0x00	; 0
     cde:	d0 e0       	ldi	r29, 0x00	; 0
     ce0:	ce 01       	movw	r24, r28
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	08 95       	ret

00000cec <xQueueGenericSend>:
     cec:	9f 92       	push	r9
     cee:	af 92       	push	r10
     cf0:	bf 92       	push	r11
     cf2:	cf 92       	push	r12
     cf4:	df 92       	push	r13
     cf6:	ef 92       	push	r14
     cf8:	ff 92       	push	r15
     cfa:	0f 93       	push	r16
     cfc:	1f 93       	push	r17
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	cd b7       	in	r28, 0x3d	; 61
     d04:	de b7       	in	r29, 0x3e	; 62
     d06:	29 97       	sbiw	r28, 0x09	; 9
     d08:	0f b6       	in	r0, 0x3f	; 63
     d0a:	f8 94       	cli
     d0c:	de bf       	out	0x3e, r29	; 62
     d0e:	0f be       	out	0x3f, r0	; 63
     d10:	cd bf       	out	0x3d, r28	; 61
     d12:	7c 01       	movw	r14, r24
     d14:	5b 01       	movw	r10, r22
     d16:	2e 83       	std	Y+6, r18	; 0x06
     d18:	3f 83       	std	Y+7, r19	; 0x07
     d1a:	48 87       	std	Y+8, r20	; 0x08
     d1c:	59 87       	std	Y+9, r21	; 0x09
     d1e:	10 e0       	ldi	r17, 0x00	; 0
     d20:	99 24       	eor	r9, r9
     d22:	93 94       	inc	r9
     d24:	6c 01       	movw	r12, r24
     d26:	88 e0       	ldi	r24, 0x08	; 8
     d28:	c8 0e       	add	r12, r24
     d2a:	d1 1c       	adc	r13, r1
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	0f 92       	push	r0
     d32:	f7 01       	movw	r30, r14
     d34:	26 8d       	ldd	r18, Z+30	; 0x1e
     d36:	97 8d       	ldd	r25, Z+31	; 0x1f
     d38:	29 17       	cp	r18, r25
     d3a:	10 f0       	brcs	.+4      	; 0xd40 <xQueueGenericSend+0x54>
     d3c:	02 30       	cpi	r16, 0x02	; 2
     d3e:	a9 f4       	brne	.+42     	; 0xd6a <xQueueGenericSend+0x7e>
     d40:	40 2f       	mov	r20, r16
     d42:	b5 01       	movw	r22, r10
     d44:	c7 01       	movw	r24, r14
     d46:	ac de       	rcall	.-680    	; 0xaa0 <prvCopyDataToQueue>
     d48:	f7 01       	movw	r30, r14
     d4a:	93 89       	ldd	r25, Z+19	; 0x13
     d4c:	99 23       	and	r25, r25
     d4e:	39 f0       	breq	.+14     	; 0xd5e <xQueueGenericSend+0x72>
     d50:	c7 01       	movw	r24, r14
     d52:	43 96       	adiw	r24, 0x13	; 19
     d54:	72 d5       	rcall	.+2788   	; 0x183a <xTaskRemoveFromEventList>
     d56:	81 30       	cpi	r24, 0x01	; 1
     d58:	21 f4       	brne	.+8      	; 0xd62 <xQueueGenericSend+0x76>
     d5a:	ee dd       	rcall	.-1060   	; 0x938 <vPortYield>
     d5c:	02 c0       	rjmp	.+4      	; 0xd62 <xQueueGenericSend+0x76>
     d5e:	81 11       	cpse	r24, r1
     d60:	eb dd       	rcall	.-1066   	; 0x938 <vPortYield>
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	4b c0       	rjmp	.+150    	; 0xe00 <xQueueGenericSend+0x114>
     d6a:	8e 81       	ldd	r24, Y+6	; 0x06
     d6c:	9f 81       	ldd	r25, Y+7	; 0x07
     d6e:	a8 85       	ldd	r26, Y+8	; 0x08
     d70:	b9 85       	ldd	r27, Y+9	; 0x09
     d72:	89 2b       	or	r24, r25
     d74:	8a 2b       	or	r24, r26
     d76:	8b 2b       	or	r24, r27
     d78:	21 f4       	brne	.+8      	; 0xd82 <xQueueGenericSend+0x96>
     d7a:	0f 90       	pop	r0
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	3f c0       	rjmp	.+126    	; 0xe00 <xQueueGenericSend+0x114>
     d82:	11 11       	cpse	r17, r1
     d84:	04 c0       	rjmp	.+8      	; 0xd8e <xQueueGenericSend+0xa2>
     d86:	ce 01       	movw	r24, r28
     d88:	01 96       	adiw	r24, 0x01	; 1
     d8a:	99 d5       	rcall	.+2866   	; 0x18be <vTaskSetTimeOutState>
     d8c:	19 2d       	mov	r17, r9
     d8e:	0f 90       	pop	r0
     d90:	0f be       	out	0x3f, r0	; 63
     d92:	a9 d2       	rcall	.+1362   	; 0x12e6 <vTaskSuspendAll>
     d94:	0f b6       	in	r0, 0x3f	; 63
     d96:	f8 94       	cli
     d98:	0f 92       	push	r0
     d9a:	f7 01       	movw	r30, r14
     d9c:	81 a1       	ldd	r24, Z+33	; 0x21
     d9e:	8f 3f       	cpi	r24, 0xFF	; 255
     da0:	09 f4       	brne	.+2      	; 0xda4 <xQueueGenericSend+0xb8>
     da2:	11 a2       	std	Z+33, r1	; 0x21
     da4:	f7 01       	movw	r30, r14
     da6:	82 a1       	ldd	r24, Z+34	; 0x22
     da8:	8f 3f       	cpi	r24, 0xFF	; 255
     daa:	09 f4       	brne	.+2      	; 0xdae <xQueueGenericSend+0xc2>
     dac:	12 a2       	std	Z+34, r1	; 0x22
     dae:	0f 90       	pop	r0
     db0:	0f be       	out	0x3f, r0	; 63
     db2:	be 01       	movw	r22, r28
     db4:	6a 5f       	subi	r22, 0xFA	; 250
     db6:	7f 4f       	sbci	r23, 0xFF	; 255
     db8:	ce 01       	movw	r24, r28
     dba:	01 96       	adiw	r24, 0x01	; 1
     dbc:	91 d5       	rcall	.+2850   	; 0x18e0 <xTaskCheckForTimeOut>
     dbe:	81 11       	cpse	r24, r1
     dc0:	1b c0       	rjmp	.+54     	; 0xdf8 <xQueueGenericSend+0x10c>
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
     dc8:	f7 01       	movw	r30, r14
     dca:	96 8d       	ldd	r25, Z+30	; 0x1e
     dcc:	0f 90       	pop	r0
     dce:	0f be       	out	0x3f, r0	; 63
     dd0:	87 8d       	ldd	r24, Z+31	; 0x1f
     dd2:	98 13       	cpse	r25, r24
     dd4:	0d c0       	rjmp	.+26     	; 0xdf0 <xQueueGenericSend+0x104>
     dd6:	4e 81       	ldd	r20, Y+6	; 0x06
     dd8:	5f 81       	ldd	r21, Y+7	; 0x07
     dda:	68 85       	ldd	r22, Y+8	; 0x08
     ddc:	79 85       	ldd	r23, Y+9	; 0x09
     dde:	c6 01       	movw	r24, r12
     de0:	02 d5       	rcall	.+2564   	; 0x17e6 <vTaskPlaceOnEventList>
     de2:	c7 01       	movw	r24, r14
     de4:	d8 de       	rcall	.-592    	; 0xb96 <prvUnlockQueue>
     de6:	a0 d3       	rcall	.+1856   	; 0x1528 <xTaskResumeAll>
     de8:	81 11       	cpse	r24, r1
     dea:	a0 cf       	rjmp	.-192    	; 0xd2c <xQueueGenericSend+0x40>
     dec:	a5 dd       	rcall	.-1206   	; 0x938 <vPortYield>
     dee:	9e cf       	rjmp	.-196    	; 0xd2c <xQueueGenericSend+0x40>
     df0:	c7 01       	movw	r24, r14
     df2:	d1 de       	rcall	.-606    	; 0xb96 <prvUnlockQueue>
     df4:	99 d3       	rcall	.+1842   	; 0x1528 <xTaskResumeAll>
     df6:	9a cf       	rjmp	.-204    	; 0xd2c <xQueueGenericSend+0x40>
     df8:	c7 01       	movw	r24, r14
     dfa:	cd de       	rcall	.-614    	; 0xb96 <prvUnlockQueue>
     dfc:	95 d3       	rcall	.+1834   	; 0x1528 <xTaskResumeAll>
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	29 96       	adiw	r28, 0x09	; 9
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	f8 94       	cli
     e06:	de bf       	out	0x3e, r29	; 62
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	cd bf       	out	0x3d, r28	; 61
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	1f 91       	pop	r17
     e12:	0f 91       	pop	r16
     e14:	ff 90       	pop	r15
     e16:	ef 90       	pop	r14
     e18:	df 90       	pop	r13
     e1a:	cf 90       	pop	r12
     e1c:	bf 90       	pop	r11
     e1e:	af 90       	pop	r10
     e20:	9f 90       	pop	r9
     e22:	08 95       	ret

00000e24 <xQueueGenericReceive>:
     e24:	9f 92       	push	r9
     e26:	af 92       	push	r10
     e28:	bf 92       	push	r11
     e2a:	cf 92       	push	r12
     e2c:	df 92       	push	r13
     e2e:	ef 92       	push	r14
     e30:	ff 92       	push	r15
     e32:	0f 93       	push	r16
     e34:	1f 93       	push	r17
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
     e3e:	29 97       	sbiw	r28, 0x09	; 9
     e40:	0f b6       	in	r0, 0x3f	; 63
     e42:	f8 94       	cli
     e44:	de bf       	out	0x3e, r29	; 62
     e46:	0f be       	out	0x3f, r0	; 63
     e48:	cd bf       	out	0x3d, r28	; 61
     e4a:	7c 01       	movw	r14, r24
     e4c:	5b 01       	movw	r10, r22
     e4e:	2e 83       	std	Y+6, r18	; 0x06
     e50:	3f 83       	std	Y+7, r19	; 0x07
     e52:	48 87       	std	Y+8, r20	; 0x08
     e54:	59 87       	std	Y+9, r21	; 0x09
     e56:	10 e0       	ldi	r17, 0x00	; 0
     e58:	99 24       	eor	r9, r9
     e5a:	93 94       	inc	r9
     e5c:	6c 01       	movw	r12, r24
     e5e:	83 e1       	ldi	r24, 0x13	; 19
     e60:	c8 0e       	add	r12, r24
     e62:	d1 1c       	adc	r13, r1
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	0f 92       	push	r0
     e6a:	f7 01       	movw	r30, r14
     e6c:	96 8d       	ldd	r25, Z+30	; 0x1e
     e6e:	99 23       	and	r25, r25
     e70:	69 f1       	breq	.+90     	; 0xecc <xQueueGenericReceive+0xa8>
     e72:	c6 80       	ldd	r12, Z+6	; 0x06
     e74:	d7 80       	ldd	r13, Z+7	; 0x07
     e76:	b5 01       	movw	r22, r10
     e78:	c7 01       	movw	r24, r14
     e7a:	73 de       	rcall	.-794    	; 0xb62 <prvCopyDataFromQueue>
     e7c:	01 11       	cpse	r16, r1
     e7e:	17 c0       	rjmp	.+46     	; 0xeae <xQueueGenericReceive+0x8a>
     e80:	f7 01       	movw	r30, r14
     e82:	86 8d       	ldd	r24, Z+30	; 0x1e
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	86 8f       	std	Z+30, r24	; 0x1e
     e88:	80 81       	ld	r24, Z
     e8a:	91 81       	ldd	r25, Z+1	; 0x01
     e8c:	89 2b       	or	r24, r25
     e8e:	21 f4       	brne	.+8      	; 0xe98 <xQueueGenericReceive+0x74>
     e90:	40 d6       	rcall	.+3200   	; 0x1b12 <pvTaskIncrementMutexHeldCount>
     e92:	f7 01       	movw	r30, r14
     e94:	93 83       	std	Z+3, r25	; 0x03
     e96:	82 83       	std	Z+2, r24	; 0x02
     e98:	f7 01       	movw	r30, r14
     e9a:	80 85       	ldd	r24, Z+8	; 0x08
     e9c:	88 23       	and	r24, r24
     e9e:	91 f0       	breq	.+36     	; 0xec4 <xQueueGenericReceive+0xa0>
     ea0:	c7 01       	movw	r24, r14
     ea2:	08 96       	adiw	r24, 0x08	; 8
     ea4:	ca d4       	rcall	.+2452   	; 0x183a <xTaskRemoveFromEventList>
     ea6:	81 30       	cpi	r24, 0x01	; 1
     ea8:	69 f4       	brne	.+26     	; 0xec4 <xQueueGenericReceive+0xa0>
     eaa:	46 dd       	rcall	.-1396   	; 0x938 <vPortYield>
     eac:	0b c0       	rjmp	.+22     	; 0xec4 <xQueueGenericReceive+0xa0>
     eae:	f7 01       	movw	r30, r14
     eb0:	d7 82       	std	Z+7, r13	; 0x07
     eb2:	c6 82       	std	Z+6, r12	; 0x06
     eb4:	83 89       	ldd	r24, Z+19	; 0x13
     eb6:	88 23       	and	r24, r24
     eb8:	29 f0       	breq	.+10     	; 0xec4 <xQueueGenericReceive+0xa0>
     eba:	c7 01       	movw	r24, r14
     ebc:	43 96       	adiw	r24, 0x13	; 19
     ebe:	bd d4       	rcall	.+2426   	; 0x183a <xTaskRemoveFromEventList>
     ec0:	81 11       	cpse	r24, r1
     ec2:	3a dd       	rcall	.-1420   	; 0x938 <vPortYield>
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	56 c0       	rjmp	.+172    	; 0xf78 <xQueueGenericReceive+0x154>
     ecc:	8e 81       	ldd	r24, Y+6	; 0x06
     ece:	9f 81       	ldd	r25, Y+7	; 0x07
     ed0:	a8 85       	ldd	r26, Y+8	; 0x08
     ed2:	b9 85       	ldd	r27, Y+9	; 0x09
     ed4:	89 2b       	or	r24, r25
     ed6:	8a 2b       	or	r24, r26
     ed8:	8b 2b       	or	r24, r27
     eda:	21 f4       	brne	.+8      	; 0xee4 <xQueueGenericReceive+0xc0>
     edc:	0f 90       	pop	r0
     ede:	0f be       	out	0x3f, r0	; 63
     ee0:	80 e0       	ldi	r24, 0x00	; 0
     ee2:	4a c0       	rjmp	.+148    	; 0xf78 <xQueueGenericReceive+0x154>
     ee4:	11 11       	cpse	r17, r1
     ee6:	04 c0       	rjmp	.+8      	; 0xef0 <xQueueGenericReceive+0xcc>
     ee8:	ce 01       	movw	r24, r28
     eea:	01 96       	adiw	r24, 0x01	; 1
     eec:	e8 d4       	rcall	.+2512   	; 0x18be <vTaskSetTimeOutState>
     eee:	19 2d       	mov	r17, r9
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
     ef4:	f8 d1       	rcall	.+1008   	; 0x12e6 <vTaskSuspendAll>
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	f8 94       	cli
     efa:	0f 92       	push	r0
     efc:	f7 01       	movw	r30, r14
     efe:	81 a1       	ldd	r24, Z+33	; 0x21
     f00:	8f 3f       	cpi	r24, 0xFF	; 255
     f02:	09 f4       	brne	.+2      	; 0xf06 <xQueueGenericReceive+0xe2>
     f04:	11 a2       	std	Z+33, r1	; 0x21
     f06:	f7 01       	movw	r30, r14
     f08:	82 a1       	ldd	r24, Z+34	; 0x22
     f0a:	8f 3f       	cpi	r24, 0xFF	; 255
     f0c:	09 f4       	brne	.+2      	; 0xf10 <xQueueGenericReceive+0xec>
     f0e:	12 a2       	std	Z+34, r1	; 0x22
     f10:	0f 90       	pop	r0
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	be 01       	movw	r22, r28
     f16:	6a 5f       	subi	r22, 0xFA	; 250
     f18:	7f 4f       	sbci	r23, 0xFF	; 255
     f1a:	ce 01       	movw	r24, r28
     f1c:	01 96       	adiw	r24, 0x01	; 1
     f1e:	e0 d4       	rcall	.+2496   	; 0x18e0 <xTaskCheckForTimeOut>
     f20:	81 11       	cpse	r24, r1
     f22:	26 c0       	rjmp	.+76     	; 0xf70 <xQueueGenericReceive+0x14c>
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	f8 94       	cli
     f28:	0f 92       	push	r0
     f2a:	f7 01       	movw	r30, r14
     f2c:	86 8d       	ldd	r24, Z+30	; 0x1e
     f2e:	0f 90       	pop	r0
     f30:	0f be       	out	0x3f, r0	; 63
     f32:	81 11       	cpse	r24, r1
     f34:	19 c0       	rjmp	.+50     	; 0xf68 <xQueueGenericReceive+0x144>
     f36:	80 81       	ld	r24, Z
     f38:	91 81       	ldd	r25, Z+1	; 0x01
     f3a:	89 2b       	or	r24, r25
     f3c:	41 f4       	brne	.+16     	; 0xf4e <xQueueGenericReceive+0x12a>
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	0f 92       	push	r0
     f44:	82 81       	ldd	r24, Z+2	; 0x02
     f46:	93 81       	ldd	r25, Z+3	; 0x03
     f48:	46 d5       	rcall	.+2700   	; 0x19d6 <vTaskPriorityInherit>
     f4a:	0f 90       	pop	r0
     f4c:	0f be       	out	0x3f, r0	; 63
     f4e:	4e 81       	ldd	r20, Y+6	; 0x06
     f50:	5f 81       	ldd	r21, Y+7	; 0x07
     f52:	68 85       	ldd	r22, Y+8	; 0x08
     f54:	79 85       	ldd	r23, Y+9	; 0x09
     f56:	c6 01       	movw	r24, r12
     f58:	46 d4       	rcall	.+2188   	; 0x17e6 <vTaskPlaceOnEventList>
     f5a:	c7 01       	movw	r24, r14
     f5c:	1c de       	rcall	.-968    	; 0xb96 <prvUnlockQueue>
     f5e:	e4 d2       	rcall	.+1480   	; 0x1528 <xTaskResumeAll>
     f60:	81 11       	cpse	r24, r1
     f62:	80 cf       	rjmp	.-256    	; 0xe64 <xQueueGenericReceive+0x40>
     f64:	e9 dc       	rcall	.-1582   	; 0x938 <vPortYield>
     f66:	7e cf       	rjmp	.-260    	; 0xe64 <xQueueGenericReceive+0x40>
     f68:	c7 01       	movw	r24, r14
     f6a:	15 de       	rcall	.-982    	; 0xb96 <prvUnlockQueue>
     f6c:	dd d2       	rcall	.+1466   	; 0x1528 <xTaskResumeAll>
     f6e:	7a cf       	rjmp	.-268    	; 0xe64 <xQueueGenericReceive+0x40>
     f70:	c7 01       	movw	r24, r14
     f72:	11 de       	rcall	.-990    	; 0xb96 <prvUnlockQueue>
     f74:	d9 d2       	rcall	.+1458   	; 0x1528 <xTaskResumeAll>
     f76:	80 e0       	ldi	r24, 0x00	; 0
     f78:	29 96       	adiw	r28, 0x09	; 9
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	de bf       	out	0x3e, r29	; 62
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	cd bf       	out	0x3d, r28	; 61
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	0f 91       	pop	r16
     f8c:	ff 90       	pop	r15
     f8e:	ef 90       	pop	r14
     f90:	df 90       	pop	r13
     f92:	cf 90       	pop	r12
     f94:	bf 90       	pop	r11
     f96:	af 90       	pop	r10
     f98:	9f 90       	pop	r9
     f9a:	08 95       	ret

00000f9c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
     f9c:	0f b6       	in	r0, 0x3f	; 63
     f9e:	f8 94       	cli
     fa0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     fa2:	fc 01       	movw	r30, r24
     fa4:	86 8d       	ldd	r24, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     faa:	08 95       	ret

00000fac <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	f8 94       	cli
     fb0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
     fb2:	fc 01       	movw	r30, r24
     fb4:	26 8d       	ldd	r18, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
     fb6:	0f 90       	pop	r0
     fb8:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
     fba:	87 8d       	ldd	r24, Z+31	; 0x1f
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     fbc:	82 1b       	sub	r24, r18
     fbe:	08 95       	ret

00000fc0 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     fc0:	cc ef       	ldi	r28, 0xFC	; 252
     fc2:	d9 e1       	ldi	r29, 0x19	; 25
     fc4:	88 81       	ld	r24, Y
     fc6:	82 30       	cpi	r24, 0x02	; 2
     fc8:	f0 f3       	brcs	.-4      	; 0xfc6 <prvIdleTask+0x6>
     fca:	b6 dc       	rcall	.-1684   	; 0x938 <vPortYield>
     fcc:	fb cf       	rjmp	.-10     	; 0xfc4 <prvIdleTask+0x4>

00000fce <prvAddCurrentTaskToDelayedList>:
     fce:	cf 92       	push	r12
     fd0:	df 92       	push	r13
     fd2:	ef 92       	push	r14
     fd4:	ff 92       	push	r15
     fd6:	6b 01       	movw	r12, r22
     fd8:	7c 01       	movw	r14, r24
     fda:	e0 91 28 1a 	lds	r30, 0x1A28
     fde:	f0 91 29 1a 	lds	r31, 0x1A29
     fe2:	62 83       	std	Z+2, r22	; 0x02
     fe4:	73 83       	std	Z+3, r23	; 0x03
     fe6:	84 83       	std	Z+4, r24	; 0x04
     fe8:	95 83       	std	Z+5, r25	; 0x05
     fea:	80 91 d0 19 	lds	r24, 0x19D0
     fee:	90 91 d1 19 	lds	r25, 0x19D1
     ff2:	a0 91 d2 19 	lds	r26, 0x19D2
     ff6:	b0 91 d3 19 	lds	r27, 0x19D3
     ffa:	c8 16       	cp	r12, r24
     ffc:	d9 06       	cpc	r13, r25
     ffe:	ea 06       	cpc	r14, r26
    1000:	fb 06       	cpc	r15, r27
    1002:	60 f4       	brcc	.+24     	; 0x101c <prvAddCurrentTaskToDelayedList+0x4e>
    1004:	60 91 28 1a 	lds	r22, 0x1A28
    1008:	70 91 29 1a 	lds	r23, 0x1A29
    100c:	80 91 e2 19 	lds	r24, 0x19E2
    1010:	90 91 e3 19 	lds	r25, 0x19E3
    1014:	6e 5f       	subi	r22, 0xFE	; 254
    1016:	7f 4f       	sbci	r23, 0xFF	; 255
    1018:	81 db       	rcall	.-2302   	; 0x71c <vListInsert>
    101a:	20 c0       	rjmp	.+64     	; 0x105c <prvAddCurrentTaskToDelayedList+0x8e>
    101c:	60 91 28 1a 	lds	r22, 0x1A28
    1020:	70 91 29 1a 	lds	r23, 0x1A29
    1024:	80 91 e4 19 	lds	r24, 0x19E4
    1028:	90 91 e5 19 	lds	r25, 0x19E5
    102c:	6e 5f       	subi	r22, 0xFE	; 254
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	75 db       	rcall	.-2326   	; 0x71c <vListInsert>
    1032:	80 91 02 02 	lds	r24, 0x0202
    1036:	90 91 03 02 	lds	r25, 0x0203
    103a:	a0 91 04 02 	lds	r26, 0x0204
    103e:	b0 91 05 02 	lds	r27, 0x0205
    1042:	c8 16       	cp	r12, r24
    1044:	d9 06       	cpc	r13, r25
    1046:	ea 06       	cpc	r14, r26
    1048:	fb 06       	cpc	r15, r27
    104a:	40 f4       	brcc	.+16     	; 0x105c <prvAddCurrentTaskToDelayedList+0x8e>
    104c:	c0 92 02 02 	sts	0x0202, r12
    1050:	d0 92 03 02 	sts	0x0203, r13
    1054:	e0 92 04 02 	sts	0x0204, r14
    1058:	f0 92 05 02 	sts	0x0205, r15
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	df 90       	pop	r13
    1062:	cf 90       	pop	r12
    1064:	08 95       	ret

00001066 <xTaskGenericCreate>:
    1066:	4f 92       	push	r4
    1068:	5f 92       	push	r5
    106a:	6f 92       	push	r6
    106c:	7f 92       	push	r7
    106e:	8f 92       	push	r8
    1070:	9f 92       	push	r9
    1072:	af 92       	push	r10
    1074:	bf 92       	push	r11
    1076:	cf 92       	push	r12
    1078:	df 92       	push	r13
    107a:	ef 92       	push	r14
    107c:	ff 92       	push	r15
    107e:	0f 93       	push	r16
    1080:	1f 93       	push	r17
    1082:	cf 93       	push	r28
    1084:	df 93       	push	r29
    1086:	4c 01       	movw	r8, r24
    1088:	eb 01       	movw	r28, r22
    108a:	5a 01       	movw	r10, r20
    108c:	29 01       	movw	r4, r18
    108e:	89 e2       	ldi	r24, 0x29	; 41
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	40 da       	rcall	.-2944   	; 0x514 <pvPortMalloc>
    1094:	3c 01       	movw	r6, r24
    1096:	00 97       	sbiw	r24, 0x00	; 0
    1098:	09 f4       	brne	.+2      	; 0x109c <xTaskGenericCreate+0x36>
    109a:	d4 c0       	rjmp	.+424    	; 0x1244 <xTaskGenericCreate+0x1de>
    109c:	c1 14       	cp	r12, r1
    109e:	d1 04       	cpc	r13, r1
    10a0:	09 f0       	breq	.+2      	; 0x10a4 <xTaskGenericCreate+0x3e>
    10a2:	cb c0       	rjmp	.+406    	; 0x123a <xTaskGenericCreate+0x1d4>
    10a4:	c5 01       	movw	r24, r10
    10a6:	36 da       	rcall	.-2964   	; 0x514 <pvPortMalloc>
    10a8:	f3 01       	movw	r30, r6
    10aa:	94 8f       	std	Z+28, r25	; 0x1c
    10ac:	83 8f       	std	Z+27, r24	; 0x1b
    10ae:	00 97       	sbiw	r24, 0x00	; 0
    10b0:	19 f4       	brne	.+6      	; 0x10b8 <xTaskGenericCreate+0x52>
    10b2:	c3 01       	movw	r24, r6
    10b4:	c7 da       	rcall	.-2674   	; 0x644 <vPortFree>
    10b6:	c6 c0       	rjmp	.+396    	; 0x1244 <xTaskGenericCreate+0x1de>
    10b8:	a5 01       	movw	r20, r10
    10ba:	65 ea       	ldi	r22, 0xA5	; 165
    10bc:	70 e0       	ldi	r23, 0x00	; 0
    10be:	0e 94 b0 19 	call	0x3360	; 0x3360 <memset>
    10c2:	f1 e0       	ldi	r31, 0x01	; 1
    10c4:	af 1a       	sub	r10, r31
    10c6:	b1 08       	sbc	r11, r1
    10c8:	f3 01       	movw	r30, r6
    10ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    10cc:	94 8d       	ldd	r25, Z+28	; 0x1c
    10ce:	a8 0e       	add	r10, r24
    10d0:	b9 1e       	adc	r11, r25
    10d2:	88 81       	ld	r24, Y
    10d4:	85 8f       	std	Z+29, r24	; 0x1d
    10d6:	88 81       	ld	r24, Y
    10d8:	88 23       	and	r24, r24
    10da:	81 f0       	breq	.+32     	; 0x10fc <xTaskGenericCreate+0x96>
    10dc:	d3 01       	movw	r26, r6
    10de:	5e 96       	adiw	r26, 0x1e	; 30
    10e0:	fe 01       	movw	r30, r28
    10e2:	31 96       	adiw	r30, 0x01	; 1
    10e4:	9e 01       	movw	r18, r28
    10e6:	26 5f       	subi	r18, 0xF6	; 246
    10e8:	3f 4f       	sbci	r19, 0xFF	; 255
    10ea:	ef 01       	movw	r28, r30
    10ec:	81 91       	ld	r24, Z+
    10ee:	8d 93       	st	X+, r24
    10f0:	88 81       	ld	r24, Y
    10f2:	88 23       	and	r24, r24
    10f4:	19 f0       	breq	.+6      	; 0x10fc <xTaskGenericCreate+0x96>
    10f6:	e2 17       	cp	r30, r18
    10f8:	f3 07       	cpc	r31, r19
    10fa:	b9 f7       	brne	.-18     	; 0x10ea <xTaskGenericCreate+0x84>
    10fc:	f3 01       	movw	r30, r6
    10fe:	16 a2       	std	Z+38, r1	; 0x26
    1100:	10 2f       	mov	r17, r16
    1102:	04 30       	cpi	r16, 0x04	; 4
    1104:	08 f0       	brcs	.+2      	; 0x1108 <xTaskGenericCreate+0xa2>
    1106:	13 e0       	ldi	r17, 0x03	; 3
    1108:	f3 01       	movw	r30, r6
    110a:	12 8f       	std	Z+26, r17	; 0x1a
    110c:	17 a3       	std	Z+39, r17	; 0x27
    110e:	10 a6       	std	Z+40, r1	; 0x28
    1110:	e3 01       	movw	r28, r6
    1112:	22 96       	adiw	r28, 0x02	; 2
    1114:	ce 01       	movw	r24, r28
    1116:	dd da       	rcall	.-2630   	; 0x6d2 <vListInitialiseItem>
    1118:	c3 01       	movw	r24, r6
    111a:	0e 96       	adiw	r24, 0x0e	; 14
    111c:	da da       	rcall	.-2636   	; 0x6d2 <vListInitialiseItem>
    111e:	f3 01       	movw	r30, r6
    1120:	73 86       	std	Z+11, r7	; 0x0b
    1122:	62 86       	std	Z+10, r6	; 0x0a
    1124:	84 e0       	ldi	r24, 0x04	; 4
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	a0 e0       	ldi	r26, 0x00	; 0
    112a:	b0 e0       	ldi	r27, 0x00	; 0
    112c:	81 1b       	sub	r24, r17
    112e:	91 09       	sbc	r25, r1
    1130:	a1 09       	sbc	r26, r1
    1132:	b1 09       	sbc	r27, r1
    1134:	86 87       	std	Z+14, r24	; 0x0e
    1136:	97 87       	std	Z+15, r25	; 0x0f
    1138:	a0 8b       	std	Z+16, r26	; 0x10
    113a:	b1 8b       	std	Z+17, r27	; 0x11
    113c:	77 8a       	std	Z+23, r7	; 0x17
    113e:	66 8a       	std	Z+22, r6	; 0x16
    1140:	a2 01       	movw	r20, r4
    1142:	b4 01       	movw	r22, r8
    1144:	c5 01       	movw	r24, r10
    1146:	4d db       	rcall	.-2406   	; 0x7e2 <pxPortInitialiseStack>
    1148:	f3 01       	movw	r30, r6
    114a:	91 83       	std	Z+1, r25	; 0x01
    114c:	80 83       	st	Z, r24
    114e:	e1 14       	cp	r14, r1
    1150:	f1 04       	cpc	r15, r1
    1152:	19 f0       	breq	.+6      	; 0x115a <xTaskGenericCreate+0xf4>
    1154:	f7 01       	movw	r30, r14
    1156:	71 82       	std	Z+1, r7	; 0x01
    1158:	60 82       	st	Z, r6
    115a:	0f b6       	in	r0, 0x3f	; 63
    115c:	f8 94       	cli
    115e:	0f 92       	push	r0
    1160:	80 91 d4 19 	lds	r24, 0x19D4
    1164:	8f 5f       	subi	r24, 0xFF	; 255
    1166:	80 93 d4 19 	sts	0x19D4, r24
    116a:	80 91 28 1a 	lds	r24, 0x1A28
    116e:	90 91 29 1a 	lds	r25, 0x1A29
    1172:	89 2b       	or	r24, r25
    1174:	51 f5       	brne	.+84     	; 0x11ca <xTaskGenericCreate+0x164>
    1176:	70 92 29 1a 	sts	0x1A29, r7
    117a:	60 92 28 1a 	sts	0x1A28, r6
    117e:	80 91 d4 19 	lds	r24, 0x19D4
    1182:	81 30       	cpi	r24, 0x01	; 1
    1184:	89 f5       	brne	.+98     	; 0x11e8 <xTaskGenericCreate+0x182>
    1186:	8c ef       	ldi	r24, 0xFC	; 252
    1188:	99 e1       	ldi	r25, 0x19	; 25
    118a:	92 da       	rcall	.-2780   	; 0x6b0 <vListInitialise>
    118c:	87 e0       	ldi	r24, 0x07	; 7
    118e:	9a e1       	ldi	r25, 0x1A	; 26
    1190:	8f da       	rcall	.-2786   	; 0x6b0 <vListInitialise>
    1192:	82 e1       	ldi	r24, 0x12	; 18
    1194:	9a e1       	ldi	r25, 0x1A	; 26
    1196:	8c da       	rcall	.-2792   	; 0x6b0 <vListInitialise>
    1198:	8d e1       	ldi	r24, 0x1D	; 29
    119a:	9a e1       	ldi	r25, 0x1A	; 26
    119c:	89 da       	rcall	.-2798   	; 0x6b0 <vListInitialise>
    119e:	81 ef       	ldi	r24, 0xF1	; 241
    11a0:	99 e1       	ldi	r25, 0x19	; 25
    11a2:	86 da       	rcall	.-2804   	; 0x6b0 <vListInitialise>
    11a4:	86 ee       	ldi	r24, 0xE6	; 230
    11a6:	99 e1       	ldi	r25, 0x19	; 25
    11a8:	83 da       	rcall	.-2810   	; 0x6b0 <vListInitialise>
    11aa:	87 ed       	ldi	r24, 0xD7	; 215
    11ac:	99 e1       	ldi	r25, 0x19	; 25
    11ae:	80 da       	rcall	.-2816   	; 0x6b0 <vListInitialise>
    11b0:	81 ef       	ldi	r24, 0xF1	; 241
    11b2:	99 e1       	ldi	r25, 0x19	; 25
    11b4:	90 93 e5 19 	sts	0x19E5, r25
    11b8:	80 93 e4 19 	sts	0x19E4, r24
    11bc:	86 ee       	ldi	r24, 0xE6	; 230
    11be:	99 e1       	ldi	r25, 0x19	; 25
    11c0:	90 93 e3 19 	sts	0x19E3, r25
    11c4:	80 93 e2 19 	sts	0x19E2, r24
    11c8:	0f c0       	rjmp	.+30     	; 0x11e8 <xTaskGenericCreate+0x182>
    11ca:	80 91 ce 19 	lds	r24, 0x19CE
    11ce:	81 11       	cpse	r24, r1
    11d0:	0b c0       	rjmp	.+22     	; 0x11e8 <xTaskGenericCreate+0x182>
    11d2:	e0 91 28 1a 	lds	r30, 0x1A28
    11d6:	f0 91 29 1a 	lds	r31, 0x1A29
    11da:	82 8d       	ldd	r24, Z+26	; 0x1a
    11dc:	08 17       	cp	r16, r24
    11de:	20 f0       	brcs	.+8      	; 0x11e8 <xTaskGenericCreate+0x182>
    11e0:	70 92 29 1a 	sts	0x1A29, r7
    11e4:	60 92 28 1a 	sts	0x1A28, r6
    11e8:	80 91 ca 19 	lds	r24, 0x19CA
    11ec:	8f 5f       	subi	r24, 0xFF	; 255
    11ee:	80 93 ca 19 	sts	0x19CA, r24
    11f2:	f3 01       	movw	r30, r6
    11f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    11f6:	90 91 cf 19 	lds	r25, 0x19CF
    11fa:	98 17       	cp	r25, r24
    11fc:	10 f4       	brcc	.+4      	; 0x1202 <xTaskGenericCreate+0x19c>
    11fe:	80 93 cf 19 	sts	0x19CF, r24
    1202:	fb e0       	ldi	r31, 0x0B	; 11
    1204:	8f 9f       	mul	r24, r31
    1206:	c0 01       	movw	r24, r0
    1208:	11 24       	eor	r1, r1
    120a:	be 01       	movw	r22, r28
    120c:	84 50       	subi	r24, 0x04	; 4
    120e:	96 4e       	sbci	r25, 0xE6	; 230
    1210:	64 da       	rcall	.-2872   	; 0x6da <vListInsertEnd>
    1212:	0f 90       	pop	r0
    1214:	0f be       	out	0x3f, r0	; 63
    1216:	80 91 ce 19 	lds	r24, 0x19CE
    121a:	88 23       	and	r24, r24
    121c:	51 f0       	breq	.+20     	; 0x1232 <xTaskGenericCreate+0x1cc>
    121e:	e0 91 28 1a 	lds	r30, 0x1A28
    1222:	f0 91 29 1a 	lds	r31, 0x1A29
    1226:	82 8d       	ldd	r24, Z+26	; 0x1a
    1228:	80 17       	cp	r24, r16
    122a:	28 f4       	brcc	.+10     	; 0x1236 <xTaskGenericCreate+0x1d0>
    122c:	85 db       	rcall	.-2294   	; 0x938 <vPortYield>
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	0a c0       	rjmp	.+20     	; 0x1246 <xTaskGenericCreate+0x1e0>
    1232:	81 e0       	ldi	r24, 0x01	; 1
    1234:	08 c0       	rjmp	.+16     	; 0x1246 <xTaskGenericCreate+0x1e0>
    1236:	81 e0       	ldi	r24, 0x01	; 1
    1238:	06 c0       	rjmp	.+12     	; 0x1246 <xTaskGenericCreate+0x1e0>
    123a:	fc 01       	movw	r30, r24
    123c:	d4 8e       	std	Z+28, r13	; 0x1c
    123e:	c3 8e       	std	Z+27, r12	; 0x1b
    1240:	c6 01       	movw	r24, r12
    1242:	3a cf       	rjmp	.-396    	; 0x10b8 <xTaskGenericCreate+0x52>
    1244:	8f ef       	ldi	r24, 0xFF	; 255
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	1f 91       	pop	r17
    124c:	0f 91       	pop	r16
    124e:	ff 90       	pop	r15
    1250:	ef 90       	pop	r14
    1252:	df 90       	pop	r13
    1254:	cf 90       	pop	r12
    1256:	bf 90       	pop	r11
    1258:	af 90       	pop	r10
    125a:	9f 90       	pop	r9
    125c:	8f 90       	pop	r8
    125e:	7f 90       	pop	r7
    1260:	6f 90       	pop	r6
    1262:	5f 90       	pop	r5
    1264:	4f 90       	pop	r4
    1266:	08 95       	ret

00001268 <uxTaskPriorityGet>:
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	0f 92       	push	r0
    126e:	00 97       	sbiw	r24, 0x00	; 0
    1270:	21 f4       	brne	.+8      	; 0x127a <uxTaskPriorityGet+0x12>
    1272:	80 91 28 1a 	lds	r24, 0x1A28
    1276:	90 91 29 1a 	lds	r25, 0x1A29
    127a:	0f 90       	pop	r0
    127c:	0f be       	out	0x3f, r0	; 63
    127e:	fc 01       	movw	r30, r24
    1280:	82 8d       	ldd	r24, Z+26	; 0x1a
    1282:	08 95       	ret

00001284 <vTaskStartScheduler>:
    1284:	af 92       	push	r10
    1286:	bf 92       	push	r11
    1288:	cf 92       	push	r12
    128a:	df 92       	push	r13
    128c:	ef 92       	push	r14
    128e:	ff 92       	push	r15
    1290:	0f 93       	push	r16
    1292:	a1 2c       	mov	r10, r1
    1294:	b1 2c       	mov	r11, r1
    1296:	c1 2c       	mov	r12, r1
    1298:	d1 2c       	mov	r13, r1
    129a:	0f 2e       	mov	r0, r31
    129c:	f5 ed       	ldi	r31, 0xD5	; 213
    129e:	ef 2e       	mov	r14, r31
    12a0:	f9 e1       	ldi	r31, 0x19	; 25
    12a2:	ff 2e       	mov	r15, r31
    12a4:	f0 2d       	mov	r31, r0
    12a6:	00 e0       	ldi	r16, 0x00	; 0
    12a8:	20 e0       	ldi	r18, 0x00	; 0
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	44 e6       	ldi	r20, 0x64	; 100
    12ae:	50 e0       	ldi	r21, 0x00	; 0
    12b0:	68 e0       	ldi	r22, 0x08	; 8
    12b2:	72 e0       	ldi	r23, 0x02	; 2
    12b4:	80 ee       	ldi	r24, 0xE0	; 224
    12b6:	97 e0       	ldi	r25, 0x07	; 7
    12b8:	d6 de       	rcall	.-596    	; 0x1066 <xTaskGenericCreate>
    12ba:	81 30       	cpi	r24, 0x01	; 1
    12bc:	61 f4       	brne	.+24     	; 0x12d6 <vTaskStartScheduler+0x52>
    12be:	f8 94       	cli
    12c0:	80 93 ce 19 	sts	0x19CE, r24
    12c4:	10 92 d0 19 	sts	0x19D0, r1
    12c8:	10 92 d1 19 	sts	0x19D1, r1
    12cc:	10 92 d2 19 	sts	0x19D2, r1
    12d0:	10 92 d3 19 	sts	0x19D3, r1
    12d4:	f6 da       	rcall	.-2580   	; 0x8c2 <xPortStartScheduler>
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	af 90       	pop	r10
    12e4:	08 95       	ret

000012e6 <vTaskSuspendAll>:
    12e6:	80 91 c9 19 	lds	r24, 0x19C9
    12ea:	8f 5f       	subi	r24, 0xFF	; 255
    12ec:	80 93 c9 19 	sts	0x19C9, r24
    12f0:	08 95       	ret

000012f2 <xTaskGetTickCount>:
    12f2:	0f b6       	in	r0, 0x3f	; 63
    12f4:	f8 94       	cli
    12f6:	0f 92       	push	r0
    12f8:	60 91 d0 19 	lds	r22, 0x19D0
    12fc:	70 91 d1 19 	lds	r23, 0x19D1
    1300:	80 91 d2 19 	lds	r24, 0x19D2
    1304:	90 91 d3 19 	lds	r25, 0x19D3
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	08 95       	ret

0000130e <pcTaskGetTaskName>:
    130e:	00 97       	sbiw	r24, 0x00	; 0
    1310:	21 f4       	brne	.+8      	; 0x131a <pcTaskGetTaskName+0xc>
    1312:	80 91 28 1a 	lds	r24, 0x1A28
    1316:	90 91 29 1a 	lds	r25, 0x1A29
    131a:	4d 96       	adiw	r24, 0x1d	; 29
    131c:	08 95       	ret

0000131e <xTaskGetIdleTaskHandle>:
    131e:	80 91 d5 19 	lds	r24, 0x19D5
    1322:	90 91 d6 19 	lds	r25, 0x19D6
    1326:	08 95       	ret

00001328 <xTaskIncrementTick>:
    1328:	9f 92       	push	r9
    132a:	af 92       	push	r10
    132c:	bf 92       	push	r11
    132e:	cf 92       	push	r12
    1330:	df 92       	push	r13
    1332:	ef 92       	push	r14
    1334:	ff 92       	push	r15
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	80 91 c9 19 	lds	r24, 0x19C9
    1342:	81 11       	cpse	r24, r1
    1344:	d8 c0       	rjmp	.+432    	; 0x14f6 <xTaskIncrementTick+0x1ce>
    1346:	80 91 d0 19 	lds	r24, 0x19D0
    134a:	90 91 d1 19 	lds	r25, 0x19D1
    134e:	a0 91 d2 19 	lds	r26, 0x19D2
    1352:	b0 91 d3 19 	lds	r27, 0x19D3
    1356:	01 96       	adiw	r24, 0x01	; 1
    1358:	a1 1d       	adc	r26, r1
    135a:	b1 1d       	adc	r27, r1
    135c:	80 93 d0 19 	sts	0x19D0, r24
    1360:	90 93 d1 19 	sts	0x19D1, r25
    1364:	a0 93 d2 19 	sts	0x19D2, r26
    1368:	b0 93 d3 19 	sts	0x19D3, r27
    136c:	c0 90 d0 19 	lds	r12, 0x19D0
    1370:	d0 90 d1 19 	lds	r13, 0x19D1
    1374:	e0 90 d2 19 	lds	r14, 0x19D2
    1378:	f0 90 d3 19 	lds	r15, 0x19D3
    137c:	c1 14       	cp	r12, r1
    137e:	d1 04       	cpc	r13, r1
    1380:	e1 04       	cpc	r14, r1
    1382:	f1 04       	cpc	r15, r1
    1384:	f1 f5       	brne	.+124    	; 0x1402 <xTaskIncrementTick+0xda>
    1386:	80 91 e4 19 	lds	r24, 0x19E4
    138a:	90 91 e5 19 	lds	r25, 0x19E5
    138e:	20 91 e2 19 	lds	r18, 0x19E2
    1392:	30 91 e3 19 	lds	r19, 0x19E3
    1396:	30 93 e5 19 	sts	0x19E5, r19
    139a:	20 93 e4 19 	sts	0x19E4, r18
    139e:	90 93 e3 19 	sts	0x19E3, r25
    13a2:	80 93 e2 19 	sts	0x19E2, r24
    13a6:	80 91 cb 19 	lds	r24, 0x19CB
    13aa:	8f 5f       	subi	r24, 0xFF	; 255
    13ac:	80 93 cb 19 	sts	0x19CB, r24
    13b0:	e0 91 e4 19 	lds	r30, 0x19E4
    13b4:	f0 91 e5 19 	lds	r31, 0x19E5
    13b8:	80 81       	ld	r24, Z
    13ba:	81 11       	cpse	r24, r1
    13bc:	0c c0       	rjmp	.+24     	; 0x13d6 <xTaskIncrementTick+0xae>
    13be:	8f ef       	ldi	r24, 0xFF	; 255
    13c0:	9f ef       	ldi	r25, 0xFF	; 255
    13c2:	dc 01       	movw	r26, r24
    13c4:	80 93 02 02 	sts	0x0202, r24
    13c8:	90 93 03 02 	sts	0x0203, r25
    13cc:	a0 93 04 02 	sts	0x0204, r26
    13d0:	b0 93 05 02 	sts	0x0205, r27
    13d4:	16 c0       	rjmp	.+44     	; 0x1402 <xTaskIncrementTick+0xda>
    13d6:	e0 91 e4 19 	lds	r30, 0x19E4
    13da:	f0 91 e5 19 	lds	r31, 0x19E5
    13de:	07 80       	ldd	r0, Z+7	; 0x07
    13e0:	f0 85       	ldd	r31, Z+8	; 0x08
    13e2:	e0 2d       	mov	r30, r0
    13e4:	00 84       	ldd	r0, Z+8	; 0x08
    13e6:	f1 85       	ldd	r31, Z+9	; 0x09
    13e8:	e0 2d       	mov	r30, r0
    13ea:	82 81       	ldd	r24, Z+2	; 0x02
    13ec:	93 81       	ldd	r25, Z+3	; 0x03
    13ee:	a4 81       	ldd	r26, Z+4	; 0x04
    13f0:	b5 81       	ldd	r27, Z+5	; 0x05
    13f2:	80 93 02 02 	sts	0x0202, r24
    13f6:	90 93 03 02 	sts	0x0203, r25
    13fa:	a0 93 04 02 	sts	0x0204, r26
    13fe:	b0 93 05 02 	sts	0x0205, r27
    1402:	80 91 02 02 	lds	r24, 0x0202
    1406:	90 91 03 02 	lds	r25, 0x0203
    140a:	a0 91 04 02 	lds	r26, 0x0204
    140e:	b0 91 05 02 	lds	r27, 0x0205
    1412:	c8 16       	cp	r12, r24
    1414:	d9 06       	cpc	r13, r25
    1416:	ea 06       	cpc	r14, r26
    1418:	fb 06       	cpc	r15, r27
    141a:	10 f4       	brcc	.+4      	; 0x1420 <xTaskIncrementTick+0xf8>
    141c:	b1 2c       	mov	r11, r1
    141e:	5a c0       	rjmp	.+180    	; 0x14d4 <xTaskIncrementTick+0x1ac>
    1420:	b1 2c       	mov	r11, r1
    1422:	0f 2e       	mov	r0, r31
    1424:	fb e0       	ldi	r31, 0x0B	; 11
    1426:	af 2e       	mov	r10, r31
    1428:	f0 2d       	mov	r31, r0
    142a:	99 24       	eor	r9, r9
    142c:	93 94       	inc	r9
    142e:	e0 91 e4 19 	lds	r30, 0x19E4
    1432:	f0 91 e5 19 	lds	r31, 0x19E5
    1436:	90 81       	ld	r25, Z
    1438:	91 11       	cpse	r25, r1
    143a:	0c c0       	rjmp	.+24     	; 0x1454 <xTaskIncrementTick+0x12c>
    143c:	8f ef       	ldi	r24, 0xFF	; 255
    143e:	9f ef       	ldi	r25, 0xFF	; 255
    1440:	dc 01       	movw	r26, r24
    1442:	80 93 02 02 	sts	0x0202, r24
    1446:	90 93 03 02 	sts	0x0203, r25
    144a:	a0 93 04 02 	sts	0x0204, r26
    144e:	b0 93 05 02 	sts	0x0205, r27
    1452:	40 c0       	rjmp	.+128    	; 0x14d4 <xTaskIncrementTick+0x1ac>
    1454:	e0 91 e4 19 	lds	r30, 0x19E4
    1458:	f0 91 e5 19 	lds	r31, 0x19E5
    145c:	07 80       	ldd	r0, Z+7	; 0x07
    145e:	f0 85       	ldd	r31, Z+8	; 0x08
    1460:	e0 2d       	mov	r30, r0
    1462:	c0 85       	ldd	r28, Z+8	; 0x08
    1464:	d1 85       	ldd	r29, Z+9	; 0x09
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	9b 81       	ldd	r25, Y+3	; 0x03
    146a:	ac 81       	ldd	r26, Y+4	; 0x04
    146c:	bd 81       	ldd	r27, Y+5	; 0x05
    146e:	c8 16       	cp	r12, r24
    1470:	d9 06       	cpc	r13, r25
    1472:	ea 06       	cpc	r14, r26
    1474:	fb 06       	cpc	r15, r27
    1476:	48 f4       	brcc	.+18     	; 0x148a <xTaskIncrementTick+0x162>
    1478:	80 93 02 02 	sts	0x0202, r24
    147c:	90 93 03 02 	sts	0x0203, r25
    1480:	a0 93 04 02 	sts	0x0204, r26
    1484:	b0 93 05 02 	sts	0x0205, r27
    1488:	25 c0       	rjmp	.+74     	; 0x14d4 <xTaskIncrementTick+0x1ac>
    148a:	8e 01       	movw	r16, r28
    148c:	0e 5f       	subi	r16, 0xFE	; 254
    148e:	1f 4f       	sbci	r17, 0xFF	; 255
    1490:	c8 01       	movw	r24, r16
    1492:	81 d9       	rcall	.-3326   	; 0x796 <uxListRemove>
    1494:	88 8d       	ldd	r24, Y+24	; 0x18
    1496:	99 8d       	ldd	r25, Y+25	; 0x19
    1498:	89 2b       	or	r24, r25
    149a:	19 f0       	breq	.+6      	; 0x14a2 <xTaskIncrementTick+0x17a>
    149c:	ce 01       	movw	r24, r28
    149e:	0e 96       	adiw	r24, 0x0e	; 14
    14a0:	7a d9       	rcall	.-3340   	; 0x796 <uxListRemove>
    14a2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    14a4:	80 91 cf 19 	lds	r24, 0x19CF
    14a8:	82 17       	cp	r24, r18
    14aa:	10 f4       	brcc	.+4      	; 0x14b0 <xTaskIncrementTick+0x188>
    14ac:	20 93 cf 19 	sts	0x19CF, r18
    14b0:	a2 9e       	mul	r10, r18
    14b2:	c0 01       	movw	r24, r0
    14b4:	11 24       	eor	r1, r1
    14b6:	b8 01       	movw	r22, r16
    14b8:	84 50       	subi	r24, 0x04	; 4
    14ba:	96 4e       	sbci	r25, 0xE6	; 230
    14bc:	0e d9       	rcall	.-3556   	; 0x6da <vListInsertEnd>
    14be:	e0 91 28 1a 	lds	r30, 0x1A28
    14c2:	f0 91 29 1a 	lds	r31, 0x1A29
    14c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ca:	98 17       	cp	r25, r24
    14cc:	08 f4       	brcc	.+2      	; 0x14d0 <xTaskIncrementTick+0x1a8>
    14ce:	af cf       	rjmp	.-162    	; 0x142e <xTaskIncrementTick+0x106>
    14d0:	b9 2c       	mov	r11, r9
    14d2:	ad cf       	rjmp	.-166    	; 0x142e <xTaskIncrementTick+0x106>
    14d4:	e0 91 28 1a 	lds	r30, 0x1A28
    14d8:	f0 91 29 1a 	lds	r31, 0x1A29
    14dc:	e2 8d       	ldd	r30, Z+26	; 0x1a
    14de:	8b e0       	ldi	r24, 0x0B	; 11
    14e0:	e8 9f       	mul	r30, r24
    14e2:	f0 01       	movw	r30, r0
    14e4:	11 24       	eor	r1, r1
    14e6:	e4 50       	subi	r30, 0x04	; 4
    14e8:	f6 4e       	sbci	r31, 0xE6	; 230
    14ea:	80 81       	ld	r24, Z
    14ec:	82 30       	cpi	r24, 0x02	; 2
    14ee:	48 f0       	brcs	.+18     	; 0x1502 <xTaskIncrementTick+0x1da>
    14f0:	bb 24       	eor	r11, r11
    14f2:	b3 94       	inc	r11
    14f4:	06 c0       	rjmp	.+12     	; 0x1502 <xTaskIncrementTick+0x1da>
    14f6:	80 91 cd 19 	lds	r24, 0x19CD
    14fa:	8f 5f       	subi	r24, 0xFF	; 255
    14fc:	80 93 cd 19 	sts	0x19CD, r24
    1500:	b1 2c       	mov	r11, r1
    1502:	80 91 cc 19 	lds	r24, 0x19CC
    1506:	88 23       	and	r24, r24
    1508:	11 f0       	breq	.+4      	; 0x150e <xTaskIncrementTick+0x1e6>
    150a:	bb 24       	eor	r11, r11
    150c:	b3 94       	inc	r11
    150e:	8b 2d       	mov	r24, r11
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	df 90       	pop	r13
    151e:	cf 90       	pop	r12
    1520:	bf 90       	pop	r11
    1522:	af 90       	pop	r10
    1524:	9f 90       	pop	r9
    1526:	08 95       	ret

00001528 <xTaskResumeAll>:
    1528:	cf 92       	push	r12
    152a:	df 92       	push	r13
    152c:	ef 92       	push	r14
    152e:	ff 92       	push	r15
    1530:	0f 93       	push	r16
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	f8 94       	cli
    153c:	0f 92       	push	r0
    153e:	80 91 c9 19 	lds	r24, 0x19C9
    1542:	81 50       	subi	r24, 0x01	; 1
    1544:	80 93 c9 19 	sts	0x19C9, r24
    1548:	80 91 c9 19 	lds	r24, 0x19C9
    154c:	81 11       	cpse	r24, r1
    154e:	5a c0       	rjmp	.+180    	; 0x1604 <xTaskResumeAll+0xdc>
    1550:	80 91 d4 19 	lds	r24, 0x19D4
    1554:	81 11       	cpse	r24, r1
    1556:	29 c0       	rjmp	.+82     	; 0x15aa <xTaskResumeAll+0x82>
    1558:	58 c0       	rjmp	.+176    	; 0x160a <xTaskResumeAll+0xe2>
    155a:	d7 01       	movw	r26, r14
    155c:	17 96       	adiw	r26, 0x07	; 7
    155e:	ed 91       	ld	r30, X+
    1560:	fc 91       	ld	r31, X
    1562:	18 97       	sbiw	r26, 0x08	; 8
    1564:	c0 85       	ldd	r28, Z+8	; 0x08
    1566:	d1 85       	ldd	r29, Z+9	; 0x09
    1568:	ce 01       	movw	r24, r28
    156a:	0e 96       	adiw	r24, 0x0e	; 14
    156c:	14 d9       	rcall	.-3544   	; 0x796 <uxListRemove>
    156e:	8e 01       	movw	r16, r28
    1570:	0e 5f       	subi	r16, 0xFE	; 254
    1572:	1f 4f       	sbci	r17, 0xFF	; 255
    1574:	c8 01       	movw	r24, r16
    1576:	0f d9       	rcall	.-3554   	; 0x796 <uxListRemove>
    1578:	9a 8d       	ldd	r25, Y+26	; 0x1a
    157a:	80 91 cf 19 	lds	r24, 0x19CF
    157e:	89 17       	cp	r24, r25
    1580:	10 f4       	brcc	.+4      	; 0x1586 <xTaskResumeAll+0x5e>
    1582:	90 93 cf 19 	sts	0x19CF, r25
    1586:	d9 9e       	mul	r13, r25
    1588:	c0 01       	movw	r24, r0
    158a:	11 24       	eor	r1, r1
    158c:	b8 01       	movw	r22, r16
    158e:	84 50       	subi	r24, 0x04	; 4
    1590:	96 4e       	sbci	r25, 0xE6	; 230
    1592:	a3 d8       	rcall	.-3770   	; 0x6da <vListInsertEnd>
    1594:	e0 91 28 1a 	lds	r30, 0x1A28
    1598:	f0 91 29 1a 	lds	r31, 0x1A29
    159c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    159e:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a0:	98 17       	cp	r25, r24
    15a2:	78 f0       	brcs	.+30     	; 0x15c2 <xTaskResumeAll+0x9a>
    15a4:	c0 92 cc 19 	sts	0x19CC, r12
    15a8:	0c c0       	rjmp	.+24     	; 0x15c2 <xTaskResumeAll+0x9a>
    15aa:	0f 2e       	mov	r0, r31
    15ac:	f7 ed       	ldi	r31, 0xD7	; 215
    15ae:	ef 2e       	mov	r14, r31
    15b0:	f9 e1       	ldi	r31, 0x19	; 25
    15b2:	ff 2e       	mov	r15, r31
    15b4:	f0 2d       	mov	r31, r0
    15b6:	0f 2e       	mov	r0, r31
    15b8:	fb e0       	ldi	r31, 0x0B	; 11
    15ba:	df 2e       	mov	r13, r31
    15bc:	f0 2d       	mov	r31, r0
    15be:	cc 24       	eor	r12, r12
    15c0:	c3 94       	inc	r12
    15c2:	f7 01       	movw	r30, r14
    15c4:	80 81       	ld	r24, Z
    15c6:	81 11       	cpse	r24, r1
    15c8:	c8 cf       	rjmp	.-112    	; 0x155a <xTaskResumeAll+0x32>
    15ca:	80 91 cd 19 	lds	r24, 0x19CD
    15ce:	88 23       	and	r24, r24
    15d0:	91 f0       	breq	.+36     	; 0x15f6 <xTaskResumeAll+0xce>
    15d2:	80 91 cd 19 	lds	r24, 0x19CD
    15d6:	88 23       	and	r24, r24
    15d8:	71 f0       	breq	.+28     	; 0x15f6 <xTaskResumeAll+0xce>
    15da:	c1 e0       	ldi	r28, 0x01	; 1
    15dc:	a5 de       	rcall	.-694    	; 0x1328 <xTaskIncrementTick>
    15de:	81 11       	cpse	r24, r1
    15e0:	c0 93 cc 19 	sts	0x19CC, r28
    15e4:	80 91 cd 19 	lds	r24, 0x19CD
    15e8:	81 50       	subi	r24, 0x01	; 1
    15ea:	80 93 cd 19 	sts	0x19CD, r24
    15ee:	80 91 cd 19 	lds	r24, 0x19CD
    15f2:	81 11       	cpse	r24, r1
    15f4:	f3 cf       	rjmp	.-26     	; 0x15dc <xTaskResumeAll+0xb4>
    15f6:	80 91 cc 19 	lds	r24, 0x19CC
    15fa:	81 30       	cpi	r24, 0x01	; 1
    15fc:	29 f4       	brne	.+10     	; 0x1608 <xTaskResumeAll+0xe0>
    15fe:	9c d9       	rcall	.-3272   	; 0x938 <vPortYield>
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	03 c0       	rjmp	.+6      	; 0x160a <xTaskResumeAll+0xe2>
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	01 c0       	rjmp	.+2      	; 0x160a <xTaskResumeAll+0xe2>
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	0f 90       	pop	r0
    160c:	0f be       	out	0x3f, r0	; 63
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	1f 91       	pop	r17
    1614:	0f 91       	pop	r16
    1616:	ff 90       	pop	r15
    1618:	ef 90       	pop	r14
    161a:	df 90       	pop	r13
    161c:	cf 90       	pop	r12
    161e:	08 95       	ret

00001620 <vTaskDelayUntil>:
    1620:	cf 92       	push	r12
    1622:	df 92       	push	r13
    1624:	ef 92       	push	r14
    1626:	ff 92       	push	r15
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	ec 01       	movw	r28, r24
    1632:	6a 01       	movw	r12, r20
    1634:	7b 01       	movw	r14, r22
    1636:	57 de       	rcall	.-850    	; 0x12e6 <vTaskSuspendAll>
    1638:	80 91 d0 19 	lds	r24, 0x19D0
    163c:	90 91 d1 19 	lds	r25, 0x19D1
    1640:	a0 91 d2 19 	lds	r26, 0x19D2
    1644:	b0 91 d3 19 	lds	r27, 0x19D3
    1648:	08 81       	ld	r16, Y
    164a:	19 81       	ldd	r17, Y+1	; 0x01
    164c:	2a 81       	ldd	r18, Y+2	; 0x02
    164e:	3b 81       	ldd	r19, Y+3	; 0x03
    1650:	c0 0e       	add	r12, r16
    1652:	d1 1e       	adc	r13, r17
    1654:	e2 1e       	adc	r14, r18
    1656:	f3 1e       	adc	r15, r19
    1658:	80 17       	cp	r24, r16
    165a:	91 07       	cpc	r25, r17
    165c:	a2 07       	cpc	r26, r18
    165e:	b3 07       	cpc	r27, r19
    1660:	78 f4       	brcc	.+30     	; 0x1680 <vTaskDelayUntil+0x60>
    1662:	c0 16       	cp	r12, r16
    1664:	d1 06       	cpc	r13, r17
    1666:	e2 06       	cpc	r14, r18
    1668:	f3 06       	cpc	r15, r19
    166a:	40 f5       	brcc	.+80     	; 0x16bc <vTaskDelayUntil+0x9c>
    166c:	c8 82       	st	Y, r12
    166e:	d9 82       	std	Y+1, r13	; 0x01
    1670:	ea 82       	std	Y+2, r14	; 0x02
    1672:	fb 82       	std	Y+3, r15	; 0x03
    1674:	8c 15       	cp	r24, r12
    1676:	9d 05       	cpc	r25, r13
    1678:	ae 05       	cpc	r26, r14
    167a:	bf 05       	cpc	r27, r15
    167c:	a8 f4       	brcc	.+42     	; 0x16a8 <vTaskDelayUntil+0x88>
    167e:	0b c0       	rjmp	.+22     	; 0x1696 <vTaskDelayUntil+0x76>
    1680:	c0 16       	cp	r12, r16
    1682:	d1 06       	cpc	r13, r17
    1684:	e2 06       	cpc	r14, r18
    1686:	f3 06       	cpc	r15, r19
    1688:	a0 f0       	brcs	.+40     	; 0x16b2 <vTaskDelayUntil+0x92>
    168a:	8c 15       	cp	r24, r12
    168c:	9d 05       	cpc	r25, r13
    168e:	ae 05       	cpc	r26, r14
    1690:	bf 05       	cpc	r27, r15
    1692:	78 f0       	brcs	.+30     	; 0x16b2 <vTaskDelayUntil+0x92>
    1694:	13 c0       	rjmp	.+38     	; 0x16bc <vTaskDelayUntil+0x9c>
    1696:	80 91 28 1a 	lds	r24, 0x1A28
    169a:	90 91 29 1a 	lds	r25, 0x1A29
    169e:	02 96       	adiw	r24, 0x02	; 2
    16a0:	7a d8       	rcall	.-3852   	; 0x796 <uxListRemove>
    16a2:	c7 01       	movw	r24, r14
    16a4:	b6 01       	movw	r22, r12
    16a6:	93 dc       	rcall	.-1754   	; 0xfce <prvAddCurrentTaskToDelayedList>
    16a8:	3f df       	rcall	.-386    	; 0x1528 <xTaskResumeAll>
    16aa:	81 11       	cpse	r24, r1
    16ac:	0c c0       	rjmp	.+24     	; 0x16c6 <vTaskDelayUntil+0xa6>
    16ae:	44 d9       	rcall	.-3448   	; 0x938 <vPortYield>
    16b0:	0a c0       	rjmp	.+20     	; 0x16c6 <vTaskDelayUntil+0xa6>
    16b2:	c8 82       	st	Y, r12
    16b4:	d9 82       	std	Y+1, r13	; 0x01
    16b6:	ea 82       	std	Y+2, r14	; 0x02
    16b8:	fb 82       	std	Y+3, r15	; 0x03
    16ba:	ed cf       	rjmp	.-38     	; 0x1696 <vTaskDelayUntil+0x76>
    16bc:	c8 82       	st	Y, r12
    16be:	d9 82       	std	Y+1, r13	; 0x01
    16c0:	ea 82       	std	Y+2, r14	; 0x02
    16c2:	fb 82       	std	Y+3, r15	; 0x03
    16c4:	f1 cf       	rjmp	.-30     	; 0x16a8 <vTaskDelayUntil+0x88>
    16c6:	df 91       	pop	r29
    16c8:	cf 91       	pop	r28
    16ca:	1f 91       	pop	r17
    16cc:	0f 91       	pop	r16
    16ce:	ff 90       	pop	r15
    16d0:	ef 90       	pop	r14
    16d2:	df 90       	pop	r13
    16d4:	cf 90       	pop	r12
    16d6:	08 95       	ret

000016d8 <vTaskDelay>:
    16d8:	cf 92       	push	r12
    16da:	df 92       	push	r13
    16dc:	ef 92       	push	r14
    16de:	ff 92       	push	r15
    16e0:	6b 01       	movw	r12, r22
    16e2:	7c 01       	movw	r14, r24
    16e4:	67 2b       	or	r22, r23
    16e6:	68 2b       	or	r22, r24
    16e8:	69 2b       	or	r22, r25
    16ea:	c9 f0       	breq	.+50     	; 0x171e <vTaskDelay+0x46>
    16ec:	fc dd       	rcall	.-1032   	; 0x12e6 <vTaskSuspendAll>
    16ee:	80 91 d0 19 	lds	r24, 0x19D0
    16f2:	90 91 d1 19 	lds	r25, 0x19D1
    16f6:	a0 91 d2 19 	lds	r26, 0x19D2
    16fa:	b0 91 d3 19 	lds	r27, 0x19D3
    16fe:	c8 0e       	add	r12, r24
    1700:	d9 1e       	adc	r13, r25
    1702:	ea 1e       	adc	r14, r26
    1704:	fb 1e       	adc	r15, r27
    1706:	80 91 28 1a 	lds	r24, 0x1A28
    170a:	90 91 29 1a 	lds	r25, 0x1A29
    170e:	02 96       	adiw	r24, 0x02	; 2
    1710:	42 d8       	rcall	.-3964   	; 0x796 <uxListRemove>
    1712:	c7 01       	movw	r24, r14
    1714:	b6 01       	movw	r22, r12
    1716:	5b dc       	rcall	.-1866   	; 0xfce <prvAddCurrentTaskToDelayedList>
    1718:	07 df       	rcall	.-498    	; 0x1528 <xTaskResumeAll>
    171a:	81 11       	cpse	r24, r1
    171c:	01 c0       	rjmp	.+2      	; 0x1720 <vTaskDelay+0x48>
    171e:	0c d9       	rcall	.-3560   	; 0x938 <vPortYield>
    1720:	ff 90       	pop	r15
    1722:	ef 90       	pop	r14
    1724:	df 90       	pop	r13
    1726:	cf 90       	pop	r12
    1728:	08 95       	ret

0000172a <vTaskSwitchContext>:
    172a:	80 91 c9 19 	lds	r24, 0x19C9
    172e:	88 23       	and	r24, r24
    1730:	21 f0       	breq	.+8      	; 0x173a <vTaskSwitchContext+0x10>
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	80 93 cc 19 	sts	0x19CC, r24
    1738:	08 95       	ret
    173a:	10 92 cc 19 	sts	0x19CC, r1
    173e:	e0 91 cf 19 	lds	r30, 0x19CF
    1742:	4b e0       	ldi	r20, 0x0B	; 11
    1744:	e4 9f       	mul	r30, r20
    1746:	f0 01       	movw	r30, r0
    1748:	11 24       	eor	r1, r1
    174a:	e4 50       	subi	r30, 0x04	; 4
    174c:	f6 4e       	sbci	r31, 0xE6	; 230
    174e:	80 81       	ld	r24, Z
    1750:	81 11       	cpse	r24, r1
    1752:	10 c0       	rjmp	.+32     	; 0x1774 <vTaskSwitchContext+0x4a>
    1754:	9b e0       	ldi	r25, 0x0B	; 11
    1756:	80 91 cf 19 	lds	r24, 0x19CF
    175a:	81 50       	subi	r24, 0x01	; 1
    175c:	80 93 cf 19 	sts	0x19CF, r24
    1760:	e0 91 cf 19 	lds	r30, 0x19CF
    1764:	9e 9f       	mul	r25, r30
    1766:	f0 01       	movw	r30, r0
    1768:	11 24       	eor	r1, r1
    176a:	e4 50       	subi	r30, 0x04	; 4
    176c:	f6 4e       	sbci	r31, 0xE6	; 230
    176e:	80 81       	ld	r24, Z
    1770:	88 23       	and	r24, r24
    1772:	89 f3       	breq	.-30     	; 0x1756 <vTaskSwitchContext+0x2c>
    1774:	80 91 cf 19 	lds	r24, 0x19CF
    1778:	28 2f       	mov	r18, r24
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	4b e0       	ldi	r20, 0x0B	; 11
    177e:	84 9f       	mul	r24, r20
    1780:	c0 01       	movw	r24, r0
    1782:	11 24       	eor	r1, r1
    1784:	dc 01       	movw	r26, r24
    1786:	a4 50       	subi	r26, 0x04	; 4
    1788:	b6 4e       	sbci	r27, 0xE6	; 230
    178a:	11 96       	adiw	r26, 0x01	; 1
    178c:	ed 91       	ld	r30, X+
    178e:	fc 91       	ld	r31, X
    1790:	12 97       	sbiw	r26, 0x02	; 2
    1792:	04 80       	ldd	r0, Z+4	; 0x04
    1794:	f5 81       	ldd	r31, Z+5	; 0x05
    1796:	e0 2d       	mov	r30, r0
    1798:	12 96       	adiw	r26, 0x02	; 2
    179a:	fc 93       	st	X, r31
    179c:	ee 93       	st	-X, r30
    179e:	11 97       	sbiw	r26, 0x01	; 1
    17a0:	81 50       	subi	r24, 0x01	; 1
    17a2:	96 4e       	sbci	r25, 0xE6	; 230
    17a4:	e8 17       	cp	r30, r24
    17a6:	f9 07       	cpc	r31, r25
    17a8:	61 f4       	brne	.+24     	; 0x17c2 <vTaskSwitchContext+0x98>
    17aa:	84 81       	ldd	r24, Z+4	; 0x04
    17ac:	95 81       	ldd	r25, Z+5	; 0x05
    17ae:	4b e0       	ldi	r20, 0x0B	; 11
    17b0:	42 9f       	mul	r20, r18
    17b2:	f0 01       	movw	r30, r0
    17b4:	43 9f       	mul	r20, r19
    17b6:	f0 0d       	add	r31, r0
    17b8:	11 24       	eor	r1, r1
    17ba:	e4 50       	subi	r30, 0x04	; 4
    17bc:	f6 4e       	sbci	r31, 0xE6	; 230
    17be:	92 83       	std	Z+2, r25	; 0x02
    17c0:	81 83       	std	Z+1, r24	; 0x01
    17c2:	8b e0       	ldi	r24, 0x0B	; 11
    17c4:	82 9f       	mul	r24, r18
    17c6:	f0 01       	movw	r30, r0
    17c8:	83 9f       	mul	r24, r19
    17ca:	f0 0d       	add	r31, r0
    17cc:	11 24       	eor	r1, r1
    17ce:	e4 50       	subi	r30, 0x04	; 4
    17d0:	f6 4e       	sbci	r31, 0xE6	; 230
    17d2:	01 80       	ldd	r0, Z+1	; 0x01
    17d4:	f2 81       	ldd	r31, Z+2	; 0x02
    17d6:	e0 2d       	mov	r30, r0
    17d8:	80 85       	ldd	r24, Z+8	; 0x08
    17da:	91 85       	ldd	r25, Z+9	; 0x09
    17dc:	90 93 29 1a 	sts	0x1A29, r25
    17e0:	80 93 28 1a 	sts	0x1A28, r24
    17e4:	08 95       	ret

000017e6 <vTaskPlaceOnEventList>:
    17e6:	cf 92       	push	r12
    17e8:	df 92       	push	r13
    17ea:	ef 92       	push	r14
    17ec:	ff 92       	push	r15
    17ee:	6a 01       	movw	r12, r20
    17f0:	7b 01       	movw	r14, r22
    17f2:	20 91 28 1a 	lds	r18, 0x1A28
    17f6:	30 91 29 1a 	lds	r19, 0x1A29
    17fa:	b9 01       	movw	r22, r18
    17fc:	62 5f       	subi	r22, 0xF2	; 242
    17fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1800:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsert>
    1804:	80 91 28 1a 	lds	r24, 0x1A28
    1808:	90 91 29 1a 	lds	r25, 0x1A29
    180c:	02 96       	adiw	r24, 0x02	; 2
    180e:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    1812:	80 91 d0 19 	lds	r24, 0x19D0
    1816:	90 91 d1 19 	lds	r25, 0x19D1
    181a:	a0 91 d2 19 	lds	r26, 0x19D2
    181e:	b0 91 d3 19 	lds	r27, 0x19D3
    1822:	bc 01       	movw	r22, r24
    1824:	cd 01       	movw	r24, r26
    1826:	6c 0d       	add	r22, r12
    1828:	7d 1d       	adc	r23, r13
    182a:	8e 1d       	adc	r24, r14
    182c:	9f 1d       	adc	r25, r15
    182e:	cf db       	rcall	.-2146   	; 0xfce <prvAddCurrentTaskToDelayedList>
    1830:	ff 90       	pop	r15
    1832:	ef 90       	pop	r14
    1834:	df 90       	pop	r13
    1836:	cf 90       	pop	r12
    1838:	08 95       	ret

0000183a <xTaskRemoveFromEventList>:
    183a:	0f 93       	push	r16
    183c:	1f 93       	push	r17
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	dc 01       	movw	r26, r24
    1844:	17 96       	adiw	r26, 0x07	; 7
    1846:	ed 91       	ld	r30, X+
    1848:	fc 91       	ld	r31, X
    184a:	18 97       	sbiw	r26, 0x08	; 8
    184c:	c0 85       	ldd	r28, Z+8	; 0x08
    184e:	d1 85       	ldd	r29, Z+9	; 0x09
    1850:	8e 01       	movw	r16, r28
    1852:	02 5f       	subi	r16, 0xF2	; 242
    1854:	1f 4f       	sbci	r17, 0xFF	; 255
    1856:	c8 01       	movw	r24, r16
    1858:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    185c:	80 91 c9 19 	lds	r24, 0x19C9
    1860:	81 11       	cpse	r24, r1
    1862:	16 c0       	rjmp	.+44     	; 0x1890 <xTaskRemoveFromEventList+0x56>
    1864:	0c 50       	subi	r16, 0x0C	; 12
    1866:	11 09       	sbc	r17, r1
    1868:	c8 01       	movw	r24, r16
    186a:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    186e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1870:	80 91 cf 19 	lds	r24, 0x19CF
    1874:	89 17       	cp	r24, r25
    1876:	10 f4       	brcc	.+4      	; 0x187c <xTaskRemoveFromEventList+0x42>
    1878:	90 93 cf 19 	sts	0x19CF, r25
    187c:	bb e0       	ldi	r27, 0x0B	; 11
    187e:	9b 9f       	mul	r25, r27
    1880:	c0 01       	movw	r24, r0
    1882:	11 24       	eor	r1, r1
    1884:	b8 01       	movw	r22, r16
    1886:	84 50       	subi	r24, 0x04	; 4
    1888:	96 4e       	sbci	r25, 0xE6	; 230
    188a:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsertEnd>
    188e:	05 c0       	rjmp	.+10     	; 0x189a <xTaskRemoveFromEventList+0x60>
    1890:	b8 01       	movw	r22, r16
    1892:	87 ed       	ldi	r24, 0xD7	; 215
    1894:	99 e1       	ldi	r25, 0x19	; 25
    1896:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsertEnd>
    189a:	e0 91 28 1a 	lds	r30, 0x1A28
    189e:	f0 91 29 1a 	lds	r31, 0x1A29
    18a2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    18a6:	89 17       	cp	r24, r25
    18a8:	20 f4       	brcc	.+8      	; 0x18b2 <xTaskRemoveFromEventList+0x78>
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	80 93 cc 19 	sts	0x19CC, r24
    18b0:	01 c0       	rjmp	.+2      	; 0x18b4 <xTaskRemoveFromEventList+0x7a>
    18b2:	80 e0       	ldi	r24, 0x00	; 0
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	08 95       	ret

000018be <vTaskSetTimeOutState>:
    18be:	20 91 cb 19 	lds	r18, 0x19CB
    18c2:	fc 01       	movw	r30, r24
    18c4:	20 83       	st	Z, r18
    18c6:	40 91 d0 19 	lds	r20, 0x19D0
    18ca:	50 91 d1 19 	lds	r21, 0x19D1
    18ce:	60 91 d2 19 	lds	r22, 0x19D2
    18d2:	70 91 d3 19 	lds	r23, 0x19D3
    18d6:	41 83       	std	Z+1, r20	; 0x01
    18d8:	52 83       	std	Z+2, r21	; 0x02
    18da:	63 83       	std	Z+3, r22	; 0x03
    18dc:	74 83       	std	Z+4, r23	; 0x04
    18de:	08 95       	ret

000018e0 <xTaskCheckForTimeOut>:
    18e0:	8f 92       	push	r8
    18e2:	9f 92       	push	r9
    18e4:	af 92       	push	r10
    18e6:	bf 92       	push	r11
    18e8:	cf 92       	push	r12
    18ea:	df 92       	push	r13
    18ec:	ef 92       	push	r14
    18ee:	ff 92       	push	r15
    18f0:	0f 93       	push	r16
    18f2:	1f 93       	push	r17
    18f4:	fc 01       	movw	r30, r24
    18f6:	db 01       	movw	r26, r22
    18f8:	0f b6       	in	r0, 0x3f	; 63
    18fa:	f8 94       	cli
    18fc:	0f 92       	push	r0
    18fe:	40 91 d0 19 	lds	r20, 0x19D0
    1902:	50 91 d1 19 	lds	r21, 0x19D1
    1906:	60 91 d2 19 	lds	r22, 0x19D2
    190a:	70 91 d3 19 	lds	r23, 0x19D3
    190e:	80 91 cb 19 	lds	r24, 0x19CB
    1912:	90 81       	ld	r25, Z
    1914:	98 17       	cp	r25, r24
    1916:	49 f0       	breq	.+18     	; 0x192a <xTaskCheckForTimeOut+0x4a>
    1918:	01 81       	ldd	r16, Z+1	; 0x01
    191a:	12 81       	ldd	r17, Z+2	; 0x02
    191c:	23 81       	ldd	r18, Z+3	; 0x03
    191e:	34 81       	ldd	r19, Z+4	; 0x04
    1920:	40 17       	cp	r20, r16
    1922:	51 07       	cpc	r21, r17
    1924:	62 07       	cpc	r22, r18
    1926:	73 07       	cpc	r23, r19
    1928:	28 f5       	brcc	.+74     	; 0x1974 <xTaskCheckForTimeOut+0x94>
    192a:	c1 80       	ldd	r12, Z+1	; 0x01
    192c:	d2 80       	ldd	r13, Z+2	; 0x02
    192e:	e3 80       	ldd	r14, Z+3	; 0x03
    1930:	f4 80       	ldd	r15, Z+4	; 0x04
    1932:	0d 91       	ld	r16, X+
    1934:	1d 91       	ld	r17, X+
    1936:	2d 91       	ld	r18, X+
    1938:	3c 91       	ld	r19, X
    193a:	13 97       	sbiw	r26, 0x03	; 3
    193c:	4a 01       	movw	r8, r20
    193e:	5b 01       	movw	r10, r22
    1940:	8c 18       	sub	r8, r12
    1942:	9d 08       	sbc	r9, r13
    1944:	ae 08       	sbc	r10, r14
    1946:	bf 08       	sbc	r11, r15
    1948:	80 16       	cp	r8, r16
    194a:	91 06       	cpc	r9, r17
    194c:	a2 06       	cpc	r10, r18
    194e:	b3 06       	cpc	r11, r19
    1950:	98 f4       	brcc	.+38     	; 0x1978 <xTaskCheckForTimeOut+0x98>
    1952:	cf 01       	movw	r24, r30
    1954:	c4 1a       	sub	r12, r20
    1956:	d5 0a       	sbc	r13, r21
    1958:	e6 0a       	sbc	r14, r22
    195a:	f7 0a       	sbc	r15, r23
    195c:	0c 0d       	add	r16, r12
    195e:	1d 1d       	adc	r17, r13
    1960:	2e 1d       	adc	r18, r14
    1962:	3f 1d       	adc	r19, r15
    1964:	0d 93       	st	X+, r16
    1966:	1d 93       	st	X+, r17
    1968:	2d 93       	st	X+, r18
    196a:	3c 93       	st	X, r19
    196c:	13 97       	sbiw	r26, 0x03	; 3
    196e:	a7 df       	rcall	.-178    	; 0x18be <vTaskSetTimeOutState>
    1970:	80 e0       	ldi	r24, 0x00	; 0
    1972:	03 c0       	rjmp	.+6      	; 0x197a <xTaskCheckForTimeOut+0x9a>
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	01 c0       	rjmp	.+2      	; 0x197a <xTaskCheckForTimeOut+0x9a>
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	ff 90       	pop	r15
    1984:	ef 90       	pop	r14
    1986:	df 90       	pop	r13
    1988:	cf 90       	pop	r12
    198a:	bf 90       	pop	r11
    198c:	af 90       	pop	r10
    198e:	9f 90       	pop	r9
    1990:	8f 90       	pop	r8
    1992:	08 95       	ret

00001994 <vTaskMissedYield>:
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	80 93 cc 19 	sts	0x19CC, r24
    199a:	08 95       	ret

0000199c <uxTaskGetStackHighWaterMark>:
    199c:	00 97       	sbiw	r24, 0x00	; 0
    199e:	21 f4       	brne	.+8      	; 0x19a8 <uxTaskGetStackHighWaterMark+0xc>
    19a0:	80 91 28 1a 	lds	r24, 0x1A28
    19a4:	90 91 29 1a 	lds	r25, 0x1A29
    19a8:	dc 01       	movw	r26, r24
    19aa:	5b 96       	adiw	r26, 0x1b	; 27
    19ac:	ed 91       	ld	r30, X+
    19ae:	fc 91       	ld	r31, X
    19b0:	5c 97       	sbiw	r26, 0x1c	; 28
    19b2:	80 81       	ld	r24, Z
    19b4:	85 3a       	cpi	r24, 0xA5	; 165
    19b6:	59 f4       	brne	.+22     	; 0x19ce <uxTaskGetStackHighWaterMark+0x32>
    19b8:	31 96       	adiw	r30, 0x01	; 1
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	dc 01       	movw	r26, r24
    19c0:	01 96       	adiw	r24, 0x01	; 1
    19c2:	a1 1d       	adc	r26, r1
    19c4:	b1 1d       	adc	r27, r1
    19c6:	21 91       	ld	r18, Z+
    19c8:	25 3a       	cpi	r18, 0xA5	; 165
    19ca:	d1 f3       	breq	.-12     	; 0x19c0 <uxTaskGetStackHighWaterMark+0x24>
    19cc:	08 95       	ret
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	dc 01       	movw	r26, r24
    19d4:	08 95       	ret

000019d6 <vTaskPriorityInherit>:
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	fc 01       	movw	r30, r24
    19e0:	89 2b       	or	r24, r25
    19e2:	09 f4       	brne	.+2      	; 0x19e6 <vTaskPriorityInherit+0x10>
    19e4:	51 c0       	rjmp	.+162    	; 0x1a88 <vTaskPriorityInherit+0xb2>
    19e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e8:	a0 91 28 1a 	lds	r26, 0x1A28
    19ec:	b0 91 29 1a 	lds	r27, 0x1A29
    19f0:	5a 96       	adiw	r26, 0x1a	; 26
    19f2:	9c 91       	ld	r25, X
    19f4:	89 17       	cp	r24, r25
    19f6:	08 f0       	brcs	.+2      	; 0x19fa <vTaskPriorityInherit+0x24>
    19f8:	47 c0       	rjmp	.+142    	; 0x1a88 <vTaskPriorityInherit+0xb2>
    19fa:	46 85       	ldd	r20, Z+14	; 0x0e
    19fc:	57 85       	ldd	r21, Z+15	; 0x0f
    19fe:	60 89       	ldd	r22, Z+16	; 0x10
    1a00:	71 89       	ldd	r23, Z+17	; 0x11
    1a02:	77 23       	and	r23, r23
    1a04:	94 f0       	brlt	.+36     	; 0x1a2a <vTaskPriorityInherit+0x54>
    1a06:	a0 91 28 1a 	lds	r26, 0x1A28
    1a0a:	b0 91 29 1a 	lds	r27, 0x1A29
    1a0e:	5a 96       	adiw	r26, 0x1a	; 26
    1a10:	9c 91       	ld	r25, X
    1a12:	44 e0       	ldi	r20, 0x04	; 4
    1a14:	50 e0       	ldi	r21, 0x00	; 0
    1a16:	60 e0       	ldi	r22, 0x00	; 0
    1a18:	70 e0       	ldi	r23, 0x00	; 0
    1a1a:	49 1b       	sub	r20, r25
    1a1c:	51 09       	sbc	r21, r1
    1a1e:	61 09       	sbc	r22, r1
    1a20:	71 09       	sbc	r23, r1
    1a22:	46 87       	std	Z+14, r20	; 0x0e
    1a24:	57 87       	std	Z+15, r21	; 0x0f
    1a26:	60 8b       	std	Z+16, r22	; 0x10
    1a28:	71 8b       	std	Z+17, r23	; 0x11
    1a2a:	2b e0       	ldi	r18, 0x0B	; 11
    1a2c:	82 9f       	mul	r24, r18
    1a2e:	c0 01       	movw	r24, r0
    1a30:	11 24       	eor	r1, r1
    1a32:	84 50       	subi	r24, 0x04	; 4
    1a34:	96 4e       	sbci	r25, 0xE6	; 230
    1a36:	24 85       	ldd	r18, Z+12	; 0x0c
    1a38:	35 85       	ldd	r19, Z+13	; 0x0d
    1a3a:	28 17       	cp	r18, r24
    1a3c:	39 07       	cpc	r19, r25
    1a3e:	e9 f4       	brne	.+58     	; 0x1a7a <vTaskPriorityInherit+0xa4>
    1a40:	8f 01       	movw	r16, r30
    1a42:	ef 01       	movw	r28, r30
    1a44:	22 96       	adiw	r28, 0x02	; 2
    1a46:	ce 01       	movw	r24, r28
    1a48:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    1a4c:	e0 91 28 1a 	lds	r30, 0x1A28
    1a50:	f0 91 29 1a 	lds	r31, 0x1A29
    1a54:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a56:	f8 01       	movw	r30, r16
    1a58:	92 8f       	std	Z+26, r25	; 0x1a
    1a5a:	80 91 cf 19 	lds	r24, 0x19CF
    1a5e:	89 17       	cp	r24, r25
    1a60:	10 f4       	brcc	.+4      	; 0x1a66 <vTaskPriorityInherit+0x90>
    1a62:	90 93 cf 19 	sts	0x19CF, r25
    1a66:	fb e0       	ldi	r31, 0x0B	; 11
    1a68:	9f 9f       	mul	r25, r31
    1a6a:	c0 01       	movw	r24, r0
    1a6c:	11 24       	eor	r1, r1
    1a6e:	be 01       	movw	r22, r28
    1a70:	84 50       	subi	r24, 0x04	; 4
    1a72:	96 4e       	sbci	r25, 0xE6	; 230
    1a74:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsertEnd>
    1a78:	07 c0       	rjmp	.+14     	; 0x1a88 <vTaskPriorityInherit+0xb2>
    1a7a:	a0 91 28 1a 	lds	r26, 0x1A28
    1a7e:	b0 91 29 1a 	lds	r27, 0x1A29
    1a82:	5a 96       	adiw	r26, 0x1a	; 26
    1a84:	8c 91       	ld	r24, X
    1a86:	82 8f       	std	Z+26, r24	; 0x1a
    1a88:	df 91       	pop	r29
    1a8a:	cf 91       	pop	r28
    1a8c:	1f 91       	pop	r17
    1a8e:	0f 91       	pop	r16
    1a90:	08 95       	ret

00001a92 <xTaskPriorityDisinherit>:
    1a92:	0f 93       	push	r16
    1a94:	1f 93       	push	r17
    1a96:	cf 93       	push	r28
    1a98:	df 93       	push	r29
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	89 2b       	or	r24, r25
    1a9e:	79 f1       	breq	.+94     	; 0x1afe <xTaskPriorityDisinherit+0x6c>
    1aa0:	80 a5       	ldd	r24, Z+40	; 0x28
    1aa2:	81 50       	subi	r24, 0x01	; 1
    1aa4:	80 a7       	std	Z+40, r24	; 0x28
    1aa6:	22 8d       	ldd	r18, Z+26	; 0x1a
    1aa8:	97 a1       	ldd	r25, Z+39	; 0x27
    1aaa:	29 17       	cp	r18, r25
    1aac:	51 f1       	breq	.+84     	; 0x1b02 <xTaskPriorityDisinherit+0x70>
    1aae:	81 11       	cpse	r24, r1
    1ab0:	2a c0       	rjmp	.+84     	; 0x1b06 <xTaskPriorityDisinherit+0x74>
    1ab2:	ef 01       	movw	r28, r30
    1ab4:	8f 01       	movw	r16, r30
    1ab6:	0e 5f       	subi	r16, 0xFE	; 254
    1ab8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aba:	c8 01       	movw	r24, r16
    1abc:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    1ac0:	9f a1       	ldd	r25, Y+39	; 0x27
    1ac2:	9a 8f       	std	Y+26, r25	; 0x1a
    1ac4:	44 e0       	ldi	r20, 0x04	; 4
    1ac6:	50 e0       	ldi	r21, 0x00	; 0
    1ac8:	60 e0       	ldi	r22, 0x00	; 0
    1aca:	70 e0       	ldi	r23, 0x00	; 0
    1acc:	49 1b       	sub	r20, r25
    1ace:	51 09       	sbc	r21, r1
    1ad0:	61 09       	sbc	r22, r1
    1ad2:	71 09       	sbc	r23, r1
    1ad4:	4e 87       	std	Y+14, r20	; 0x0e
    1ad6:	5f 87       	std	Y+15, r21	; 0x0f
    1ad8:	68 8b       	std	Y+16, r22	; 0x10
    1ada:	79 8b       	std	Y+17, r23	; 0x11
    1adc:	80 91 cf 19 	lds	r24, 0x19CF
    1ae0:	89 17       	cp	r24, r25
    1ae2:	10 f4       	brcc	.+4      	; 0x1ae8 <xTaskPriorityDisinherit+0x56>
    1ae4:	90 93 cf 19 	sts	0x19CF, r25
    1ae8:	2b e0       	ldi	r18, 0x0B	; 11
    1aea:	92 9f       	mul	r25, r18
    1aec:	c0 01       	movw	r24, r0
    1aee:	11 24       	eor	r1, r1
    1af0:	b8 01       	movw	r22, r16
    1af2:	84 50       	subi	r24, 0x04	; 4
    1af4:	96 4e       	sbci	r25, 0xE6	; 230
    1af6:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsertEnd>
    1afa:	81 e0       	ldi	r24, 0x01	; 1
    1afc:	05 c0       	rjmp	.+10     	; 0x1b08 <xTaskPriorityDisinherit+0x76>
    1afe:	80 e0       	ldi	r24, 0x00	; 0
    1b00:	03 c0       	rjmp	.+6      	; 0x1b08 <xTaskPriorityDisinherit+0x76>
    1b02:	80 e0       	ldi	r24, 0x00	; 0
    1b04:	01 c0       	rjmp	.+2      	; 0x1b08 <xTaskPriorityDisinherit+0x76>
    1b06:	80 e0       	ldi	r24, 0x00	; 0
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	1f 91       	pop	r17
    1b0e:	0f 91       	pop	r16
    1b10:	08 95       	ret

00001b12 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1b12:	80 91 28 1a 	lds	r24, 0x1A28
    1b16:	90 91 29 1a 	lds	r25, 0x1A29
    1b1a:	89 2b       	or	r24, r25
    1b1c:	39 f0       	breq	.+14     	; 0x1b2c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1b1e:	e0 91 28 1a 	lds	r30, 0x1A28
    1b22:	f0 91 29 1a 	lds	r31, 0x1A29
    1b26:	80 a5       	ldd	r24, Z+40	; 0x28
    1b28:	8f 5f       	subi	r24, 0xFF	; 255
    1b2a:	80 a7       	std	Z+40, r24	; 0x28
		}

		return pxCurrentTCB;
    1b2c:	80 91 28 1a 	lds	r24, 0x1A28
    1b30:	90 91 29 1a 	lds	r25, 0x1A29
	}
    1b34:	08 95       	ret

00001b36 <_ZN9BaseShareC1EPKc>:
 *           base class object which can't do anything!) but instead by the 
 *           constructors of descendent classes. 
 *  @param   p_name The name for the shared data item, in a character string
 */

BaseShare::BaseShare (const char* p_name = NULL)
    1b36:	ef 92       	push	r14
    1b38:	ff 92       	push	r15
    1b3a:	0f 93       	push	r16
    1b3c:	1f 93       	push	r17
    1b3e:	cf 93       	push	r28
    1b40:	df 93       	push	r29
    1b42:	8c 01       	movw	r16, r24
    1b44:	7b 01       	movw	r14, r22
    1b46:	81 e1       	ldi	r24, 0x11	; 17
    1b48:	92 e0       	ldi	r25, 0x02	; 2
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	91 83       	std	Z+1, r25	; 0x01
    1b4e:	80 83       	st	Z, r24
{
	// Allocate some memory and then save the share's name; trim it to 12 characters
	if (p_name != NULL)
    1b50:	61 15       	cp	r22, r1
    1b52:	71 05       	cpc	r23, r1
    1b54:	a9 f0       	breq	.+42     	; 0x1b80 <_ZN9BaseShareC1EPKc+0x4a>
	{
		uint8_t namelength = strlen (p_name);
    1b56:	fb 01       	movw	r30, r22
    1b58:	01 90       	ld	r0, Z+
    1b5a:	00 20       	and	r0, r0
    1b5c:	e9 f7       	brne	.-6      	; 0x1b58 <_ZN9BaseShareC1EPKc+0x22>
    1b5e:	31 97       	sbiw	r30, 0x01	; 1
		namelength = (namelength <= 12) ? namelength : 12;
    1b60:	e6 1b       	sub	r30, r22
    1b62:	ed 30       	cpi	r30, 0x0D	; 13
    1b64:	08 f0       	brcs	.+2      	; 0x1b68 <_ZN9BaseShareC1EPKc+0x32>
    1b66:	ec e0       	ldi	r30, 0x0C	; 12
		name = new char[namelength + 1];
    1b68:	ce 2f       	mov	r28, r30
    1b6a:	d0 e0       	ldi	r29, 0x00	; 0
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	01 96       	adiw	r24, 0x01	; 1
    1b70:	80 d4       	rcall	.+2304   	; 0x2472 <_Znaj>
    1b72:	f8 01       	movw	r30, r16
    1b74:	95 83       	std	Z+5, r25	; 0x05
    1b76:	84 83       	std	Z+4, r24	; 0x04
		strncpy (name, p_name, namelength);
    1b78:	ae 01       	movw	r20, r28
    1b7a:	b7 01       	movw	r22, r14
    1b7c:	0e 94 b7 19 	call	0x336e	; 0x336e <strncpy>
	}

	// Install this share in the linked list of shares
	p_next = p_newest;
    1b80:	80 91 2a 1a 	lds	r24, 0x1A2A
    1b84:	90 91 2b 1a 	lds	r25, 0x1A2B
    1b88:	f8 01       	movw	r30, r16
    1b8a:	97 83       	std	Z+7, r25	; 0x07
    1b8c:	86 83       	std	Z+6, r24	; 0x06
	p_newest = this;
    1b8e:	10 93 2b 1a 	sts	0x1A2B, r17
    1b92:	00 93 2a 1a 	sts	0x1A2A, r16
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	ff 90       	pop	r15
    1ba0:	ef 90       	pop	r14
    1ba2:	08 95       	ret

00001ba4 <_Z16print_all_sharesP8emstream>:
 *           status of other shares in reverse order of creation. 
 *  @param   p_ser_dev A pointer to the serial device on which shares are printed
 */

void print_all_shares (emstream* p_ser_dev)
{
    1ba4:	0f 93       	push	r16
    1ba6:	1f 93       	push	r17
    1ba8:	cf 93       	push	r28
    1baa:	df 93       	push	r29
    1bac:	ec 01       	movw	r28, r24
	if (BaseShare::p_newest != NULL)
    1bae:	80 91 2a 1a 	lds	r24, 0x1A2A
    1bb2:	90 91 2b 1a 	lds	r25, 0x1A2B
    1bb6:	89 2b       	or	r24, r25
    1bb8:	09 f1       	breq	.+66     	; 0x1bfc <_Z16print_all_sharesP8emstream+0x58>
	{
		*p_ser_dev << PMS ("Share/Queue     Type    Free/Total") << endl;
    1bba:	6b e0       	ldi	r22, 0x0B	; 11
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	32 d5       	rcall	.+2660   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1bc0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1bc2:	65 e2       	ldi	r22, 0x25	; 37
    1bc4:	71 e0       	ldi	r23, 0x01	; 1
    1bc6:	f7 d4       	rcall	.+2542   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1bc8:	66 e0       	ldi	r22, 0x06	; 6
    1bca:	c8 01       	movw	r24, r16
    1bcc:	2b d5       	rcall	.+2646   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
		*p_ser_dev << PMS ("----            ----    ----------") << endl;
    1bce:	6b e0       	ldi	r22, 0x0B	; 11
    1bd0:	ce 01       	movw	r24, r28
    1bd2:	28 d5       	rcall	.+2640   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1bd4:	8c 01       	movw	r16, r24
    1bd6:	62 e0       	ldi	r22, 0x02	; 2
    1bd8:	71 e0       	ldi	r23, 0x01	; 1
    1bda:	ed d4       	rcall	.+2522   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1bdc:	66 e0       	ldi	r22, 0x06	; 6
    1bde:	c8 01       	movw	r24, r16
    1be0:	21 d5       	rcall	.+2626   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

		BaseShare::p_newest->print_in_list (p_ser_dev);
    1be2:	80 91 2a 1a 	lds	r24, 0x1A2A
    1be6:	90 91 2b 1a 	lds	r25, 0x1A2B
    1bea:	dc 01       	movw	r26, r24
    1bec:	ed 91       	ld	r30, X+
    1bee:	fc 91       	ld	r31, X
    1bf0:	01 90       	ld	r0, Z+
    1bf2:	f0 81       	ld	r31, Z
    1bf4:	e0 2d       	mov	r30, r0
    1bf6:	be 01       	movw	r22, r28
    1bf8:	09 95       	icall
    1bfa:	0a c0       	rjmp	.+20     	; 0x1c10 <_Z16print_all_sharesP8emstream+0x6c>
	}
	else
	{
		*p_ser_dev << PMS ("No shared data items to print") << endl;
    1bfc:	6b e0       	ldi	r22, 0x0B	; 11
    1bfe:	ce 01       	movw	r24, r28
    1c00:	11 d5       	rcall	.+2594   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1c02:	ec 01       	movw	r28, r24
    1c04:	64 ee       	ldi	r22, 0xE4	; 228
    1c06:	70 e0       	ldi	r23, 0x00	; 0
    1c08:	d6 d4       	rcall	.+2476   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1c0a:	66 e0       	ldi	r22, 0x06	; 6
    1c0c:	ce 01       	movw	r24, r28
    1c0e:	0a d5       	rcall	.+2580   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	}
}
    1c10:	df 91       	pop	r29
    1c12:	cf 91       	pop	r28
    1c14:	1f 91       	pop	r17
    1c16:	0f 91       	pop	r16
    1c18:	08 95       	ret

00001c1a <_ZN8TaskBaseC1EPKchjP8emstream>:
 *                        (default: @c configMINIMAL_STACK_SIZE)
 *  @param   p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which 
 *                     can be used by this task to communicate (default: NULL)
 */

TaskBase::TaskBase (const char* a_name, unsigned portBASE_TYPE a_priority, 
    1c1a:	4f 92       	push	r4
    1c1c:	5f 92       	push	r5
    1c1e:	6f 92       	push	r6
    1c20:	7f 92       	push	r7
    1c22:	8f 92       	push	r8
    1c24:	9f 92       	push	r9
    1c26:	af 92       	push	r10
    1c28:	bf 92       	push	r11
    1c2a:	cf 92       	push	r12
    1c2c:	df 92       	push	r13
    1c2e:	ef 92       	push	r14
    1c30:	ff 92       	push	r15
    1c32:	0f 93       	push	r16
    1c34:	1f 93       	push	r17
    1c36:	cf 93       	push	r28
    1c38:	df 93       	push	r29
    1c3a:	ec 01       	movw	r28, r24
    1c3c:	3b 01       	movw	r6, r22
    1c3e:	29 01       	movw	r4, r18
    1c40:	48 01       	movw	r8, r16
					size_t a_stack_size, emstream* p_ser_dev)
    1c42:	fc 01       	movw	r30, r24
    1c44:	87 e1       	ldi	r24, 0x17	; 23
    1c46:	92 e0       	ldi	r25, 0x02	; 2
    1c48:	81 93       	st	Z+, r24
    1c4a:	91 93       	st	Z+, r25
{
	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    1c4c:	a1 2c       	mov	r10, r1
    1c4e:	b1 2c       	mov	r11, r1
    1c50:	c1 2c       	mov	r12, r1
    1c52:	d1 2c       	mov	r13, r1
    1c54:	7f 01       	movw	r14, r30
    1c56:	04 2f       	mov	r16, r20
    1c58:	9e 01       	movw	r18, r28
    1c5a:	a2 01       	movw	r20, r4
    1c5c:	87 ea       	ldi	r24, 0xA7	; 167
    1c5e:	9e e0       	ldi	r25, 0x0E	; 14
    1c60:	02 da       	rcall	.-3068   	; 0x1066 <xTaskGenericCreate>
		 a_priority,                                // Priority for the new task
		 &handle                                    // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    1c62:	9f 82       	std	Y+7, r9	; 0x07
    1c64:	8e 82       	std	Y+6, r8	; 0x06
	total_stack = a_stack_size;
    1c66:	59 86       	std	Y+9, r5	; 0x09
    1c68:	48 86       	std	Y+8, r4	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    1c6a:	20 91 2c 1a 	lds	r18, 0x1A2C
    1c6e:	30 91 2d 1a 	lds	r19, 0x1A2D
    1c72:	3d 83       	std	Y+5, r19	; 0x05
    1c74:	2c 83       	std	Y+4, r18	; 0x04
	last_created_task_pointer = this;
    1c76:	d0 93 2d 1a 	sts	0x1A2D, r29
    1c7a:	c0 93 2c 1a 	sts	0x1A2C, r28

	// Initialize the finite state machine and its transition logger
	state = 0;
    1c7e:	1c 86       	std	Y+12, r1	; 0x0c
	previous_state = 0;
    1c80:	1d 86       	std	Y+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    1c82:	40 90 3c 1a 	lds	r4, 0x1A3C
    1c86:	50 90 3d 1a 	lds	r5, 0x1A3D
    1c8a:	9f ef       	ldi	r25, 0xFF	; 255
    1c8c:	49 1a       	sub	r4, r25
    1c8e:	59 0a       	sbc	r5, r25
    1c90:	50 92 3d 1a 	sts	0x1A3D, r5
    1c94:	40 92 3c 1a 	sts	0x1A3C, r4
    1c98:	5b 86       	std	Y+11, r5	; 0x0b
    1c9a:	4a 86       	std	Y+10, r4	; 0x0a

	// Initialize the run counter
	runs = 0;
    1c9c:	1e 86       	std	Y+14, r1	; 0x0e
    1c9e:	1f 86       	std	Y+15, r1	; 0x0f
    1ca0:	18 8a       	std	Y+16, r1	; 0x10
    1ca2:	19 8a       	std	Y+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    1ca4:	81 14       	cp	r8, r1
    1ca6:	91 04       	cpc	r9, r1
    1ca8:	09 f4       	brne	.+2      	; 0x1cac <_ZN8TaskBaseC1EPKchjP8emstream+0x92>
    1caa:	32 c0       	rjmp	.+100    	; 0x1d10 <_ZN8TaskBaseC1EPKchjP8emstream+0xf6>
	{
		if (task_status == pdPASS)
    1cac:	81 30       	cpi	r24, 0x01	; 1
    1cae:	d9 f4       	brne	.+54     	; 0x1ce6 <_ZN8TaskBaseC1EPKchjP8emstream+0xcc>
		{
			*p_serial << PMS ("Task \"") << a_name << PMS ("\" created, stack at 0x")
    1cb0:	6b e0       	ldi	r22, 0x0B	; 11
    1cb2:	c4 01       	movw	r24, r8
    1cb4:	b7 d4       	rcall	.+2414   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1cb6:	ec 01       	movw	r28, r24
    1cb8:	6e e5       	ldi	r22, 0x5E	; 94
    1cba:	71 e0       	ldi	r23, 0x01	; 1
    1cbc:	7c d4       	rcall	.+2296   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1cbe:	b3 01       	movw	r22, r6
    1cc0:	ce 01       	movw	r24, r28
    1cc2:	79 d4       	rcall	.+2290   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1cc4:	6b e0       	ldi	r22, 0x0B	; 11
    1cc6:	ce 01       	movw	r24, r28
    1cc8:	ad d4       	rcall	.+2394   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1cca:	ec 01       	movw	r28, r24
    1ccc:	65 e6       	ldi	r22, 0x65	; 101
    1cce:	71 e0       	ldi	r23, 0x01	; 1
    1cd0:	72 d4       	rcall	.+2276   	; 0x25b6 <_ZN8emstream4putsEPKc>
				<< hex << (portPOINTER_SIZE_TYPE)top_of_stack << dec << endl;
    1cd2:	63 e0       	ldi	r22, 0x03	; 3
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	a6 d4       	rcall	.+2380   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1cd8:	b2 01       	movw	r22, r4
    1cda:	e8 d4       	rcall	.+2512   	; 0x26ac <_ZN8emstreamlsEj>
    1cdc:	62 e0       	ldi	r22, 0x02	; 2
    1cde:	a2 d4       	rcall	.+2372   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1ce0:	66 e0       	ldi	r22, 0x06	; 6
    1ce2:	a0 d4       	rcall	.+2368   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1ce4:	15 c0       	rjmp	.+42     	; 0x1d10 <_ZN8TaskBaseC1EPKchjP8emstream+0xf6>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task \"") << a_name << '"' << endl;
    1ce6:	6b e0       	ldi	r22, 0x0B	; 11
    1ce8:	c4 01       	movw	r24, r8
    1cea:	9c d4       	rcall	.+2360   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1cec:	ec 01       	movw	r28, r24
    1cee:	68 e4       	ldi	r22, 0x48	; 72
    1cf0:	71 e0       	ldi	r23, 0x01	; 1
    1cf2:	61 d4       	rcall	.+2242   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1cf4:	b3 01       	movw	r22, r6
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	5e d4       	rcall	.+2236   	; 0x25b6 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    1cfa:	e8 81       	ld	r30, Y
    1cfc:	f9 81       	ldd	r31, Y+1	; 0x01
    1cfe:	02 80       	ldd	r0, Z+2	; 0x02
    1d00:	f3 81       	ldd	r31, Z+3	; 0x03
    1d02:	e0 2d       	mov	r30, r0
    1d04:	62 e2       	ldi	r22, 0x22	; 34
    1d06:	ce 01       	movw	r24, r28
    1d08:	09 95       	icall
    1d0a:	66 e0       	ldi	r22, 0x06	; 6
    1d0c:	ce 01       	movw	r24, r28
    1d0e:	8a d4       	rcall	.+2324   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    1d10:	df 91       	pop	r29
    1d12:	cf 91       	pop	r28
    1d14:	1f 91       	pop	r17
    1d16:	0f 91       	pop	r16
    1d18:	ff 90       	pop	r15
    1d1a:	ef 90       	pop	r14
    1d1c:	df 90       	pop	r13
    1d1e:	cf 90       	pop	r12
    1d20:	bf 90       	pop	r11
    1d22:	af 90       	pop	r10
    1d24:	9f 90       	pop	r9
    1d26:	8f 90       	pop	r8
    1d28:	7f 90       	pop	r7
    1d2a:	6f 90       	pop	r6
    1d2c:	5f 90       	pop	r5
    1d2e:	4f 90       	pop	r4
    1d30:	08 95       	ret

00001d32 <_ZN8TaskBase22_call_users_run_methodEPS_>:
 *           it is the C (not C++) function which was registered with the scheduler.
 *  @param   p_task A pointer to the task (this task) whose run method is to be called
 */

void TaskBase::_call_users_run_method (TaskBase* p_task)
{
    1d32:	ec 01       	movw	r28, r24
	// This is where the user's run() method is actually called
	p_task->run ();
    1d34:	e8 81       	ld	r30, Y
    1d36:	f9 81       	ldd	r31, Y+1	; 0x01
    1d38:	01 90       	ld	r0, Z+
    1d3a:	f0 81       	ld	r31, Z
    1d3c:	e0 2d       	mov	r30, r0
    1d3e:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    1d40:	1b 82       	std	Y+3, r1	; 0x03
    1d42:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    1d44:	6f ef       	ldi	r22, 0xFF	; 255
    1d46:	7f ef       	ldi	r23, 0xFF	; 255
    1d48:	cb 01       	movw	r24, r22
    1d4a:	c6 dc       	rcall	.-1652   	; 0x16d8 <vTaskDelay>
 *           @c _call_static_run_method() function was, in turn, called by FreeRTOS; 
 *           it is the C (not C++) function which was registered with the scheduler.
 *  @param   p_task A pointer to the task (this task) whose run method is to be called
 */

void TaskBase::_call_users_run_method (TaskBase* p_task)
    1d4c:	fb cf       	rjmp	.-10     	; 0x1d44 <_ZN8TaskBase22_call_users_run_methodEPS_+0x12>

00001d4e <_call_static_run_method>:
 *                  function; the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (TaskBase* p_task)
{
	TaskBase::_call_users_run_method (p_task);
    1d4e:	f1 df       	rcall	.-30     	; 0x1d32 <_ZN8TaskBase22_call_users_run_methodEPS_>

00001d50 <_ZN8TaskBase13transition_toEh>:
 *  @param   new_state The state to which this task will transition
 */

void TaskBase::transition_to (uint8_t new_state)
{
	state = new_state;
    1d50:	fc 01       	movw	r30, r24
    1d52:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    1d54:	65 87       	std	Z+13, r22	; 0x0d
    1d56:	08 95       	ret

00001d58 <_ZN8TaskBase19print_stack_in_listEP8emstream>:
 *           printed separately afterwards. 
 *  @param   p_ser_dev The serial device to which each task prints its stack
 */

void TaskBase::print_stack_in_list (emstream* p_ser_dev)
{
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	0f 93       	push	r16
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	ec 01       	movw	r28, r24
    1d6a:	7b 01       	movw	r14, r22
	*p_ser_dev << PMS ("Task: ") 
			   << (const char*)(pcTaskGetTaskName (handle)) 
    1d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d70:	ce da       	rcall	.-2660   	; 0x130e <pcTaskGetTaskName>
    1d72:	6c 01       	movw	r12, r24
 *  @param   p_ser_dev The serial device to which each task prints its stack
 */

void TaskBase::print_stack_in_list (emstream* p_ser_dev)
{
	*p_ser_dev << PMS ("Task: ") 
    1d74:	6b e0       	ldi	r22, 0x0B	; 11
    1d76:	c7 01       	movw	r24, r14
    1d78:	55 d4       	rcall	.+2218   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1d7a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1d7c:	6c e7       	ldi	r22, 0x7C	; 124
    1d7e:	71 e0       	ldi	r23, 0x01	; 1
    1d80:	1a d4       	rcall	.+2100   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1d82:	b6 01       	movw	r22, r12
    1d84:	c8 01       	movw	r24, r16
    1d86:	17 d4       	rcall	.+2094   	; 0x25b6 <_ZN8emstream4putsEPKc>
			   << (const char*)(pcTaskGetTaskName (handle)) 
			   << endl;
    1d88:	66 e0       	ldi	r22, 0x06	; 6
    1d8a:	c8 01       	movw	r24, r16
    1d8c:	4b d4       	rcall	.+2198   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param   p_ser_dev The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_dev)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_dev);
    1d8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d90:	9b 85       	ldd	r25, Y+11	; 0x0b
		 *           stack's contents for debugging and instructional purposes.
		 *  @param   p_ser_dev The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_dev)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
    1d92:	28 85       	ldd	r18, Y+8	; 0x08
    1d94:	39 85       	ldd	r19, Y+9	; 0x09
								(uint8_t*)(top_of_stack), p_ser_dev);
    1d96:	a7 01       	movw	r20, r14
    1d98:	bc 01       	movw	r22, r24
    1d9a:	82 1b       	sub	r24, r18
    1d9c:	93 0b       	sbc	r25, r19
    1d9e:	e5 d2       	rcall	.+1482   	; 0x236a <_Z15hex_dump_memoryPhS_P8emstream>

	dump_stack (p_ser_dev);

	if (prev_task_pointer != NULL)
    1da0:	8c 81       	ldd	r24, Y+4	; 0x04
    1da2:	9d 81       	ldd	r25, Y+5	; 0x05
    1da4:	00 97       	sbiw	r24, 0x00	; 0
    1da6:	11 f0       	breq	.+4      	; 0x1dac <_ZN8TaskBase19print_stack_in_listEP8emstream+0x54>
	{
		prev_task_pointer->print_stack_in_list (p_ser_dev);
    1da8:	b7 01       	movw	r22, r14
    1daa:	d6 df       	rcall	.-84     	; 0x1d58 <_ZN8TaskBase19print_stack_in_listEP8emstream>
	}
}
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	ff 90       	pop	r15
    1db6:	ef 90       	pop	r14
    1db8:	df 90       	pop	r13
    1dba:	cf 90       	pop	r12
    1dbc:	08 95       	ret

00001dbe <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    1dbe:	0f 93       	push	r16
    1dc0:	1f 93       	push	r17
    1dc2:	cf 93       	push	r28
    1dc4:	df 93       	push	r29
    1dc6:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    1dc8:	80 91 2c 1a 	lds	r24, 0x1A2C
    1dcc:	90 91 2d 1a 	lds	r25, 0x1A2D
    1dd0:	00 97       	sbiw	r24, 0x00	; 0
    1dd2:	11 f0       	breq	.+4      	; 0x1dd8 <_Z17print_task_stacksP8emstream+0x1a>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    1dd4:	be 01       	movw	r22, r28
    1dd6:	c0 df       	rcall	.-128    	; 0x1d58 <_ZN8TaskBase19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << PMS ("Task: IDLE") << endl;
    1dd8:	6b e0       	ldi	r22, 0x0B	; 11
    1dda:	ce 01       	movw	r24, r28
    1ddc:	23 d4       	rcall	.+2118   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1dde:	8c 01       	movw	r16, r24
    1de0:	63 e8       	ldi	r22, 0x83	; 131
    1de2:	71 e0       	ldi	r23, 0x01	; 1
    1de4:	e8 d3       	rcall	.+2000   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1de6:	66 e0       	ldi	r22, 0x06	; 6
    1de8:	c8 01       	movw	r24, r16
    1dea:	1c d4       	rcall	.+2104   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
								(uint8_t*)(portStackTopForTask + 1), ser_dev);
    1dec:	80 91 3c 1a 	lds	r24, 0x1A3C
    1df0:	90 91 3d 1a 	lds	r25, 0x1A3D
    1df4:	bc 01       	movw	r22, r24
    1df6:	6f 5f       	subi	r22, 0xFF	; 255
    1df8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dfa:	ae 01       	movw	r20, r28
    1dfc:	83 56       	subi	r24, 0x63	; 99
    1dfe:	91 09       	sbc	r25, r1
    1e00:	b4 d2       	rcall	.+1384   	; 0x236a <_Z15hex_dump_memoryPhS_P8emstream>
}
    1e02:	df 91       	pop	r29
    1e04:	cf 91       	pop	r28
    1e06:	1f 91       	pop	r17
    1e08:	0f 91       	pop	r16
    1e0a:	08 95       	ret

00001e0c <_ZN8TaskBase12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void TaskBase::print_status (emstream& ser_dev)
{
    1e0c:	8f 92       	push	r8
    1e0e:	9f 92       	push	r9
    1e10:	af 92       	push	r10
    1e12:	bf 92       	push	r11
    1e14:	cf 92       	push	r12
    1e16:	df 92       	push	r13
    1e18:	ef 92       	push	r14
    1e1a:	ff 92       	push	r15
    1e1c:	0f 93       	push	r16
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	ec 01       	movw	r28, r24
    1e26:	8b 01       	movw	r16, r22
	ser_dev.puts (pcTaskGetTaskName (handle));
    1e28:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2c:	70 da       	rcall	.-2848   	; 0x130e <pcTaskGetTaskName>
    1e2e:	bc 01       	movw	r22, r24
    1e30:	c8 01       	movw	r24, r16
    1e32:	c1 d3       	rcall	.+1922   	; 0x25b6 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    1e34:	d8 01       	movw	r26, r16
    1e36:	ed 91       	ld	r30, X+
    1e38:	fc 91       	ld	r31, X
    1e3a:	02 80       	ldd	r0, Z+2	; 0x02
    1e3c:	f3 81       	ldd	r31, Z+3	; 0x03
    1e3e:	e0 2d       	mov	r30, r0
    1e40:	69 e0       	ldi	r22, 0x09	; 9
    1e42:	c8 01       	movw	r24, r16
    1e44:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    1e46:	8a 81       	ldd	r24, Y+2	; 0x02
    1e48:	9b 81       	ldd	r25, Y+3	; 0x03
    1e4a:	61 da       	rcall	.-2878   	; 0x130e <pcTaskGetTaskName>
    1e4c:	fc 01       	movw	r30, r24
    1e4e:	01 90       	ld	r0, Z+
    1e50:	00 20       	and	r0, r0
    1e52:	e9 f7       	brne	.-6      	; 0x1e4e <_ZN8TaskBase12print_statusER8emstream+0x42>
    1e54:	31 97       	sbiw	r30, 0x01	; 1
    1e56:	e8 1b       	sub	r30, r24
    1e58:	f9 0b       	sbc	r31, r25
    1e5a:	38 97       	sbiw	r30, 0x08	; 8
    1e5c:	48 f4       	brcc	.+18     	; 0x1e70 <_ZN8TaskBase12print_statusER8emstream+0x64>
	{
		ser_dev.putchar ('\t');
    1e5e:	d8 01       	movw	r26, r16
    1e60:	ed 91       	ld	r30, X+
    1e62:	fc 91       	ld	r31, X
    1e64:	02 80       	ldd	r0, Z+2	; 0x02
    1e66:	f3 81       	ldd	r31, Z+3	; 0x03
    1e68:	e0 2d       	mov	r30, r0
    1e6a:	69 e0       	ldi	r22, 0x09	; 9
    1e6c:	c8 01       	movw	r24, r16
    1e6e:	09 95       	icall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< (size_t)(get_total_stack ()) << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    1e70:	ce 84       	ldd	r12, Y+14	; 0x0e
    1e72:	df 84       	ldd	r13, Y+15	; 0x0f
    1e74:	e8 88       	ldd	r14, Y+16	; 0x10
    1e76:	f9 88       	ldd	r15, Y+17	; 0x11
		 *           the constructor call.
		 *  @return  The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    1e78:	a8 84       	ldd	r10, Y+8	; 0x08
    1e7a:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << (uint8_t)(uxTaskPriorityGet (handle)) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    1e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e80:	8d dd       	rcall	.-1254   	; 0x199c <uxTaskGetStackHighWaterMark>
    1e82:	98 2e       	mov	r9, r24
		 *           cause state transitions.
		 *  @return  The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    1e84:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << (uint8_t)(uxTaskPriorityGet (handle)) << PMS ("\t")
    1e86:	8a 81       	ldd	r24, Y+2	; 0x02
    1e88:	9b 81       	ldd	r25, Y+3	; 0x03
    1e8a:	ee d9       	rcall	.-3108   	; 0x1268 <uxTaskPriorityGet>
    1e8c:	68 2f       	mov	r22, r24
    1e8e:	c8 01       	movw	r24, r16
    1e90:	85 d4       	rcall	.+2314   	; 0x279c <_ZN8emstreamlsEh>
    1e92:	6b e0       	ldi	r22, 0x0B	; 11
    1e94:	c7 d3       	rcall	.+1934   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1e96:	ec 01       	movw	r28, r24
    1e98:	67 ef       	ldi	r22, 0xF7	; 247
    1e9a:	71 e0       	ldi	r23, 0x01	; 1
    1e9c:	8c d3       	rcall	.+1816   	; 0x25b6 <_ZN8emstream4putsEPKc>
			<< get_state ()
    1e9e:	68 2d       	mov	r22, r8
    1ea0:	ce 01       	movw	r24, r28
    1ea2:	7c d4       	rcall	.+2296   	; 0x279c <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    1ea4:	6b e0       	ldi	r22, 0x0B	; 11
    1ea6:	be d3       	rcall	.+1916   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1ea8:	ec 01       	movw	r28, r24
    1eaa:	69 ef       	ldi	r22, 0xF9	; 249
    1eac:	71 e0       	ldi	r23, 0x01	; 1
    1eae:	83 d3       	rcall	.+1798   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1eb0:	69 2d       	mov	r22, r9
    1eb2:	ce 01       	movw	r24, r28
    1eb4:	73 d4       	rcall	.+2278   	; 0x279c <_ZN8emstreamlsEh>
    1eb6:	6b e0       	ldi	r22, 0x0B	; 11
    1eb8:	b5 d3       	rcall	.+1898   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1eba:	ec 01       	movw	r28, r24
    1ebc:	6b ef       	ldi	r22, 0xFB	; 251
    1ebe:	71 e0       	ldi	r23, 0x01	; 1
    1ec0:	7a d3       	rcall	.+1780   	; 0x25b6 <_ZN8emstream4putsEPKc>
			<< (size_t)(get_total_stack ()) << PMS ("\t")
    1ec2:	b5 01       	movw	r22, r10
    1ec4:	ce 01       	movw	r24, r28
    1ec6:	f2 d3       	rcall	.+2020   	; 0x26ac <_ZN8emstreamlsEj>
    1ec8:	6b e0       	ldi	r22, 0x0B	; 11
    1eca:	ac d3       	rcall	.+1880   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1ecc:	ec 01       	movw	r28, r24
    1ece:	6d ef       	ldi	r22, 0xFD	; 253
    1ed0:	71 e0       	ldi	r23, 0x01	; 1
    1ed2:	71 d3       	rcall	.+1762   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    1ed4:	6b e0       	ldi	r22, 0x0B	; 11
    1ed6:	ce 01       	movw	r24, r28
    1ed8:	a5 d3       	rcall	.+1866   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1eda:	ec 01       	movw	r28, r24
    1edc:	6f ef       	ldi	r22, 0xFF	; 255
    1ede:	71 e0       	ldi	r23, 0x01	; 1
    1ee0:	6a d3       	rcall	.+1748   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1ee2:	b7 01       	movw	r22, r14
    1ee4:	a6 01       	movw	r20, r12
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	17 d4       	rcall	.+2094   	; 0x2718 <_ZN8emstreamlsEm>
}
    1eea:	df 91       	pop	r29
    1eec:	cf 91       	pop	r28
    1eee:	1f 91       	pop	r17
    1ef0:	0f 91       	pop	r16
    1ef2:	ff 90       	pop	r15
    1ef4:	ef 90       	pop	r14
    1ef6:	df 90       	pop	r13
    1ef8:	cf 90       	pop	r12
    1efa:	bf 90       	pop	r11
    1efc:	af 90       	pop	r10
    1efe:	9f 90       	pop	r9
    1f00:	8f 90       	pop	r8
    1f02:	08 95       	ret

00001f04 <_ZlsR8emstreamR8TaskBase>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, TaskBase& a_task)
{
    1f04:	cf 93       	push	r28
    1f06:	df 93       	push	r29
    1f08:	ec 01       	movw	r28, r24
    1f0a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    1f0c:	db 01       	movw	r26, r22
    1f0e:	ed 91       	ld	r30, X+
    1f10:	fc 91       	ld	r31, X
    1f12:	02 80       	ldd	r0, Z+2	; 0x02
    1f14:	f3 81       	ldd	r31, Z+3	; 0x03
    1f16:	e0 2d       	mov	r30, r0
    1f18:	be 01       	movw	r22, r28
    1f1a:	09 95       	icall
	return (ser_dev);
}
    1f1c:	ce 01       	movw	r24, r28
    1f1e:	df 91       	pop	r29
    1f20:	cf 91       	pop	r28
    1f22:	08 95       	ret

00001f24 <_ZN8TaskBase20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void TaskBase::print_status_in_list (emstream* ser_device)
{
    1f24:	0f 93       	push	r16
    1f26:	1f 93       	push	r17
    1f28:	cf 93       	push	r28
    1f2a:	df 93       	push	r29
    1f2c:	ec 01       	movw	r28, r24
    1f2e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    1f30:	bc 01       	movw	r22, r24
    1f32:	c8 01       	movw	r24, r16
    1f34:	e7 df       	rcall	.-50     	; 0x1f04 <_ZlsR8emstreamR8TaskBase>
    1f36:	66 e0       	ldi	r22, 0x06	; 6
    1f38:	75 d3       	rcall	.+1770   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    1f3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f3e:	00 97       	sbiw	r24, 0x00	; 0
    1f40:	11 f0       	breq	.+4      	; 0x1f46 <_ZN8TaskBase20print_status_in_listEP8emstream+0x22>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    1f42:	b8 01       	movw	r22, r16
    1f44:	ef df       	rcall	.-34     	; 0x1f24 <_ZN8TaskBase20print_status_in_listEP8emstream>
	}
}
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	08 95       	ret

00001f50 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    1f50:	0f 93       	push	r16
    1f52:	1f 93       	push	r17
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    1f5a:	6b e0       	ldi	r22, 0x0B	; 11
    1f5c:	63 d3       	rcall	.+1734   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1f5e:	8c 01       	movw	r16, r24
    1f60:	65 ee       	ldi	r22, 0xE5	; 229
    1f62:	71 e0       	ldi	r23, 0x01	; 1
    1f64:	28 d3       	rcall	.+1616   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    1f66:	6b e0       	ldi	r22, 0x0B	; 11
    1f68:	c8 01       	movw	r24, r16
    1f6a:	5c d3       	rcall	.+1720   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1f6c:	8c 01       	movw	r16, r24
    1f6e:	60 ef       	ldi	r22, 0xF0	; 240
    1f70:	71 e0       	ldi	r23, 0x01	; 1
    1f72:	21 d3       	rcall	.+1602   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    1f74:	66 e0       	ldi	r22, 0x06	; 6
    1f76:	c8 01       	movw	r24, r16
    1f78:	55 d3       	rcall	.+1706   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    1f7a:	6b e0       	ldi	r22, 0x0B	; 11
    1f7c:	ce 01       	movw	r24, r28
    1f7e:	52 d3       	rcall	.+1700   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1f80:	8c 01       	movw	r16, r24
    1f82:	62 ec       	ldi	r22, 0xC2	; 194
    1f84:	71 e0       	ldi	r23, 0x01	; 1
    1f86:	17 d3       	rcall	.+1582   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    1f88:	6b e0       	ldi	r22, 0x0B	; 11
    1f8a:	c8 01       	movw	r24, r16
    1f8c:	4b d3       	rcall	.+1686   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1f8e:	8c 01       	movw	r16, r24
    1f90:	63 ed       	ldi	r22, 0xD3	; 211
    1f92:	71 e0       	ldi	r23, 0x01	; 1
    1f94:	10 d3       	rcall	.+1568   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    1f96:	6b e0       	ldi	r22, 0x0B	; 11
    1f98:	c8 01       	movw	r24, r16
    1f9a:	44 d3       	rcall	.+1672   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1f9c:	8c 01       	movw	r16, r24
    1f9e:	6f ed       	ldi	r22, 0xDF	; 223
    1fa0:	71 e0       	ldi	r23, 0x01	; 1
    1fa2:	09 d3       	rcall	.+1554   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1fa4:	66 e0       	ldi	r22, 0x06	; 6
    1fa6:	c8 01       	movw	r24, r16
    1fa8:	3d d3       	rcall	.+1658   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    1faa:	6b e0       	ldi	r22, 0x0B	; 11
    1fac:	ce 01       	movw	r24, r28
    1fae:	3a d3       	rcall	.+1652   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1fb0:	8c 01       	movw	r16, r24
    1fb2:	6f e9       	ldi	r22, 0x9F	; 159
    1fb4:	71 e0       	ldi	r23, 0x01	; 1
    1fb6:	ff d2       	rcall	.+1534   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    1fb8:	6b e0       	ldi	r22, 0x0B	; 11
    1fba:	c8 01       	movw	r24, r16
    1fbc:	33 d3       	rcall	.+1638   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1fbe:	8c 01       	movw	r16, r24
    1fc0:	60 eb       	ldi	r22, 0xB0	; 176
    1fc2:	71 e0       	ldi	r23, 0x01	; 1
    1fc4:	f8 d2       	rcall	.+1520   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    1fc6:	6b e0       	ldi	r22, 0x0B	; 11
    1fc8:	c8 01       	movw	r24, r16
    1fca:	2c d3       	rcall	.+1624   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1fcc:	8c 01       	movw	r16, r24
    1fce:	6c eb       	ldi	r22, 0xBC	; 188
    1fd0:	71 e0       	ldi	r23, 0x01	; 1
    1fd2:	f1 d2       	rcall	.+1506   	; 0x25b6 <_ZN8emstream4putsEPKc>
    1fd4:	66 e0       	ldi	r22, 0x06	; 6
    1fd6:	c8 01       	movw	r24, r16
    1fd8:	25 d3       	rcall	.+1610   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    1fda:	80 91 2c 1a 	lds	r24, 0x1A2C
    1fde:	90 91 2d 1a 	lds	r25, 0x1A2D
    1fe2:	00 97       	sbiw	r24, 0x00	; 0
    1fe4:	11 f0       	breq	.+4      	; 0x1fea <_Z15print_task_listP8emstream+0x9a>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    1fe6:	be 01       	movw	r22, r28
    1fe8:	9d df       	rcall	.-198    	; 0x1f24 <_ZN8TaskBase20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    1fea:	99 d9       	rcall	.-3278   	; 0x131e <xTaskGetIdleTaskHandle>
    1fec:	d7 dc       	rcall	.-1618   	; 0x199c <uxTaskGetStackHighWaterMark>
    1fee:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    1ff0:	6b e0       	ldi	r22, 0x0B	; 11
    1ff2:	ce 01       	movw	r24, r28
    1ff4:	17 d3       	rcall	.+1582   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    1ff6:	ec 01       	movw	r28, r24
    1ff8:	6e e8       	ldi	r22, 0x8E	; 142
    1ffa:	71 e0       	ldi	r23, 0x01	; 1
    1ffc:	dc d2       	rcall	.+1464   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    1ffe:	61 2f       	mov	r22, r17
    2000:	ce 01       	movw	r24, r28
    2002:	cc d3       	rcall	.+1944   	; 0x279c <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t-")
    2004:	6b e0       	ldi	r22, 0x0B	; 11
    2006:	0e d3       	rcall	.+1564   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2008:	ec 01       	movw	r28, r24
    200a:	69 e9       	ldi	r22, 0x99	; 153
    200c:	71 e0       	ldi	r23, 0x01	; 1
    200e:	d3 d2       	rcall	.+1446   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2010:	64 e6       	ldi	r22, 0x64	; 100
    2012:	70 e0       	ldi	r23, 0x00	; 0
    2014:	ce 01       	movw	r24, r28
    2016:	4a d3       	rcall	.+1684   	; 0x26ac <_ZN8emstreamlsEj>
    2018:	6b e0       	ldi	r22, 0x0B	; 11
    201a:	04 d3       	rcall	.+1544   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    201c:	ec 01       	movw	r28, r24
    201e:	6b e9       	ldi	r22, 0x9B	; 155
    2020:	71 e0       	ldi	r23, 0x01	; 1
    2022:	c9 d2       	rcall	.+1426   	; 0x25b6 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2024:	66 e0       	ldi	r22, 0x06	; 6
    2026:	ce 01       	movw	r24, r28
    2028:	fd d2       	rcall	.+1530   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
}
    202a:	df 91       	pop	r29
    202c:	cf 91       	pop	r28
    202e:	1f 91       	pop	r17
    2030:	0f 91       	pop	r16
    2032:	08 95       	ret

00002034 <_ZN9TextQueue13print_in_listEP8emstream>:
 *           device. 
 *  @param   p_ser_dev Pointer to a serial device on which to print the status
 */

void TextQueue::print_in_list (emstream* p_ser_dev)
{
    2034:	cf 92       	push	r12
    2036:	df 92       	push	r13
    2038:	ef 92       	push	r14
    203a:	ff 92       	push	r15
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	7c 01       	movw	r14, r24
    2046:	8b 01       	movw	r16, r22
    2048:	dc 01       	movw	r26, r24
    204a:	1a 96       	adiw	r26, 0x0a	; 10
    204c:	6d 91       	ld	r22, X+
    204e:	7c 91       	ld	r23, X
    2050:	1b 97       	sbiw	r26, 0x0b	; 11
    2052:	c8 01       	movw	r24, r16
    2054:	b0 d2       	rcall	.+1376   	; 0x25b6 <_ZN8emstream4putsEPKc>
	// Print this task's name and pad it to 16 characters
	*p_ser_dev << name;
	for (uint8_t cols = strlen (name); cols < 16; cols++)
    2056:	f7 01       	movw	r30, r14
    2058:	a2 85       	ldd	r26, Z+10	; 0x0a
    205a:	b3 85       	ldd	r27, Z+11	; 0x0b
    205c:	fd 01       	movw	r30, r26
    205e:	01 90       	ld	r0, Z+
    2060:	00 20       	and	r0, r0
    2062:	e9 f7       	brne	.-6      	; 0x205e <_ZN9TextQueue13print_in_listEP8emstream+0x2a>
    2064:	31 97       	sbiw	r30, 0x01	; 1
    2066:	ce 2f       	mov	r28, r30
    2068:	ca 1b       	sub	r28, r26
    206a:	c0 31       	cpi	r28, 0x10	; 16
    206c:	60 f4       	brcc	.+24     	; 0x2086 <_ZN9TextQueue13print_in_listEP8emstream+0x52>
	{
		p_ser_dev->putchar (' ');
    206e:	d8 01       	movw	r26, r16
    2070:	ed 91       	ld	r30, X+
    2072:	fc 91       	ld	r31, X
    2074:	02 80       	ldd	r0, Z+2	; 0x02
    2076:	f3 81       	ldd	r31, Z+3	; 0x03
    2078:	e0 2d       	mov	r30, r0
    207a:	60 e2       	ldi	r22, 0x20	; 32
    207c:	c8 01       	movw	r24, r16
    207e:	09 95       	icall

void TextQueue::print_in_list (emstream* p_ser_dev)
{
	// Print this task's name and pad it to 16 characters
	*p_ser_dev << name;
	for (uint8_t cols = strlen (name); cols < 16; cols++)
    2080:	cf 5f       	subi	r28, 0xFF	; 255
    2082:	c0 31       	cpi	r28, 0x10	; 16
    2084:	a1 f7       	brne	.-24     	; 0x206e <_ZN9TextQueue13print_in_listEP8emstream+0x3a>
	{
		p_ser_dev->putchar (' ');
	}

	// Print the type
	p_ser_dev->puts ("txt_q\t");
    2086:	6b e1       	ldi	r22, 0x1B	; 27
    2088:	72 e0       	ldi	r23, 0x02	; 2
    208a:	c8 01       	movw	r24, r16
    208c:	94 d2       	rcall	.+1320   	; 0x25b6 <_ZN8emstream4putsEPKc>

	// Print the free and total number of spaces in the queue
	*p_ser_dev << uxQueueSpacesAvailable (the_queue) << '/' << buf_size << '\t';
    208e:	f7 01       	movw	r30, r14
    2090:	c6 88       	ldd	r12, Z+22	; 0x16
    2092:	d7 88       	ldd	r13, Z+23	; 0x17
    2094:	86 85       	ldd	r24, Z+14	; 0x0e
    2096:	97 85       	ldd	r25, Z+15	; 0x0f
    2098:	0e 94 d6 07 	call	0xfac	; 0xfac <uxQueueSpacesAvailable>
    209c:	68 2f       	mov	r22, r24
    209e:	c8 01       	movw	r24, r16
    20a0:	7d d3       	rcall	.+1786   	; 0x279c <_ZN8emstreamlsEh>
    20a2:	ec 01       	movw	r28, r24
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    20a4:	e8 81       	ld	r30, Y
    20a6:	f9 81       	ldd	r31, Y+1	; 0x01
    20a8:	02 80       	ldd	r0, Z+2	; 0x02
    20aa:	f3 81       	ldd	r31, Z+3	; 0x03
    20ac:	e0 2d       	mov	r30, r0
    20ae:	6f e2       	ldi	r22, 0x2F	; 47
    20b0:	09 95       	icall
    20b2:	b6 01       	movw	r22, r12
    20b4:	ce 01       	movw	r24, r28
    20b6:	fa d2       	rcall	.+1524   	; 0x26ac <_ZN8emstreamlsEj>
    20b8:	dc 01       	movw	r26, r24
    20ba:	ed 91       	ld	r30, X+
    20bc:	fc 91       	ld	r31, X
    20be:	02 80       	ldd	r0, Z+2	; 0x02
    20c0:	f3 81       	ldd	r31, Z+3	; 0x03
    20c2:	e0 2d       	mov	r30, r0
    20c4:	69 e0       	ldi	r22, 0x09	; 9
    20c6:	09 95       	icall

	// End the line
	*p_ser_dev << endl;
    20c8:	66 e0       	ldi	r22, 0x06	; 6
    20ca:	c8 01       	movw	r24, r16
    20cc:	ab d2       	rcall	.+1366   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	// Call the next item
	if (p_next != NULL)
    20ce:	f7 01       	movw	r30, r14
    20d0:	84 85       	ldd	r24, Z+12	; 0x0c
    20d2:	95 85       	ldd	r25, Z+13	; 0x0d
    20d4:	00 97       	sbiw	r24, 0x00	; 0
    20d6:	41 f0       	breq	.+16     	; 0x20e8 <_ZN9TextQueue13print_in_listEP8emstream+0xb4>
	{
		p_next->print_in_list (p_ser_dev);
    20d8:	dc 01       	movw	r26, r24
    20da:	ed 91       	ld	r30, X+
    20dc:	fc 91       	ld	r31, X
    20de:	01 90       	ld	r0, Z+
    20e0:	f0 81       	ld	r31, Z
    20e2:	e0 2d       	mov	r30, r0
    20e4:	b8 01       	movw	r22, r16
    20e6:	09 95       	icall
	}
}
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	1f 91       	pop	r17
    20ee:	0f 91       	pop	r16
    20f0:	ff 90       	pop	r15
    20f2:	ef 90       	pop	r14
    20f4:	df 90       	pop	r13
    20f6:	cf 90       	pop	r12
    20f8:	08 95       	ret

000020fa <_ZThn6_N9TextQueue13print_in_listEP8emstream>:
    20fa:	06 97       	sbiw	r24, 0x06	; 6
    20fc:	9b cf       	rjmp	.-202    	; 0x2034 <_ZN9TextQueue13print_in_listEP8emstream>

000020fe <_ZN9TextQueue7getcharEv>:
 *           receiving task will not waste processor time until a character shows up.
 *  @return  The character which was received from the queue
 */

inline char TextQueue::getchar (void)
{
    20fe:	0f 93       	push	r16
    2100:	cf 93       	push	r28
    2102:	df 93       	push	r29
    2104:	1f 92       	push	r1
    2106:	cd b7       	in	r28, 0x3d	; 61
    2108:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    210a:	00 e0       	ldi	r16, 0x00	; 0
    210c:	2f ef       	ldi	r18, 0xFF	; 255
    210e:	3f ef       	ldi	r19, 0xFF	; 255
    2110:	a9 01       	movw	r20, r18
    2112:	be 01       	movw	r22, r28
    2114:	6f 5f       	subi	r22, 0xFF	; 255
    2116:	7f 4f       	sbci	r23, 0xFF	; 255
    2118:	fc 01       	movw	r30, r24
    211a:	86 85       	ldd	r24, Z+14	; 0x0e
    211c:	97 85       	ldd	r25, Z+15	; 0x0f
    211e:	0e 94 12 07 	call	0xe24	; 0xe24 <xQueueGenericReceive>
    2122:	81 30       	cpi	r24, 0x01	; 1
    2124:	11 f4       	brne	.+4      	; 0x212a <_ZN9TextQueue7getcharEv+0x2c>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2126:	89 81       	ldd	r24, Y+1	; 0x01
    2128:	01 c0       	rjmp	.+2      	; 0x212c <_ZN9TextQueue7getcharEv+0x2e>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    212a:	8f ef       	ldi	r24, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    212c:	0f 90       	pop	r0
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	0f 91       	pop	r16
    2134:	08 95       	ret

00002136 <_ZN9TextQueue14check_for_charEv>:
 *  @return  True for character available, false for no character available
 */

inline bool TextQueue::check_for_char (void)
{
	return (uxQueueMessagesWaiting (the_queue));
    2136:	fc 01       	movw	r30, r24
    2138:	86 85       	ldd	r24, Z+14	; 0x0e
    213a:	97 85       	ldd	r25, Z+15	; 0x0f
    213c:	0e 94 ce 07 	call	0xf9c	; 0xf9c <uxQueueMessagesWaiting>
    2140:	91 e0       	ldi	r25, 0x01	; 1
    2142:	81 11       	cpse	r24, r1
    2144:	01 c0       	rjmp	.+2      	; 0x2148 <_ZN9TextQueue14check_for_charEv+0x12>
    2146:	90 e0       	ldi	r25, 0x00	; 0
}
    2148:	89 2f       	mov	r24, r25
    214a:	08 95       	ret

0000214c <_ZN9TextQueue7putcharEc>:
 *           and return. 
 *  @param   a_char The character to be sent to the queue
 */

inline void TextQueue::putchar (char a_char)
{
    214c:	0f 93       	push	r16
    214e:	cf 93       	push	r28
    2150:	df 93       	push	r29
    2152:	1f 92       	push	r1
    2154:	cd b7       	in	r28, 0x3d	; 61
    2156:	de b7       	in	r29, 0x3e	; 62
    2158:	69 83       	std	Y+1, r22	; 0x01
	xQueueSendToBack (the_queue, &a_char, ticks_to_wait);
    215a:	fc 01       	movw	r30, r24
    215c:	20 89       	ldd	r18, Z+16	; 0x10
    215e:	31 89       	ldd	r19, Z+17	; 0x11
    2160:	42 89       	ldd	r20, Z+18	; 0x12
    2162:	53 89       	ldd	r21, Z+19	; 0x13
    2164:	00 e0       	ldi	r16, 0x00	; 0
    2166:	be 01       	movw	r22, r28
    2168:	6f 5f       	subi	r22, 0xFF	; 255
    216a:	7f 4f       	sbci	r23, 0xFF	; 255
    216c:	86 85       	ldd	r24, Z+14	; 0x0e
    216e:	97 85       	ldd	r25, Z+15	; 0x0f
    2170:	0e 94 76 06 	call	0xcec	; 0xcec <xQueueGenericSend>
}
    2174:	0f 90       	pop	r0
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	0f 91       	pop	r16
    217c:	08 95       	ret

0000217e <_ZN9TextQueueC1EjPKcP8emstreamm>:
 *                       portMAX_DELAY causes a send to block indefinitely
 *  @param   p_ser_dev A pointer which points to a serial device which can be used for
 *                     diagnostic logging or printing
 */

TextQueue::TextQueue (uint16_t queue_size, const char* p_name, emstream* p_ser_dev,
    217e:	4f 92       	push	r4
    2180:	5f 92       	push	r5
    2182:	6f 92       	push	r6
    2184:	7f 92       	push	r7
    2186:	8f 92       	push	r8
    2188:	9f 92       	push	r9
    218a:	af 92       	push	r10
    218c:	bf 92       	push	r11
    218e:	cf 92       	push	r12
    2190:	df 92       	push	r13
    2192:	ef 92       	push	r14
    2194:	ff 92       	push	r15
    2196:	0f 93       	push	r16
    2198:	1f 93       	push	r17
    219a:	cf 93       	push	r28
    219c:	df 93       	push	r29
    219e:	ec 01       	movw	r28, r24
    21a0:	d6 2e       	mov	r13, r22
    21a2:	c7 2e       	mov	r12, r23
    21a4:	4a 01       	movw	r8, r20
    21a6:	59 01       	movw	r10, r18
					  TickType_t a_wait_time)
	: emstream (), BaseShare (p_name)
    21a8:	fb d1       	rcall	.+1014   	; 0x25a0 <_ZN8emstreamC1Ev>
    21aa:	b4 01       	movw	r22, r8
    21ac:	ce 01       	movw	r24, r28
    21ae:	06 96       	adiw	r24, 0x06	; 6
    21b0:	c2 dc       	rcall	.-1660   	; 0x1b36 <_ZN9BaseShareC1EPKc>
    21b2:	86 e2       	ldi	r24, 0x26	; 38
    21b4:	92 e0       	ldi	r25, 0x02	; 2
    21b6:	99 83       	std	Y+1, r25	; 0x01
    21b8:	88 83       	st	Y, r24
    21ba:	88 e3       	ldi	r24, 0x38	; 56
    21bc:	92 e0       	ldi	r25, 0x02	; 2
    21be:	9f 83       	std	Y+7, r25	; 0x07
    21c0:	8e 83       	std	Y+6, r24	; 0x06
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    21c2:	bd 8a       	std	Y+21, r11	; 0x15
    21c4:	ac 8a       	std	Y+20, r10	; 0x14

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	61 e0       	ldi	r22, 0x01	; 1
    21ca:	8d 2d       	mov	r24, r13
    21cc:	0e 94 4c 06 	call	0xc98	; 0xc98 <xQueueGenericCreate>
    21d0:	9f 87       	std	Y+15, r25	; 0x0f
    21d2:	8e 87       	std	Y+14, r24	; 0x0e

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    21d4:	e8 8a       	std	Y+16, r14	; 0x10
    21d6:	f9 8a       	std	Y+17, r15	; 0x11
    21d8:	0a 8b       	std	Y+18, r16	; 0x12
    21da:	1b 8b       	std	Y+19, r17	; 0x13

	// Save the buffer size
	buf_size = queue_size;
    21dc:	de 8a       	std	Y+22, r13	; 0x16
    21de:	cf 8a       	std	Y+23, r12	; 0x17
}
    21e0:	df 91       	pop	r29
    21e2:	cf 91       	pop	r28
    21e4:	1f 91       	pop	r17
    21e6:	0f 91       	pop	r16
    21e8:	ff 90       	pop	r15
    21ea:	ef 90       	pop	r14
    21ec:	df 90       	pop	r13
    21ee:	cf 90       	pop	r12
    21f0:	bf 90       	pop	r11
    21f2:	af 90       	pop	r10
    21f4:	9f 90       	pop	r9
    21f6:	8f 90       	pop	r8
    21f8:	7f 90       	pop	r7
    21fa:	6f 90       	pop	r6
    21fc:	5f 90       	pop	r5
    21fe:	4f 90       	pop	r4
    2200:	08 95       	ret

00002202 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2202:	cf 92       	push	r12
    2204:	df 92       	push	r13
    2206:	ef 92       	push	r14
    2208:	ff 92       	push	r15
    220a:	cf 93       	push	r28
    220c:	df 93       	push	r29
    220e:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
    2210:	68 81       	ld	r22, Y
    2212:	79 81       	ldd	r23, Y+1	; 0x01
    2214:	8a 81       	ldd	r24, Y+2	; 0x02
    2216:	9b 81       	ldd	r25, Y+3	; 0x03
    2218:	0f 2e       	mov	r0, r31
    221a:	f8 ee       	ldi	r31, 0xE8	; 232
    221c:	cf 2e       	mov	r12, r31
    221e:	f3 e0       	ldi	r31, 0x03	; 3
    2220:	df 2e       	mov	r13, r31
    2222:	e1 2c       	mov	r14, r1
    2224:	f1 2c       	mov	r15, r1
    2226:	f0 2d       	mov	r31, r0
    2228:	a7 01       	movw	r20, r14
    222a:	96 01       	movw	r18, r12
    222c:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodsi4>
    2230:	9b 01       	movw	r18, r22
    2232:	ac 01       	movw	r20, r24
    2234:	60 e4       	ldi	r22, 0x40	; 64
    2236:	72 e4       	ldi	r23, 0x42	; 66
    2238:	8f e0       	ldi	r24, 0x0F	; 15
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	f2 d7       	rcall	.+4068   	; 0x3222 <__mulsi3>
    223e:	a7 01       	movw	r20, r14
    2240:	96 01       	movw	r18, r12
    2242:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodsi4>
    2246:	69 01       	movw	r12, r18
    2248:	7a 01       	movw	r14, r20
			+ (int32_t)hardware_count * 1000000L 
    224a:	ac 81       	ldd	r26, Y+4	; 0x04
    224c:	bd 81       	ldd	r27, Y+5	; 0x05
    224e:	20 e4       	ldi	r18, 0x40	; 64
    2250:	32 e4       	ldi	r19, 0x42	; 66
    2252:	4f e0       	ldi	r20, 0x0F	; 15
    2254:	50 e0       	ldi	r21, 0x00	; 0
    2256:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <__muluhisi3>
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
    225a:	20 e8       	ldi	r18, 0x80	; 128
    225c:	34 e8       	ldi	r19, 0x84	; 132
    225e:	4e e1       	ldi	r20, 0x1E	; 30
    2260:	50 e0       	ldi	r21, 0x00	; 0
    2262:	0e 94 55 19 	call	0x32aa	; 0x32aa <__divmodsi4>
	);
    2266:	c7 01       	movw	r24, r14
    2268:	b6 01       	movw	r22, r12
    226a:	62 0f       	add	r22, r18
    226c:	73 1f       	adc	r23, r19
    226e:	84 1f       	adc	r24, r20
    2270:	95 1f       	adc	r25, r21
}
    2272:	df 91       	pop	r29
    2274:	cf 91       	pop	r28
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	df 90       	pop	r13
    227c:	cf 90       	pop	r12
    227e:	08 95       	ret

00002280 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2280:	cf 92       	push	r12
    2282:	df 92       	push	r13
    2284:	ef 92       	push	r14
    2286:	ff 92       	push	r15
    2288:	0f 93       	push	r16
    228a:	1f 93       	push	r17
    228c:	cf 93       	push	r28
    228e:	df 93       	push	r29
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	2f 97       	sbiw	r28, 0x0f	; 15
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	6c 01       	movw	r12, r24
    22a2:	8b 01       	movw	r16, r22
		 *  computing the number of seconds. 
		 *  @return The number of whole seconds in the time stamp
		 */
		uint32_t get_seconds (void)
		{
			return (tick_count / configTICK_RATE_HZ);
    22a4:	db 01       	movw	r26, r22
    22a6:	6d 91       	ld	r22, X+
    22a8:	7d 91       	ld	r23, X+
    22aa:	8d 91       	ld	r24, X+
    22ac:	9c 91       	ld	r25, X
    22ae:	28 ee       	ldi	r18, 0xE8	; 232
    22b0:	33 e0       	ldi	r19, 0x03	; 3
    22b2:	40 e0       	ldi	r20, 0x00	; 0
    22b4:	50 e0       	ldi	r21, 0x00	; 0
    22b6:	d7 d7       	rcall	.+4014   	; 0x3266 <__udivmodsi4>
    22b8:	ba 01       	movw	r22, r20
    22ba:	a9 01       	movw	r20, r18
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    22bc:	c6 01       	movw	r24, r12
    22be:	2c d2       	rcall	.+1112   	; 0x2718 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    22c0:	d6 01       	movw	r26, r12
    22c2:	ed 91       	ld	r30, X+
    22c4:	fc 91       	ld	r31, X
    22c6:	02 80       	ldd	r0, Z+2	; 0x02
    22c8:	f3 81       	ldd	r31, Z+3	; 0x03
    22ca:	e0 2d       	mov	r30, r0
    22cc:	6e e2       	ldi	r22, 0x2E	; 46
    22ce:	c6 01       	movw	r24, r12
    22d0:	09 95       	icall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    22d2:	c8 01       	movw	r24, r16
    22d4:	96 df       	rcall	.-212    	; 0x2202 <_ZN10time_stamp12get_microsecEv>
    22d6:	8e 01       	movw	r16, r28
    22d8:	01 5f       	subi	r16, 0xF1	; 241
    22da:	1f 4f       	sbci	r17, 0xFF	; 255
    22dc:	fe 01       	movw	r30, r28
    22de:	39 96       	adiw	r30, 0x09	; 9
    22e0:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    22e2:	2a e0       	ldi	r18, 0x0A	; 10
    22e4:	30 e0       	ldi	r19, 0x00	; 0
    22e6:	40 e0       	ldi	r20, 0x00	; 0
    22e8:	50 e0       	ldi	r21, 0x00	; 0
    22ea:	df d7       	rcall	.+4030   	; 0x32aa <__divmodsi4>
    22ec:	e6 2f       	mov	r30, r22
    22ee:	29 83       	std	Y+1, r18	; 0x01
    22f0:	3a 83       	std	Y+2, r19	; 0x02
    22f2:	4b 83       	std	Y+3, r20	; 0x03
    22f4:	5c 83       	std	Y+4, r21	; 0x04
    22f6:	69 81       	ldd	r22, Y+1	; 0x01
    22f8:	7a 81       	ldd	r23, Y+2	; 0x02
    22fa:	8b 81       	ldd	r24, Y+3	; 0x03
    22fc:	9c 81       	ldd	r25, Y+4	; 0x04
		dig_buffer[index] = div_result.rem + '0';
    22fe:	20 e3       	ldi	r18, 0x30	; 48
    2300:	2e 0f       	add	r18, r30
    2302:	d8 01       	movw	r26, r16
    2304:	2e 93       	st	-X, r18
    2306:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2308:	ae 15       	cp	r26, r14
    230a:	bf 05       	cpc	r27, r15
    230c:	51 f7       	brne	.-44     	; 0x22e2 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    230e:	1f 86       	std	Y+15, r1	; 0x0f
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2310:	be 01       	movw	r22, r28
    2312:	67 5f       	subi	r22, 0xF7	; 247
    2314:	7f 4f       	sbci	r23, 0xFF	; 255
    2316:	c6 01       	movw	r24, r12
    2318:	4e d1       	rcall	.+668    	; 0x25b6 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    231a:	c6 01       	movw	r24, r12
    231c:	2f 96       	adiw	r28, 0x0f	; 15
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	de bf       	out	0x3e, r29	; 62
    2324:	0f be       	out	0x3f, r0	; 63
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	df 91       	pop	r29
    232a:	cf 91       	pop	r28
    232c:	1f 91       	pop	r17
    232e:	0f 91       	pop	r16
    2330:	ff 90       	pop	r15
    2332:	ef 90       	pop	r14
    2334:	df 90       	pop	r13
    2336:	cf 90       	pop	r12
    2338:	08 95       	ret

0000233a <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    233a:	cf 93       	push	r28
    233c:	df 93       	push	r29
    233e:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	0f 92       	push	r0

	// Now grab the hardware timer count. The tick count can't be updated, even if the
	// hardware timer overflows, because interrupts are disabled
	#if (defined TIMER5_COMPA_vect)
		hardware_count = TCNT5;
    2346:	80 91 24 01 	lds	r24, 0x0124
    234a:	90 91 25 01 	lds	r25, 0x0125
    234e:	9d 83       	std	Y+5, r25	; 0x05
    2350:	8c 83       	std	Y+4, r24	; 0x04
	#else
		hardware_count = TCNT1;
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2352:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGetTickCount>
    2356:	68 83       	st	Y, r22
    2358:	79 83       	std	Y+1, r23	; 0x01
    235a:	8a 83       	std	Y+2, r24	; 0x02
    235c:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    235e:	0f 90       	pop	r0
    2360:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2362:	ce 01       	movw	r24, r28
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	08 95       	ret

0000236a <_Z15hex_dump_memoryPhS_P8emstream>:
 *  @param p_ser_dev Pointer to the serial device on which data will be shown
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev)
{
    236a:	8f 92       	push	r8
    236c:	9f 92       	push	r9
    236e:	af 92       	push	r10
    2370:	bf 92       	push	r11
    2372:	cf 92       	push	r12
    2374:	df 92       	push	r13
    2376:	ef 92       	push	r14
    2378:	ff 92       	push	r15
    237a:	0f 93       	push	r16
    237c:	1f 93       	push	r17
    237e:	cf 93       	push	r28
    2380:	df 93       	push	r29
    2382:	6c 01       	movw	r12, r24
    2384:	5b 01       	movw	r10, r22
    2386:	ea 01       	movw	r28, r20
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2388:	63 e0       	ldi	r22, 0x03	; 3
    238a:	ca 01       	movw	r24, r20
    238c:	4b d1       	rcall	.+662    	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    238e:	ca 14       	cp	r12, r10
    2390:	db 04       	cpc	r13, r11
    2392:	08 f0       	brcs	.+2      	; 0x2396 <_Z15hex_dump_memoryPhS_P8emstream+0x2c>
    2394:	5b c0       	rjmp	.+182    	; 0x244c <_Z15hex_dump_memoryPhS_P8emstream+0xe2>
    2396:	76 01       	movw	r14, r12
    2398:	84 e1       	ldi	r24, 0x14	; 20
    239a:	e8 0e       	add	r14, r24
    239c:	f1 1c       	adc	r15, r1
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    239e:	8c 2c       	mov	r8, r12
    23a0:	9d 2c       	mov	r9, r13
    23a2:	b6 01       	movw	r22, r12
    23a4:	ce 01       	movw	r24, r28
    23a6:	82 d1       	rcall	.+772    	; 0x26ac <_ZN8emstreamlsEj>
    23a8:	6b e0       	ldi	r22, 0x0B	; 11
    23aa:	3c d1       	rcall	.+632    	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    23ac:	61 e0       	ldi	r22, 0x01	; 1
    23ae:	72 e0       	ldi	r23, 0x02	; 2
    23b0:	02 d1       	rcall	.+516    	; 0x25b6 <_ZN8emstream4putsEPKc>
    23b2:	86 01       	movw	r16, r12

		// Show a line full of data in hexadecimal format
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			*p_ser_dev << (uint8_t)(*start_address++);
    23b4:	f8 01       	movw	r30, r16
    23b6:	61 91       	ld	r22, Z+
    23b8:	8f 01       	movw	r16, r30
    23ba:	ce 01       	movw	r24, r28
    23bc:	ef d1       	rcall	.+990    	; 0x279c <_ZN8emstreamlsEh>
			p_ser_dev->putchar (' ');
    23be:	e8 81       	ld	r30, Y
    23c0:	f9 81       	ldd	r31, Y+1	; 0x01
    23c2:	02 80       	ldd	r0, Z+2	; 0x02
    23c4:	f3 81       	ldd	r31, Z+3	; 0x03
    23c6:	e0 2d       	mov	r30, r0
    23c8:	60 e2       	ldi	r22, 0x20	; 32
    23ca:	ce 01       	movw	r24, r28
    23cc:	09 95       	icall
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");

		// Show a line full of data in hexadecimal format
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    23ce:	e0 16       	cp	r14, r16
    23d0:	f1 06       	cpc	r15, r17
    23d2:	81 f7       	brne	.-32     	; 0x23b4 <_Z15hex_dump_memoryPhS_P8emstream+0x4a>
			*p_ser_dev << (uint8_t)(*start_address++);
			p_ser_dev->putchar (' ');
		}

		// Show the same line full of data in text format
		p_ser_dev->putchar (' ');
    23d4:	e8 81       	ld	r30, Y
    23d6:	f9 81       	ldd	r31, Y+1	; 0x01
    23d8:	02 80       	ldd	r0, Z+2	; 0x02
    23da:	f3 81       	ldd	r31, Z+3	; 0x03
    23dc:	e0 2d       	mov	r30, r0
    23de:	60 e2       	ldi	r22, 0x20	; 32
    23e0:	ce 01       	movw	r24, r28
    23e2:	09 95       	icall
    23e4:	08 2d       	mov	r16, r8
    23e6:	19 2d       	mov	r17, r9
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    23e8:	f8 01       	movw	r30, r16
    23ea:	61 91       	ld	r22, Z+
    23ec:	8f 01       	movw	r16, r30
			if (temp_byte == 0xA5)
    23ee:	65 3a       	cpi	r22, 0xA5	; 165
    23f0:	49 f4       	brne	.+18     	; 0x2404 <_Z15hex_dump_memoryPhS_P8emstream+0x9a>
			{
				p_ser_dev->putchar (' ');
    23f2:	e8 81       	ld	r30, Y
    23f4:	f9 81       	ldd	r31, Y+1	; 0x01
    23f6:	02 80       	ldd	r0, Z+2	; 0x02
    23f8:	f3 81       	ldd	r31, Z+3	; 0x03
    23fa:	e0 2d       	mov	r30, r0
    23fc:	60 e2       	ldi	r22, 0x20	; 32
    23fe:	ce 01       	movw	r24, r28
    2400:	09 95       	icall
    2402:	14 c0       	rjmp	.+40     	; 0x242c <_Z15hex_dump_memoryPhS_P8emstream+0xc2>
			}
			else if (temp_byte >= ' ' && temp_byte <= '~')
    2404:	80 ee       	ldi	r24, 0xE0	; 224
    2406:	86 0f       	add	r24, r22
    2408:	8f 35       	cpi	r24, 0x5F	; 95
    240a:	40 f4       	brcc	.+16     	; 0x241c <_Z15hex_dump_memoryPhS_P8emstream+0xb2>
			{
				p_ser_dev->putchar (temp_byte);
    240c:	e8 81       	ld	r30, Y
    240e:	f9 81       	ldd	r31, Y+1	; 0x01
    2410:	02 80       	ldd	r0, Z+2	; 0x02
    2412:	f3 81       	ldd	r31, Z+3	; 0x03
    2414:	e0 2d       	mov	r30, r0
    2416:	ce 01       	movw	r24, r28
    2418:	09 95       	icall
    241a:	08 c0       	rjmp	.+16     	; 0x242c <_Z15hex_dump_memoryPhS_P8emstream+0xc2>
			}
			else
			{
				p_ser_dev->putchar ('.');
    241c:	e8 81       	ld	r30, Y
    241e:	f9 81       	ldd	r31, Y+1	; 0x01
    2420:	02 80       	ldd	r0, Z+2	; 0x02
    2422:	f3 81       	ldd	r31, Z+3	; 0x03
    2424:	e0 2d       	mov	r30, r0
    2426:	6e e2       	ldi	r22, 0x2E	; 46
    2428:	ce 01       	movw	r24, r28
    242a:	09 95       	icall
			p_ser_dev->putchar (' ');
		}

		// Show the same line full of data in text format
		p_ser_dev->putchar (' ');
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    242c:	e0 16       	cp	r14, r16
    242e:	f1 06       	cpc	r15, r17
    2430:	d9 f6       	brne	.-74     	; 0x23e8 <_Z15hex_dump_memoryPhS_P8emstream+0x7e>
    2432:	f4 e1       	ldi	r31, 0x14	; 20
    2434:	cf 0e       	add	r12, r31
    2436:	d1 1c       	adc	r13, r1
				p_ser_dev->putchar ('.');
			}
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2438:	66 e0       	ldi	r22, 0x06	; 6
    243a:	ce 01       	movw	r24, r28
    243c:	f3 d0       	rcall	.+486    	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    243e:	84 e1       	ldi	r24, 0x14	; 20
    2440:	e8 0e       	add	r14, r24
    2442:	f1 1c       	adc	r15, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2444:	ca 14       	cp	r12, r10
    2446:	db 04       	cpc	r13, r11
    2448:	08 f4       	brcc	.+2      	; 0x244c <_Z15hex_dump_memoryPhS_P8emstream+0xe2>
    244a:	a9 cf       	rjmp	.-174    	; 0x239e <_Z15hex_dump_memoryPhS_P8emstream+0x34>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    244c:	62 e0       	ldi	r22, 0x02	; 2
    244e:	ce 01       	movw	r24, r28
    2450:	e9 d0       	rcall	.+466    	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
}
    2452:	df 91       	pop	r29
    2454:	cf 91       	pop	r28
    2456:	1f 91       	pop	r17
    2458:	0f 91       	pop	r16
    245a:	ff 90       	pop	r15
    245c:	ef 90       	pop	r14
    245e:	df 90       	pop	r13
    2460:	cf 90       	pop	r12
    2462:	bf 90       	pop	r11
    2464:	af 90       	pop	r10
    2466:	9f 90       	pop	r9
    2468:	8f 90       	pop	r8
    246a:	08 95       	ret

0000246c <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    246c:	0c 94 8a 02 	jmp	0x514	; 0x514 <pvPortMalloc>
    2470:	08 95       	ret

00002472 <_Znaj>:
    2472:	0c 94 8a 02 	jmp	0x514	; 0x514 <pvPortMalloc>
    2476:	08 95       	ret

00002478 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2478:	08 95       	ret

0000247a <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    247a:	0f 93       	push	r16
    247c:	1f 93       	push	r17
    247e:	cf 93       	push	r28
    2480:	df 93       	push	r29
    2482:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    2484:	41 11       	cpse	r20, r1
    2486:	3a c0       	rjmp	.+116    	; 0x24fc <_ZN7base232C1Ejh+0x82>
		{
			p_UDR = &UDR0;
    2488:	86 ec       	ldi	r24, 0xC6	; 198
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	99 83       	std	Y+1, r25	; 0x01
    248e:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    2490:	00 ec       	ldi	r16, 0xC0	; 192
    2492:	10 e0       	ldi	r17, 0x00	; 0
    2494:	1b 83       	std	Y+3, r17	; 0x03
    2496:	0a 83       	std	Y+2, r16	; 0x02
			p_UCR = &UCSR0B;
    2498:	e1 ec       	ldi	r30, 0xC1	; 193
    249a:	f0 e0       	ldi	r31, 0x00	; 0
    249c:	fd 83       	std	Y+5, r31	; 0x05
    249e:	ec 83       	std	Y+4, r30	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    24a0:	88 e1       	ldi	r24, 0x18	; 24
    24a2:	80 83       	st	Z, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    24a4:	86 e0       	ldi	r24, 0x06	; 6
    24a6:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    24aa:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    24ae:	cb 01       	movw	r24, r22
    24b0:	a0 e0       	ldi	r26, 0x00	; 0
    24b2:	b0 e0       	ldi	r27, 0x00	; 0
    24b4:	88 0f       	add	r24, r24
    24b6:	99 1f       	adc	r25, r25
    24b8:	aa 1f       	adc	r26, r26
    24ba:	bb 1f       	adc	r27, r27
    24bc:	88 0f       	add	r24, r24
    24be:	99 1f       	adc	r25, r25
    24c0:	aa 1f       	adc	r26, r26
    24c2:	bb 1f       	adc	r27, r27
    24c4:	9c 01       	movw	r18, r24
    24c6:	ad 01       	movw	r20, r26
    24c8:	22 0f       	add	r18, r18
    24ca:	33 1f       	adc	r19, r19
    24cc:	44 1f       	adc	r20, r20
    24ce:	55 1f       	adc	r21, r21
    24d0:	22 0f       	add	r18, r18
    24d2:	33 1f       	adc	r19, r19
    24d4:	44 1f       	adc	r20, r20
    24d6:	55 1f       	adc	r21, r21
    24d8:	60 e0       	ldi	r22, 0x00	; 0
    24da:	74 e2       	ldi	r23, 0x24	; 36
    24dc:	84 ef       	ldi	r24, 0xF4	; 244
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	c2 d6       	rcall	.+3460   	; 0x3266 <__udivmodsi4>
    24e2:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    24e6:	f8 01       	movw	r30, r16
    24e8:	80 81       	ld	r24, Z
    24ea:	81 60       	ori	r24, 0x01	; 1
    24ec:	80 83       	st	Z, r24
			#endif
			mask_UDRE = (1 << UDRE0);
    24ee:	80 e2       	ldi	r24, 0x20	; 32
    24f0:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC0);
    24f2:	80 e8       	ldi	r24, 0x80	; 128
    24f4:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC0);
    24f6:	80 e4       	ldi	r24, 0x40	; 64
    24f8:	88 87       	std	Y+8, r24	; 0x08
    24fa:	39 c0       	rjmp	.+114    	; 0x256e <_ZN7base232C1Ejh+0xf4>
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    24fc:	8e ec       	ldi	r24, 0xCE	; 206
    24fe:	90 e0       	ldi	r25, 0x00	; 0
    2500:	99 83       	std	Y+1, r25	; 0x01
    2502:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    2504:	08 ec       	ldi	r16, 0xC8	; 200
    2506:	10 e0       	ldi	r17, 0x00	; 0
    2508:	1b 83       	std	Y+3, r17	; 0x03
    250a:	0a 83       	std	Y+2, r16	; 0x02
			p_UCR = &UCSR1B;
    250c:	e9 ec       	ldi	r30, 0xC9	; 201
    250e:	f0 e0       	ldi	r31, 0x00	; 0
    2510:	fd 83       	std	Y+5, r31	; 0x05
    2512:	ec 83       	std	Y+4, r30	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    2514:	88 e1       	ldi	r24, 0x18	; 24
    2516:	80 83       	st	Z, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    2518:	86 e0       	ldi	r24, 0x06	; 6
    251a:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    251e:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    2522:	cb 01       	movw	r24, r22
    2524:	a0 e0       	ldi	r26, 0x00	; 0
    2526:	b0 e0       	ldi	r27, 0x00	; 0
    2528:	88 0f       	add	r24, r24
    252a:	99 1f       	adc	r25, r25
    252c:	aa 1f       	adc	r26, r26
    252e:	bb 1f       	adc	r27, r27
    2530:	88 0f       	add	r24, r24
    2532:	99 1f       	adc	r25, r25
    2534:	aa 1f       	adc	r26, r26
    2536:	bb 1f       	adc	r27, r27
    2538:	9c 01       	movw	r18, r24
    253a:	ad 01       	movw	r20, r26
    253c:	22 0f       	add	r18, r18
    253e:	33 1f       	adc	r19, r19
    2540:	44 1f       	adc	r20, r20
    2542:	55 1f       	adc	r21, r21
    2544:	22 0f       	add	r18, r18
    2546:	33 1f       	adc	r19, r19
    2548:	44 1f       	adc	r20, r20
    254a:	55 1f       	adc	r21, r21
    254c:	60 e0       	ldi	r22, 0x00	; 0
    254e:	74 e2       	ldi	r23, 0x24	; 36
    2550:	84 ef       	ldi	r24, 0xF4	; 244
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	88 d6       	rcall	.+3344   	; 0x3266 <__udivmodsi4>
    2556:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    255a:	f8 01       	movw	r30, r16
    255c:	80 81       	ld	r24, Z
    255e:	81 60       	ori	r24, 0x01	; 1
    2560:	80 83       	st	Z, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    2562:	80 e2       	ldi	r24, 0x20	; 32
    2564:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    2566:	80 e8       	ldi	r24, 0x80	; 128
    2568:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    256a:	80 e4       	ldi	r24, 0x40	; 64
    256c:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    256e:	e8 81       	ld	r30, Y
    2570:	f9 81       	ldd	r31, Y+1	; 0x01
    2572:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    2574:	80 81       	ld	r24, Z
}
    2576:	df 91       	pop	r29
    2578:	cf 91       	pop	r28
    257a:	1f 91       	pop	r17
    257c:	0f 91       	pop	r16
    257e:	08 95       	ret

00002580 <_ZN8emstream13ready_to_sendEv>:
		bts_new_base = new_base;
		return (manip_set_base);
	}

	return (manip_set_base);
}
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	08 95       	ret

00002584 <_ZN8emstream7getcharEv>:
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	08 95       	ret

00002588 <_ZN8emstream14check_for_charEv>:
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	08 95       	ret

0000258c <_ZN8emstream12transmit_nowEv>:
    258c:	08 95       	ret

0000258e <_ZN8emstream12clear_screenEv>:
    258e:	dc 01       	movw	r26, r24
    2590:	ed 91       	ld	r30, X+
    2592:	fc 91       	ld	r31, X
    2594:	02 80       	ldd	r0, Z+2	; 0x02
    2596:	f3 81       	ldd	r31, Z+3	; 0x03
    2598:	e0 2d       	mov	r30, r0
    259a:	6c e0       	ldi	r22, 0x0C	; 12
    259c:	09 95       	icall
    259e:	08 95       	ret

000025a0 <_ZN8emstreamC1Ev>:
    25a0:	fc 01       	movw	r30, r24
    25a2:	8e e3       	ldi	r24, 0x3E	; 62
    25a4:	92 e0       	ldi	r25, 0x02	; 2
    25a6:	91 83       	std	Z+1, r25	; 0x01
    25a8:	80 83       	st	Z, r24
    25aa:	8a e0       	ldi	r24, 0x0A	; 10
    25ac:	82 83       	std	Z+2, r24	; 0x02
    25ae:	83 e0       	ldi	r24, 0x03	; 3
    25b0:	85 83       	std	Z+5, r24	; 0x05
    25b2:	14 82       	std	Z+4, r1	; 0x04
    25b4:	08 95       	ret

000025b6 <_ZN8emstream4putsEPKc>:
    25b6:	0f 93       	push	r16
    25b8:	1f 93       	push	r17
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
    25be:	8c 01       	movw	r16, r24
    25c0:	fb 01       	movw	r30, r22
    25c2:	dc 01       	movw	r26, r24
    25c4:	14 96       	adiw	r26, 0x04	; 4
    25c6:	8c 91       	ld	r24, X
    25c8:	81 11       	cpse	r24, r1
    25ca:	04 c0       	rjmp	.+8      	; 0x25d4 <_ZN8emstream4putsEPKc+0x1e>
    25cc:	60 81       	ld	r22, Z
    25ce:	61 11       	cpse	r22, r1
    25d0:	17 c0       	rjmp	.+46     	; 0x2600 <_ZN8emstream4putsEPKc+0x4a>
    25d2:	23 c0       	rjmp	.+70     	; 0x261a <_ZN8emstream4putsEPKc+0x64>
    25d4:	d8 01       	movw	r26, r16
    25d6:	14 96       	adiw	r26, 0x04	; 4
    25d8:	1c 92       	st	X, r1
    25da:	eb 01       	movw	r28, r22
    25dc:	21 96       	adiw	r28, 0x01	; 1
    25de:	64 91       	lpm	r22, Z
    25e0:	66 23       	and	r22, r22
    25e2:	d9 f0       	breq	.+54     	; 0x261a <_ZN8emstream4putsEPKc+0x64>
    25e4:	d8 01       	movw	r26, r16
    25e6:	ed 91       	ld	r30, X+
    25e8:	fc 91       	ld	r31, X
    25ea:	02 80       	ldd	r0, Z+2	; 0x02
    25ec:	f3 81       	ldd	r31, Z+3	; 0x03
    25ee:	e0 2d       	mov	r30, r0
    25f0:	c8 01       	movw	r24, r16
    25f2:	09 95       	icall
    25f4:	fe 01       	movw	r30, r28
    25f6:	64 91       	lpm	r22, Z
    25f8:	21 96       	adiw	r28, 0x01	; 1
    25fa:	61 11       	cpse	r22, r1
    25fc:	f3 cf       	rjmp	.-26     	; 0x25e4 <_ZN8emstream4putsEPKc+0x2e>
    25fe:	0d c0       	rjmp	.+26     	; 0x261a <_ZN8emstream4putsEPKc+0x64>
    2600:	ef 01       	movw	r28, r30
    2602:	21 96       	adiw	r28, 0x01	; 1
    2604:	d8 01       	movw	r26, r16
    2606:	ed 91       	ld	r30, X+
    2608:	fc 91       	ld	r31, X
    260a:	02 80       	ldd	r0, Z+2	; 0x02
    260c:	f3 81       	ldd	r31, Z+3	; 0x03
    260e:	e0 2d       	mov	r30, r0
    2610:	c8 01       	movw	r24, r16
    2612:	09 95       	icall
    2614:	69 91       	ld	r22, Y+
    2616:	61 11       	cpse	r22, r1
    2618:	f5 cf       	rjmp	.-22     	; 0x2604 <_ZN8emstream4putsEPKc+0x4e>
    261a:	df 91       	pop	r29
    261c:	cf 91       	pop	r28
    261e:	1f 91       	pop	r17
    2620:	0f 91       	pop	r16
    2622:	08 95       	ret

00002624 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return  A reference to the serial device to which the data was printed. This
 *           reference is used to string printable items together with @c << operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2624:	cf 93       	push	r28
    2626:	df 93       	push	r29
    2628:	ec 01       	movw	r28, r24
	switch (new_manip)
    262a:	46 2f       	mov	r20, r22
    262c:	50 e0       	ldi	r21, 0x00	; 0
    262e:	4c 30       	cpi	r20, 0x0C	; 12
    2630:	51 05       	cpc	r21, r1
    2632:	c0 f5       	brcc	.+112    	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
    2634:	fa 01       	movw	r30, r20
    2636:	ea 59       	subi	r30, 0x9A	; 154
    2638:	ff 4f       	sbci	r31, 0xFF	; 255
    263a:	53 c6       	rjmp	.+3238   	; 0x32e2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    263c:	82 e0       	ldi	r24, 0x02	; 2
    263e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2640:	31 c0       	rjmp	.+98     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (oct):                         // Print integers in octal
			base = 8;
    2642:	88 e0       	ldi	r24, 0x08	; 8
    2644:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2646:	2e c0       	rjmp	.+92     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (dec):                         // Print integers in decimal
			base = 10;
    2648:	8a e0       	ldi	r24, 0x0A	; 10
    264a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    264c:	2b c0       	rjmp	.+86     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    264e:	80 e1       	ldi	r24, 0x10	; 16
    2650:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2652:	28 c0       	rjmp	.+80     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2654:	e8 81       	ld	r30, Y
    2656:	f9 81       	ldd	r31, Y+1	; 0x01
    2658:	02 80       	ldd	r0, Z+2	; 0x02
    265a:	f3 81       	ldd	r31, Z+3	; 0x03
    265c:	e0 2d       	mov	r30, r0
    265e:	6d e0       	ldi	r22, 0x0D	; 13
    2660:	09 95       	icall
    2662:	e8 81       	ld	r30, Y
    2664:	f9 81       	ldd	r31, Y+1	; 0x01
    2666:	02 80       	ldd	r0, Z+2	; 0x02
    2668:	f3 81       	ldd	r31, Z+3	; 0x03
    266a:	e0 2d       	mov	r30, r0
    266c:	6a e0       	ldi	r22, 0x0A	; 10
    266e:	ce 01       	movw	r24, r28
    2670:	09 95       	icall
			break;
    2672:	18 c0       	rjmp	.+48     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2674:	e8 81       	ld	r30, Y
    2676:	f9 81       	ldd	r31, Y+1	; 0x01
    2678:	02 84       	ldd	r0, Z+10	; 0x0a
    267a:	f3 85       	ldd	r31, Z+11	; 0x0b
    267c:	e0 2d       	mov	r30, r0
    267e:	09 95       	icall
			break;
    2680:	11 c0       	rjmp	.+34     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2682:	e8 81       	ld	r30, Y
    2684:	f9 81       	ldd	r31, Y+1	; 0x01
    2686:	00 84       	ldd	r0, Z+8	; 0x08
    2688:	f1 85       	ldd	r31, Z+9	; 0x09
    268a:	e0 2d       	mov	r30, r0
    268c:	09 95       	icall
			break;
    268e:	0a c0       	rjmp	.+20     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		#ifdef __AVR
			case (_p_str):                  // The next string is in program memory
				pgm_string = true;
    2690:	81 e0       	ldi	r24, 0x01	; 1
    2692:	8c 83       	std	Y+4, r24	; 0x04
				break;
    2694:	07 c0       	rjmp	.+14     	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		#endif
		case (manip_set_precision):         // Set precision for printing floats
			precision = bts_new_prec;
    2696:	80 91 07 02 	lds	r24, 0x0207
    269a:	8d 83       	std	Y+5, r24	; 0x05
			break;
    269c:	03 c0       	rjmp	.+6      	; 0x26a4 <_ZN8emstreamlsE15ser_manipulator+0x80>
		case (manip_set_base):              // Set numeric base to a number 2 to 16
			base = bts_new_base;
    269e:	80 91 06 02 	lds	r24, 0x0206
    26a2:	8a 83       	std	Y+2, r24	; 0x02
		default:                            // Not recognized?  Do nothing then
			break;
	};

	return (*this);
}
    26a4:	ce 01       	movw	r24, r28
    26a6:	df 91       	pop	r29
    26a8:	cf 91       	pop	r28
    26aa:	08 95       	ret

000026ac <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    26ac:	ff 92       	push	r15
    26ae:	0f 93       	push	r16
    26b0:	1f 93       	push	r17
    26b2:	cf 93       	push	r28
    26b4:	df 93       	push	r29
    26b6:	cd b7       	in	r28, 0x3d	; 61
    26b8:	de b7       	in	r29, 0x3e	; 62
    26ba:	61 97       	sbiw	r28, 0x11	; 17
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	de bf       	out	0x3e, r29	; 62
    26c2:	0f be       	out	0x3f, r0	; 63
    26c4:	cd bf       	out	0x3d, r28	; 61
    26c6:	8c 01       	movw	r16, r24
    26c8:	f6 2e       	mov	r15, r22
    26ca:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    26cc:	f8 01       	movw	r30, r16
    26ce:	42 81       	ldd	r20, Z+2	; 0x02
    26d0:	40 31       	cpi	r20, 0x10	; 16
    26d2:	21 f0       	breq	.+8      	; 0x26dc <_ZN8emstreamlsEj+0x30>
    26d4:	48 30       	cpi	r20, 0x08	; 8
    26d6:	11 f0       	breq	.+4      	; 0x26dc <_ZN8emstreamlsEj+0x30>
    26d8:	42 30       	cpi	r20, 0x02	; 2
    26da:	31 f4       	brne	.+12     	; 0x26e8 <_ZN8emstreamlsEj+0x3c>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    26dc:	69 2f       	mov	r22, r25
    26de:	c8 01       	movw	r24, r16
    26e0:	5d d0       	rcall	.+186    	; 0x279c <_ZN8emstreamlsEh>
    26e2:	6f 2d       	mov	r22, r15
    26e4:	5b d0       	rcall	.+182    	; 0x279c <_ZN8emstreamlsEh>
    26e6:	0b c0       	rjmp	.+22     	; 0x26fe <_ZN8emstreamlsEj+0x52>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
    26e8:	50 e0       	ldi	r21, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    26ea:	be 01       	movw	r22, r28
    26ec:	6f 5f       	subi	r22, 0xFF	; 255
    26ee:	7f 4f       	sbci	r23, 0xFF	; 255
    26f0:	8f 2d       	mov	r24, r15
    26f2:	77 d6       	rcall	.+3310   	; 0x33e2 <utoa>
		puts (out_str);
    26f4:	be 01       	movw	r22, r28
    26f6:	6f 5f       	subi	r22, 0xFF	; 255
    26f8:	7f 4f       	sbci	r23, 0xFF	; 255
    26fa:	c8 01       	movw	r24, r16
    26fc:	5c df       	rcall	.-328    	; 0x25b6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    26fe:	c8 01       	movw	r24, r16
    2700:	61 96       	adiw	r28, 0x11	; 17
    2702:	0f b6       	in	r0, 0x3f	; 63
    2704:	f8 94       	cli
    2706:	de bf       	out	0x3e, r29	; 62
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	cd bf       	out	0x3d, r28	; 61
    270c:	df 91       	pop	r29
    270e:	cf 91       	pop	r28
    2710:	1f 91       	pop	r17
    2712:	0f 91       	pop	r16
    2714:	ff 90       	pop	r15
    2716:	08 95       	ret

00002718 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    2718:	df 92       	push	r13
    271a:	ef 92       	push	r14
    271c:	ff 92       	push	r15
    271e:	0f 93       	push	r16
    2720:	1f 93       	push	r17
    2722:	cf 93       	push	r28
    2724:	df 93       	push	r29
    2726:	cd b7       	in	r28, 0x3d	; 61
    2728:	de b7       	in	r29, 0x3e	; 62
    272a:	a1 97       	sbiw	r28, 0x21	; 33
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	de bf       	out	0x3e, r29	; 62
    2732:	0f be       	out	0x3f, r0	; 63
    2734:	cd bf       	out	0x3d, r28	; 61
    2736:	8c 01       	movw	r16, r24
    2738:	d4 2e       	mov	r13, r20
    273a:	e5 2e       	mov	r14, r21
    273c:	f6 2e       	mov	r15, r22
    273e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2740:	f8 01       	movw	r30, r16
    2742:	22 81       	ldd	r18, Z+2	; 0x02
    2744:	20 31       	cpi	r18, 0x10	; 16
    2746:	21 f0       	breq	.+8      	; 0x2750 <_ZN8emstreamlsEm+0x38>
    2748:	28 30       	cpi	r18, 0x08	; 8
    274a:	11 f0       	breq	.+4      	; 0x2750 <_ZN8emstreamlsEm+0x38>
    274c:	22 30       	cpi	r18, 0x02	; 2
    274e:	51 f4       	brne	.+20     	; 0x2764 <_ZN8emstreamlsEm+0x4c>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    2750:	69 2f       	mov	r22, r25
    2752:	c8 01       	movw	r24, r16
    2754:	23 d0       	rcall	.+70     	; 0x279c <_ZN8emstreamlsEh>
    2756:	6f 2d       	mov	r22, r15
    2758:	21 d0       	rcall	.+66     	; 0x279c <_ZN8emstreamlsEh>
    275a:	6e 2d       	mov	r22, r14
    275c:	1f d0       	rcall	.+62     	; 0x279c <_ZN8emstreamlsEh>
    275e:	6d 2d       	mov	r22, r13
    2760:	1d d0       	rcall	.+58     	; 0x279c <_ZN8emstreamlsEh>
    2762:	0d c0       	rjmp	.+26     	; 0x277e <_ZN8emstreamlsEm+0x66>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
    2764:	30 e0       	ldi	r19, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    2766:	ae 01       	movw	r20, r28
    2768:	4f 5f       	subi	r20, 0xFF	; 255
    276a:	5f 4f       	sbci	r21, 0xFF	; 255
    276c:	6d 2d       	mov	r22, r13
    276e:	7e 2d       	mov	r23, r14
    2770:	8f 2d       	mov	r24, r15
    2772:	0c d6       	rcall	.+3096   	; 0x338c <ultoa>
		puts (out_str);
    2774:	be 01       	movw	r22, r28
    2776:	6f 5f       	subi	r22, 0xFF	; 255
    2778:	7f 4f       	sbci	r23, 0xFF	; 255
    277a:	c8 01       	movw	r24, r16
    277c:	1c df       	rcall	.-456    	; 0x25b6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    277e:	c8 01       	movw	r24, r16
    2780:	a1 96       	adiw	r28, 0x21	; 33
    2782:	0f b6       	in	r0, 0x3f	; 63
    2784:	f8 94       	cli
    2786:	de bf       	out	0x3e, r29	; 62
    2788:	0f be       	out	0x3f, r0	; 63
    278a:	cd bf       	out	0x3d, r28	; 61
    278c:	df 91       	pop	r29
    278e:	cf 91       	pop	r28
    2790:	1f 91       	pop	r17
    2792:	0f 91       	pop	r16
    2794:	ff 90       	pop	r15
    2796:	ef 90       	pop	r14
    2798:	df 90       	pop	r13
    279a:	08 95       	ret

0000279c <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    279c:	cf 92       	push	r12
    279e:	df 92       	push	r13
    27a0:	ef 92       	push	r14
    27a2:	ff 92       	push	r15
    27a4:	0f 93       	push	r16
    27a6:	1f 93       	push	r17
    27a8:	cf 93       	push	r28
    27aa:	df 93       	push	r29
    27ac:	cd b7       	in	r28, 0x3d	; 61
    27ae:	de b7       	in	r29, 0x3e	; 62
    27b0:	29 97       	sbiw	r28, 0x09	; 9
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	de bf       	out	0x3e, r29	; 62
    27b8:	0f be       	out	0x3f, r0	; 63
    27ba:	cd bf       	out	0x3d, r28	; 61
    27bc:	8c 01       	movw	r16, r24
    27be:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    27c0:	dc 01       	movw	r26, r24
    27c2:	13 96       	adiw	r26, 0x03	; 3
    27c4:	8c 91       	ld	r24, X
    27c6:	13 97       	sbiw	r26, 0x03	; 3
    27c8:	88 23       	and	r24, r24
    27ca:	41 f0       	breq	.+16     	; 0x27dc <_ZN8emstreamlsEh+0x40>
	{
		putchar (num);
    27cc:	ed 91       	ld	r30, X+
    27ce:	fc 91       	ld	r31, X
    27d0:	02 80       	ldd	r0, Z+2	; 0x02
    27d2:	f3 81       	ldd	r31, Z+3	; 0x03
    27d4:	e0 2d       	mov	r30, r0
    27d6:	c8 01       	movw	r24, r16
    27d8:	09 95       	icall
    27da:	54 c0       	rjmp	.+168    	; 0x2884 <_ZN8emstreamlsEh+0xe8>
	}
	else if (base == 2)
    27dc:	f8 01       	movw	r30, r16
    27de:	42 81       	ldd	r20, Z+2	; 0x02
    27e0:	42 30       	cpi	r20, 0x02	; 2
    27e2:	19 f5       	brne	.+70     	; 0x282a <_ZN8emstreamlsEh+0x8e>
    27e4:	68 94       	set
    27e6:	cc 24       	eor	r12, r12
    27e8:	c3 f8       	bld	r12, 3
    27ea:	d1 2c       	mov	r13, r1
    27ec:	68 94       	set
    27ee:	ff 24       	eor	r15, r15
    27f0:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    27f2:	8f 2d       	mov	r24, r15
    27f4:	8e 21       	and	r24, r14
    27f6:	51 f0       	breq	.+20     	; 0x280c <_ZN8emstreamlsEh+0x70>
    27f8:	d8 01       	movw	r26, r16
    27fa:	ed 91       	ld	r30, X+
    27fc:	fc 91       	ld	r31, X
    27fe:	02 80       	ldd	r0, Z+2	; 0x02
    2800:	f3 81       	ldd	r31, Z+3	; 0x03
    2802:	e0 2d       	mov	r30, r0
    2804:	61 e3       	ldi	r22, 0x31	; 49
    2806:	c8 01       	movw	r24, r16
    2808:	09 95       	icall
    280a:	09 c0       	rjmp	.+18     	; 0x281e <_ZN8emstreamlsEh+0x82>
			else             putchar ('0');
    280c:	d8 01       	movw	r26, r16
    280e:	ed 91       	ld	r30, X+
    2810:	fc 91       	ld	r31, X
    2812:	02 80       	ldd	r0, Z+2	; 0x02
    2814:	f3 81       	ldd	r31, Z+3	; 0x03
    2816:	e0 2d       	mov	r30, r0
    2818:	60 e3       	ldi	r22, 0x30	; 48
    281a:	c8 01       	movw	r24, r16
    281c:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    281e:	f6 94       	lsr	r15
    2820:	b1 e0       	ldi	r27, 0x01	; 1
    2822:	cb 1a       	sub	r12, r27
    2824:	d1 08       	sbc	r13, r1
    2826:	29 f7       	brne	.-54     	; 0x27f2 <_ZN8emstreamlsEh+0x56>
    2828:	2d c0       	rjmp	.+90     	; 0x2884 <_ZN8emstreamlsEh+0xe8>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    282a:	40 31       	cpi	r20, 0x10	; 16
    282c:	f9 f4       	brne	.+62     	; 0x286c <_ZN8emstreamlsEh+0xd0>
	{
		temp_char = (num >> 4) & 0x0F;
    282e:	62 95       	swap	r22
    2830:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2832:	01 90       	ld	r0, Z+
    2834:	f0 81       	ld	r31, Z
    2836:	e0 2d       	mov	r30, r0
    2838:	02 80       	ldd	r0, Z+2	; 0x02
    283a:	f3 81       	ldd	r31, Z+3	; 0x03
    283c:	e0 2d       	mov	r30, r0
    283e:	6a 30       	cpi	r22, 0x0A	; 10
    2840:	10 f0       	brcs	.+4      	; 0x2846 <_ZN8emstreamlsEh+0xaa>
    2842:	69 5c       	subi	r22, 0xC9	; 201
    2844:	01 c0       	rjmp	.+2      	; 0x2848 <_ZN8emstreamlsEh+0xac>
    2846:	60 5d       	subi	r22, 0xD0	; 208
    2848:	c8 01       	movw	r24, r16
    284a:	09 95       	icall
		temp_char = num & 0x0F;
    284c:	6e 2d       	mov	r22, r14
    284e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2850:	d8 01       	movw	r26, r16
    2852:	ed 91       	ld	r30, X+
    2854:	fc 91       	ld	r31, X
    2856:	02 80       	ldd	r0, Z+2	; 0x02
    2858:	f3 81       	ldd	r31, Z+3	; 0x03
    285a:	e0 2d       	mov	r30, r0
    285c:	6a 30       	cpi	r22, 0x0A	; 10
    285e:	10 f0       	brcs	.+4      	; 0x2864 <_ZN8emstreamlsEh+0xc8>
    2860:	69 5c       	subi	r22, 0xC9	; 201
    2862:	01 c0       	rjmp	.+2      	; 0x2866 <_ZN8emstreamlsEh+0xca>
    2864:	60 5d       	subi	r22, 0xD0	; 208
    2866:	c8 01       	movw	r24, r16
    2868:	09 95       	icall
    286a:	0c c0       	rjmp	.+24     	; 0x2884 <_ZN8emstreamlsEh+0xe8>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
    286c:	50 e0       	ldi	r21, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    286e:	be 01       	movw	r22, r28
    2870:	6f 5f       	subi	r22, 0xFF	; 255
    2872:	7f 4f       	sbci	r23, 0xFF	; 255
    2874:	8e 2d       	mov	r24, r14
    2876:	90 e0       	ldi	r25, 0x00	; 0
    2878:	b4 d5       	rcall	.+2920   	; 0x33e2 <utoa>
		puts (out_str);
    287a:	be 01       	movw	r22, r28
    287c:	6f 5f       	subi	r22, 0xFF	; 255
    287e:	7f 4f       	sbci	r23, 0xFF	; 255
    2880:	c8 01       	movw	r24, r16
    2882:	99 de       	rcall	.-718    	; 0x25b6 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    2884:	c8 01       	movw	r24, r16
    2886:	29 96       	adiw	r28, 0x09	; 9
    2888:	0f b6       	in	r0, 0x3f	; 63
    288a:	f8 94       	cli
    288c:	de bf       	out	0x3e, r29	; 62
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	cd bf       	out	0x3d, r28	; 61
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	ff 90       	pop	r15
    289c:	ef 90       	pop	r14
    289e:	df 90       	pop	r13
    28a0:	cf 90       	pop	r12
    28a2:	08 95       	ret

000028a4 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

void rs232::putchar (char chout)
{
    28a4:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    28a6:	18 96       	adiw	r26, 0x08	; 8
    28a8:	ed 91       	ld	r30, X+
    28aa:	fc 91       	ld	r31, X
    28ac:	19 97       	sbiw	r26, 0x09	; 9
    28ae:	80 81       	ld	r24, Z
    28b0:	1c 96       	adiw	r26, 0x0c	; 12
    28b2:	4c 91       	ld	r20, X
    28b4:	1c 97       	sbiw	r26, 0x0c	; 12
    28b6:	84 23       	and	r24, r20
    28b8:	29 f0       	breq	.+10     	; 0x28c4 <_ZN5rs2327putcharEc+0x20>
    28ba:	09 c0       	rjmp	.+18     	; 0x28ce <_ZN5rs2327putcharEc+0x2a>
    28bc:	21 50       	subi	r18, 0x01	; 1
    28be:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    28c0:	19 f4       	brne	.+6      	; 0x28c8 <_ZN5rs2327putcharEc+0x24>
    28c2:	08 95       	ret
 */

void rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    28c4:	21 e2       	ldi	r18, 0x21	; 33
    28c6:	3e e4       	ldi	r19, 0x4E	; 78
    28c8:	90 81       	ld	r25, Z
    28ca:	94 23       	and	r25, r20
    28cc:	b9 f3       	breq	.-18     	; 0x28bc <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    28ce:	90 81       	ld	r25, Z
    28d0:	1e 96       	adiw	r26, 0x0e	; 14
    28d2:	8c 91       	ld	r24, X
    28d4:	1e 97       	sbiw	r26, 0x0e	; 14
    28d6:	89 2b       	or	r24, r25
    28d8:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    28da:	16 96       	adiw	r26, 0x06	; 6
    28dc:	ed 91       	ld	r30, X+
    28de:	fc 91       	ld	r31, X
    28e0:	17 97       	sbiw	r26, 0x07	; 7
    28e2:	60 83       	st	Z, r22
    28e4:	08 95       	ret

000028e6 <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
    28e6:	fc 01       	movw	r30, r24
    28e8:	87 85       	ldd	r24, Z+15	; 0x0f
    28ea:	81 11       	cpse	r24, r1
    28ec:	21 c0       	rjmp	.+66     	; 0x2930 <_ZN5rs2327getcharEv+0x4a>
		{
			while (rcv0_read_index == rcv0_write_index);
    28ee:	20 91 36 1a 	lds	r18, 0x1A36
    28f2:	30 91 37 1a 	lds	r19, 0x1A37
    28f6:	80 91 34 1a 	lds	r24, 0x1A34
    28fa:	90 91 35 1a 	lds	r25, 0x1A35
    28fe:	28 17       	cp	r18, r24
    2900:	39 07       	cpc	r19, r25
    2902:	e9 f3       	breq	.-6      	; 0x28fe <_ZN5rs2327getcharEv+0x18>
			recv_char = rcv0_buffer[rcv0_read_index];
    2904:	e0 91 38 1a 	lds	r30, 0x1A38
    2908:	f0 91 39 1a 	lds	r31, 0x1A39
    290c:	e2 0f       	add	r30, r18
    290e:	f3 1f       	adc	r31, r19
    2910:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
    2912:	2f 5f       	subi	r18, 0xFF	; 255
    2914:	3f 4f       	sbci	r19, 0xFF	; 255
    2916:	20 32       	cpi	r18, 0x20	; 32
    2918:	31 05       	cpc	r19, r1
    291a:	28 f4       	brcc	.+10     	; 0x2926 <_ZN5rs2327getcharEv+0x40>
    291c:	30 93 37 1a 	sts	0x1A37, r19
    2920:	20 93 36 1a 	sts	0x1A36, r18
    2924:	08 95       	ret
				rcv0_read_index = 0;
    2926:	10 92 37 1a 	sts	0x1A37, r1
    292a:	10 92 36 1a 	sts	0x1A36, r1
    292e:	08 95       	ret
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
    2930:	20 91 30 1a 	lds	r18, 0x1A30
    2934:	30 91 31 1a 	lds	r19, 0x1A31
    2938:	80 91 2e 1a 	lds	r24, 0x1A2E
    293c:	90 91 2f 1a 	lds	r25, 0x1A2F
    2940:	28 17       	cp	r18, r24
    2942:	39 07       	cpc	r19, r25
    2944:	e9 f3       	breq	.-6      	; 0x2940 <_ZN5rs2327getcharEv+0x5a>
			recv_char = rcv1_buffer[rcv1_read_index];
    2946:	e0 91 32 1a 	lds	r30, 0x1A32
    294a:	f0 91 33 1a 	lds	r31, 0x1A33
    294e:	e2 0f       	add	r30, r18
    2950:	f3 1f       	adc	r31, r19
    2952:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2954:	2f 5f       	subi	r18, 0xFF	; 255
    2956:	3f 4f       	sbci	r19, 0xFF	; 255
    2958:	20 32       	cpi	r18, 0x20	; 32
    295a:	31 05       	cpc	r19, r1
    295c:	28 f4       	brcc	.+10     	; 0x2968 <_ZN5rs2327getcharEv+0x82>
    295e:	30 93 31 1a 	sts	0x1A31, r19
    2962:	20 93 30 1a 	sts	0x1A30, r18
    2966:	08 95       	ret
				rcv1_read_index = 0;
    2968:	10 92 31 1a 	sts	0x1A31, r1
    296c:	10 92 30 1a 	sts	0x1A30, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
    2970:	08 95       	ret

00002972 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
    2972:	fc 01       	movw	r30, r24
    2974:	87 85       	ldd	r24, Z+15	; 0x0f
    2976:	81 11       	cpse	r24, r1
    2978:	0e c0       	rjmp	.+28     	; 0x2996 <_ZN5rs23214check_for_charEv+0x24>
			return (rcv0_read_index != rcv0_write_index);
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	40 91 36 1a 	lds	r20, 0x1A36
    2980:	50 91 37 1a 	lds	r21, 0x1A37
    2984:	20 91 34 1a 	lds	r18, 0x1A34
    2988:	30 91 35 1a 	lds	r19, 0x1A35
    298c:	42 17       	cp	r20, r18
    298e:	53 07       	cpc	r21, r19
    2990:	79 f4       	brne	.+30     	; 0x29b0 <_ZN5rs23214check_for_charEv+0x3e>
    2992:	80 e0       	ldi	r24, 0x00	; 0
    2994:	08 95       	ret
		else
			return (rcv1_read_index != rcv1_write_index);
    2996:	81 e0       	ldi	r24, 0x01	; 1
    2998:	40 91 30 1a 	lds	r20, 0x1A30
    299c:	50 91 31 1a 	lds	r21, 0x1A31
    29a0:	20 91 2e 1a 	lds	r18, 0x1A2E
    29a4:	30 91 2f 1a 	lds	r19, 0x1A2F
    29a8:	42 17       	cp	r20, r18
    29aa:	53 07       	cpc	r21, r19
    29ac:	09 f4       	brne	.+2      	; 0x29b0 <_ZN5rs23214check_for_charEv+0x3e>
    29ae:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
    29b0:	08 95       	ret

000029b2 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    29b2:	dc 01       	movw	r26, r24
    29b4:	ed 91       	ld	r30, X+
    29b6:	fc 91       	ld	r31, X
    29b8:	02 80       	ldd	r0, Z+2	; 0x02
    29ba:	f3 81       	ldd	r31, Z+3	; 0x03
    29bc:	e0 2d       	mov	r30, r0
    29be:	6c e0       	ldi	r22, 0x0C	; 12
    29c0:	09 95       	icall
    29c2:	08 95       	ret

000029c4 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
    29c4:	ef 92       	push	r14
    29c6:	ff 92       	push	r15
    29c8:	1f 93       	push	r17
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	ec 01       	movw	r28, r24
    29d0:	7b 01       	movw	r14, r22
    29d2:	14 2f       	mov	r17, r20
	: emstream (), base232 (baud_rate, port_number)
    29d4:	e5 dd       	rcall	.-1078   	; 0x25a0 <_ZN8emstreamC1Ev>
    29d6:	41 2f       	mov	r20, r17
    29d8:	b7 01       	movw	r22, r14
    29da:	ce 01       	movw	r24, r28
    29dc:	06 96       	adiw	r24, 0x06	; 6
    29de:	4d dd       	rcall	.-1382   	; 0x247a <_ZN7base232C1Ejh>
    29e0:	8e e4       	ldi	r24, 0x4E	; 78
    29e2:	92 e0       	ldi	r25, 0x02	; 2
    29e4:	99 83       	std	Y+1, r25	; 0x01
    29e6:	88 83       	st	Y, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
    29e8:	1f 87       	std	Y+15, r17	; 0x0f

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
    29ea:	11 11       	cpse	r17, r1
    29ec:	15 c0       	rjmp	.+42     	; 0x2a18 <_ZN5rs232C1Ejh+0x54>
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
    29ee:	e1 ec       	ldi	r30, 0xC1	; 193
    29f0:	f0 e0       	ldi	r31, 0x00	; 0
    29f2:	80 81       	ld	r24, Z
    29f4:	80 68       	ori	r24, 0x80	; 128
    29f6:	80 83       	st	Z, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
    29f8:	80 e2       	ldi	r24, 0x20	; 32
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	3a dd       	rcall	.-1420   	; 0x2472 <_Znaj>
    29fe:	90 93 39 1a 	sts	0x1A39, r25
    2a02:	80 93 38 1a 	sts	0x1A38, r24
			rcv0_read_index = 0;
    2a06:	10 92 37 1a 	sts	0x1A37, r1
    2a0a:	10 92 36 1a 	sts	0x1A36, r1
			rcv0_write_index = 0;
    2a0e:	10 92 35 1a 	sts	0x1A35, r1
    2a12:	10 92 34 1a 	sts	0x1A34, r1
    2a16:	14 c0       	rjmp	.+40     	; 0x2a40 <_ZN5rs232C1Ejh+0x7c>
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
    2a18:	e9 ec       	ldi	r30, 0xC9	; 201
    2a1a:	f0 e0       	ldi	r31, 0x00	; 0
    2a1c:	80 81       	ld	r24, Z
    2a1e:	80 68       	ori	r24, 0x80	; 128
    2a20:	80 83       	st	Z, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
    2a22:	80 e2       	ldi	r24, 0x20	; 32
    2a24:	90 e0       	ldi	r25, 0x00	; 0
    2a26:	25 dd       	rcall	.-1462   	; 0x2472 <_Znaj>
    2a28:	90 93 33 1a 	sts	0x1A33, r25
    2a2c:	80 93 32 1a 	sts	0x1A32, r24
			rcv1_read_index = 0;
    2a30:	10 92 31 1a 	sts	0x1A31, r1
    2a34:	10 92 30 1a 	sts	0x1A30, r1
			rcv1_write_index = 0;
    2a38:	10 92 2f 1a 	sts	0x1A2F, r1
    2a3c:	10 92 2e 1a 	sts	0x1A2E, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    2a40:	df 91       	pop	r29
    2a42:	cf 91       	pop	r28
    2a44:	1f 91       	pop	r17
    2a46:	ff 90       	pop	r15
    2a48:	ef 90       	pop	r14
    2a4a:	08 95       	ret

00002a4c <__vector_25>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
    2a4c:	1f 92       	push	r1
    2a4e:	0f 92       	push	r0
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	0f 92       	push	r0
    2a54:	11 24       	eor	r1, r1
    2a56:	0b b6       	in	r0, 0x3b	; 59
    2a58:	0f 92       	push	r0
    2a5a:	2f 93       	push	r18
    2a5c:	3f 93       	push	r19
    2a5e:	8f 93       	push	r24
    2a60:	9f 93       	push	r25
    2a62:	ef 93       	push	r30
    2a64:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
    2a66:	20 91 c6 00 	lds	r18, 0x00C6
    2a6a:	e0 91 38 1a 	lds	r30, 0x1A38
    2a6e:	f0 91 39 1a 	lds	r31, 0x1A39
    2a72:	80 91 34 1a 	lds	r24, 0x1A34
    2a76:	90 91 35 1a 	lds	r25, 0x1A35
    2a7a:	e8 0f       	add	r30, r24
    2a7c:	f9 1f       	adc	r31, r25
    2a7e:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
    2a80:	80 91 34 1a 	lds	r24, 0x1A34
    2a84:	90 91 35 1a 	lds	r25, 0x1A35
    2a88:	01 96       	adiw	r24, 0x01	; 1
    2a8a:	80 32       	cpi	r24, 0x20	; 32
    2a8c:	91 05       	cpc	r25, r1
    2a8e:	60 f4       	brcc	.+24     	; 0x2aa8 <__vector_25+0x5c>
    2a90:	90 93 35 1a 	sts	0x1A35, r25
    2a94:	80 93 34 1a 	sts	0x1A34, r24
		rcv0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    2a98:	20 91 36 1a 	lds	r18, 0x1A36
    2a9c:	30 91 37 1a 	lds	r19, 0x1A37
    2aa0:	82 17       	cp	r24, r18
    2aa2:	93 07       	cpc	r25, r19
    2aa4:	f1 f4       	brne	.+60     	; 0x2ae2 <__vector_25+0x96>
    2aa6:	0c c0       	rjmp	.+24     	; 0x2ac0 <__vector_25+0x74>
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
		rcv0_write_index = 0;
    2aa8:	10 92 35 1a 	sts	0x1A35, r1
    2aac:	10 92 34 1a 	sts	0x1A34, r1

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    2ab0:	80 91 36 1a 	lds	r24, 0x1A36
    2ab4:	90 91 37 1a 	lds	r25, 0x1A37
    2ab8:	18 16       	cp	r1, r24
    2aba:	19 06       	cpc	r1, r25
    2abc:	91 f4       	brne	.+36     	; 0x2ae2 <__vector_25+0x96>
    2abe:	0e c0       	rjmp	.+28     	; 0x2adc <__vector_25+0x90>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    2ac0:	01 96       	adiw	r24, 0x01	; 1
    2ac2:	80 32       	cpi	r24, 0x20	; 32
    2ac4:	91 05       	cpc	r25, r1
    2ac6:	28 f4       	brcc	.+10     	; 0x2ad2 <__vector_25+0x86>
    2ac8:	90 93 37 1a 	sts	0x1A37, r25
    2acc:	80 93 36 1a 	sts	0x1A36, r24
    2ad0:	08 c0       	rjmp	.+16     	; 0x2ae2 <__vector_25+0x96>
			rcv0_read_index = 0;
    2ad2:	10 92 37 1a 	sts	0x1A37, r1
    2ad6:	10 92 36 1a 	sts	0x1A36, r1
    2ada:	03 c0       	rjmp	.+6      	; 0x2ae2 <__vector_25+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    2adc:	81 e0       	ldi	r24, 0x01	; 1
    2ade:	90 e0       	ldi	r25, 0x00	; 0
    2ae0:	f3 cf       	rjmp	.-26     	; 0x2ac8 <__vector_25+0x7c>
			rcv0_read_index = 0;
}
    2ae2:	ff 91       	pop	r31
    2ae4:	ef 91       	pop	r30
    2ae6:	9f 91       	pop	r25
    2ae8:	8f 91       	pop	r24
    2aea:	3f 91       	pop	r19
    2aec:	2f 91       	pop	r18
    2aee:	0f 90       	pop	r0
    2af0:	0b be       	out	0x3b, r0	; 59
    2af2:	0f 90       	pop	r0
    2af4:	0f be       	out	0x3f, r0	; 63
    2af6:	0f 90       	pop	r0
    2af8:	1f 90       	pop	r1
    2afa:	18 95       	reti

00002afc <__vector_36>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
    2afc:	1f 92       	push	r1
    2afe:	0f 92       	push	r0
    2b00:	0f b6       	in	r0, 0x3f	; 63
    2b02:	0f 92       	push	r0
    2b04:	11 24       	eor	r1, r1
    2b06:	0b b6       	in	r0, 0x3b	; 59
    2b08:	0f 92       	push	r0
    2b0a:	2f 93       	push	r18
    2b0c:	3f 93       	push	r19
    2b0e:	8f 93       	push	r24
    2b10:	9f 93       	push	r25
    2b12:	ef 93       	push	r30
    2b14:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    2b16:	20 91 ce 00 	lds	r18, 0x00CE
    2b1a:	e0 91 32 1a 	lds	r30, 0x1A32
    2b1e:	f0 91 33 1a 	lds	r31, 0x1A33
    2b22:	80 91 2e 1a 	lds	r24, 0x1A2E
    2b26:	90 91 2f 1a 	lds	r25, 0x1A2F
    2b2a:	e8 0f       	add	r30, r24
    2b2c:	f9 1f       	adc	r31, r25
    2b2e:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    2b30:	80 91 2e 1a 	lds	r24, 0x1A2E
    2b34:	90 91 2f 1a 	lds	r25, 0x1A2F
    2b38:	01 96       	adiw	r24, 0x01	; 1
    2b3a:	80 32       	cpi	r24, 0x20	; 32
    2b3c:	91 05       	cpc	r25, r1
    2b3e:	60 f4       	brcc	.+24     	; 0x2b58 <__vector_36+0x5c>
    2b40:	90 93 2f 1a 	sts	0x1A2F, r25
    2b44:	80 93 2e 1a 	sts	0x1A2E, r24
			rcv1_write_index = 0;

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    2b48:	20 91 30 1a 	lds	r18, 0x1A30
    2b4c:	30 91 31 1a 	lds	r19, 0x1A31
    2b50:	82 17       	cp	r24, r18
    2b52:	93 07       	cpc	r25, r19
    2b54:	f1 f4       	brne	.+60     	; 0x2b92 <__vector_36+0x96>
    2b56:	0c c0       	rjmp	.+24     	; 0x2b70 <__vector_36+0x74>
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
			rcv1_write_index = 0;
    2b58:	10 92 2f 1a 	sts	0x1A2F, r1
    2b5c:	10 92 2e 1a 	sts	0x1A2E, r1

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    2b60:	80 91 30 1a 	lds	r24, 0x1A30
    2b64:	90 91 31 1a 	lds	r25, 0x1A31
    2b68:	18 16       	cp	r1, r24
    2b6a:	19 06       	cpc	r1, r25
    2b6c:	91 f4       	brne	.+36     	; 0x2b92 <__vector_36+0x96>
    2b6e:	0e c0       	rjmp	.+28     	; 0x2b8c <__vector_36+0x90>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2b70:	01 96       	adiw	r24, 0x01	; 1
    2b72:	80 32       	cpi	r24, 0x20	; 32
    2b74:	91 05       	cpc	r25, r1
    2b76:	28 f4       	brcc	.+10     	; 0x2b82 <__vector_36+0x86>
    2b78:	90 93 31 1a 	sts	0x1A31, r25
    2b7c:	80 93 30 1a 	sts	0x1A30, r24
    2b80:	08 c0       	rjmp	.+16     	; 0x2b92 <__vector_36+0x96>
				rcv1_read_index = 0;
    2b82:	10 92 31 1a 	sts	0x1A31, r1
    2b86:	10 92 30 1a 	sts	0x1A30, r1
    2b8a:	03 c0       	rjmp	.+6      	; 0x2b92 <__vector_36+0x96>

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    2b8c:	81 e0       	ldi	r24, 0x01	; 1
    2b8e:	90 e0       	ldi	r25, 0x00	; 0
    2b90:	f3 cf       	rjmp	.-26     	; 0x2b78 <__vector_36+0x7c>
				rcv1_read_index = 0;
	}
    2b92:	ff 91       	pop	r31
    2b94:	ef 91       	pop	r30
    2b96:	9f 91       	pop	r25
    2b98:	8f 91       	pop	r24
    2b9a:	3f 91       	pop	r19
    2b9c:	2f 91       	pop	r18
    2b9e:	0f 90       	pop	r0
    2ba0:	0b be       	out	0x3b, r0	; 59
    2ba2:	0f 90       	pop	r0
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	0f 90       	pop	r0
    2ba8:	1f 90       	pop	r1
    2baa:	18 95       	reti

00002bac <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    2bac:	cf 92       	push	r12
    2bae:	df 92       	push	r13
    2bb0:	ef 92       	push	r14
    2bb2:	ff 92       	push	r15
    2bb4:	0f 93       	push	r16
    2bb6:	1f 93       	push	r17
    2bb8:	cf 93       	push	r28
    2bba:	df 93       	push	r29
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	MCUSR = 0;
    2bbc:	14 be       	out	0x34, r1	; 52
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "n"  (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
    2bbe:	0f b6       	in	r0, 0x3f	; 63
    2bc0:	f8 94       	cli
    2bc2:	a8 95       	wdr
    2bc4:	80 91 60 00 	lds	r24, 0x0060
    2bc8:	88 61       	ori	r24, 0x18	; 24
    2bca:	80 93 60 00 	sts	0x0060, r24
    2bce:	10 92 60 00 	sts	0x0060, r1
    2bd2:	0f be       	out	0x3f, r0	; 63

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232* p_ser_port = new rs232 (9600, 1);
    2bd4:	80 e1       	ldi	r24, 0x10	; 16
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	49 dc       	rcall	.-1902   	; 0x246c <_Znwj>
    2bda:	ec 01       	movw	r28, r24
    2bdc:	41 e0       	ldi	r20, 0x01	; 1
    2bde:	60 e8       	ldi	r22, 0x80	; 128
    2be0:	75 e2       	ldi	r23, 0x25	; 37
    2be2:	f0 de       	rcall	.-544    	; 0x29c4 <_ZN5rs232C1Ejh>
	*p_ser_port << clrscr << PMS ("ME405 Lab 1 Starting Program") << endl;
    2be4:	67 e0       	ldi	r22, 0x07	; 7
    2be6:	ce 01       	movw	r24, r28
    2be8:	1d dd       	rcall	.-1478   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2bea:	6b e0       	ldi	r22, 0x0B	; 11
    2bec:	1b dd       	rcall	.-1482   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2bee:	6c 01       	movw	r12, r24
    2bf0:	64 e0       	ldi	r22, 0x04	; 4
    2bf2:	72 e0       	ldi	r23, 0x02	; 2
    2bf4:	e0 dc       	rcall	.-1600   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2bf6:	66 e0       	ldi	r22, 0x06	; 6
    2bf8:	c6 01       	movw	r24, r12
    2bfa:	14 dd       	rcall	.-1496   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

	// Create the queues and other shared data items here
	p_print_ser_queue = new TextQueue (32, "Print", p_ser_port, 10);
    2bfc:	88 e1       	ldi	r24, 0x18	; 24
    2bfe:	90 e0       	ldi	r25, 0x00	; 0
    2c00:	35 dc       	rcall	.-1942   	; 0x246c <_Znwj>
    2c02:	6c 01       	movw	r12, r24
    2c04:	1a e0       	ldi	r17, 0x0A	; 10
    2c06:	e1 2e       	mov	r14, r17
    2c08:	f1 2c       	mov	r15, r1
    2c0a:	00 e0       	ldi	r16, 0x00	; 0
    2c0c:	10 e0       	ldi	r17, 0x00	; 0
    2c0e:	9e 01       	movw	r18, r28
    2c10:	4a e5       	ldi	r20, 0x5A	; 90
    2c12:	52 e0       	ldi	r21, 0x02	; 2
    2c14:	60 e2       	ldi	r22, 0x20	; 32
    2c16:	70 e0       	ldi	r23, 0x00	; 0
    2c18:	b2 da       	rcall	.-2716   	; 0x217e <_ZN9TextQueueC1EjPKcP8emstreamm>
    2c1a:	d0 92 3b 1a 	sts	0x1A3B, r13
    2c1e:	c0 92 3a 1a 	sts	0x1A3A, r12

	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (1), 260, p_ser_port);
    2c22:	82 e1       	ldi	r24, 0x12	; 18
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	22 dc       	rcall	.-1980   	; 0x246c <_Znwj>
    2c28:	8e 01       	movw	r16, r28
    2c2a:	24 e0       	ldi	r18, 0x04	; 4
    2c2c:	31 e0       	ldi	r19, 0x01	; 1
    2c2e:	41 e0       	ldi	r20, 0x01	; 1
    2c30:	60 e6       	ldi	r22, 0x60	; 96
    2c32:	72 e0       	ldi	r23, 0x02	; 2
    2c34:	6a d0       	rcall	.+212    	; 0x2d0a <_ZN9task_userC1EPKchjP8emstream>

	// Create a task which reads the A/D and adjusts an LED's brightness accordingly
	new task_brightness ("Bright", task_priority (2), 280, p_ser_port);
    2c36:	82 e1       	ldi	r24, 0x12	; 18
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	18 dc       	rcall	.-2000   	; 0x246c <_Znwj>
    2c3c:	28 e1       	ldi	r18, 0x18	; 24
    2c3e:	31 e0       	ldi	r19, 0x01	; 1
    2c40:	42 e0       	ldi	r20, 0x02	; 2
    2c42:	68 e6       	ldi	r22, 0x68	; 104
    2c44:	72 e0       	ldi	r23, 0x02	; 2
    2c46:	51 d0       	rcall	.+162    	; 0x2cea <_ZN15task_brightnessC1EPKchjP8emstream>

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    2c48:	0e 94 42 09 	call	0x1284	; 0x1284 <vTaskStartScheduler>
}
    2c4c:	80 e0       	ldi	r24, 0x00	; 0
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	df 91       	pop	r29
    2c52:	cf 91       	pop	r28
    2c54:	1f 91       	pop	r17
    2c56:	0f 91       	pop	r16
    2c58:	ff 90       	pop	r15
    2c5a:	ef 90       	pop	r14
    2c5c:	df 90       	pop	r13
    2c5e:	cf 90       	pop	r12
    2c60:	08 95       	ret

00002c62 <_ZN15task_brightness3runEv>:
 *  loop, it reads the A/D converter and uses the result to control the brightness of 
 *  an LED. 
 */

void task_brightness::run (void)
{
    2c62:	cf 93       	push	r28
    2c64:	df 93       	push	r29
    2c66:	00 d0       	rcall	.+0      	; 0x2c68 <_ZN15task_brightness3runEv+0x6>
    2c68:	00 d0       	rcall	.+0      	; 0x2c6a <_ZN15task_brightness3runEv+0x8>
    2c6a:	cd b7       	in	r28, 0x3d	; 61
    2c6c:	de b7       	in	r29, 0x3e	; 62
    2c6e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	TickType_t previousTicks = xTaskGetTickCount ();
    2c70:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGetTickCount>
    2c74:	69 83       	std	Y+1, r22	; 0x01
    2c76:	7a 83       	std	Y+2, r23	; 0x02
    2c78:	8b 83       	std	Y+3, r24	; 0x03
    2c7a:	9c 83       	std	Y+4, r25	; 0x04

	// Create an analog to digital converter driver object and a variable in which to
	// store its output. The variable p_my_adc only exists within this run() method,
	// so the A/D converter cannot be used from any other function or method
	adc* p_my_adc = new adc (p_serial);
    2c7c:	82 e0       	ldi	r24, 0x02	; 2
    2c7e:	90 e0       	ldi	r25, 0x00	; 0
    2c80:	f5 db       	rcall	.-2070   	; 0x246c <_Znwj>
    2c82:	7c 01       	movw	r14, r24
    2c84:	f8 01       	movw	r30, r16
    2c86:	66 81       	ldd	r22, Z+6	; 0x06
    2c88:	77 81       	ldd	r23, Z+7	; 0x07
    2c8a:	0e 94 17 02 	call	0x42e	; 0x42e <_ZN3adcC1EP8emstream>

	// Configure counter/timer 3 as a PWM for LED brightness. First set the data
	// direction register so that the pin used for the PWM will be an output. The 
	// pin is Port E pin 4, which is also OC3B (Output Compare B for Timer 3)
	DDRE = (1 << 4);
    2c8e:	80 e1       	ldi	r24, 0x10	; 16
    2c90:	8d b9       	out	0x0d, r24	; 13
	// To set 8-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	TCCR3A = (1 << WGM30)
			 | (1 << COM3B1) | (1 << COM3B0);
    2c92:	81 e3       	ldi	r24, 0x31	; 49
    2c94:	80 93 90 00 	sts	0x0090, r24

	// The CS31 and CS30 bits set the prescaler for this timer/counter to run the
	// timer at F_CPU / 64
	TCCR3B = (1 << WGM32)
			 | (1 << CS31)  | (1 << CS30);
    2c98:	8b e0       	ldi	r24, 0x0B	; 11
    2c9a:	80 93 91 00 	sts	0x0091, r24
		uint16_t duty_cycle = a2d_reading / 4;

		// Set the brightness. Since the PWM has already been set up, we only need to
		// put a new value into the duty cycle control register, which on an AVR is 
		// the output compare register for a given timer/counter
		OCR3B = duty_cycle;
    2c9e:	0f 2e       	mov	r0, r31
    2ca0:	fa e9       	ldi	r31, 0x9A	; 154
    2ca2:	cf 2e       	mov	r12, r31
    2ca4:	d1 2c       	mov	r13, r1
    2ca6:	f0 2d       	mov	r31, r0
	// This is the task loop for the brightness control task. This loop runs until the
	// power is turned off or something equally dramatic occurs
	for (;;)
	{
		// Read the A/D converter
		uint16_t a2d_reading = p_my_adc->read_oversampled (1,6);
    2ca8:	46 e0       	ldi	r20, 0x06	; 6
    2caa:	61 e0       	ldi	r22, 0x01	; 1
    2cac:	c7 01       	movw	r24, r14
    2cae:	0e 94 51 02 	call	0x4a2	; 0x4a2 <_ZN3adc16read_oversampledEhh>

		// Convert the A/D reading into a PWM duty cycle. The A/D reading is between 0
		// and 1023; the duty cycle should be between 0 and 255. Thus, divide by 4
		uint16_t duty_cycle = a2d_reading / 4;
    2cb2:	96 95       	lsr	r25
    2cb4:	87 95       	ror	r24
    2cb6:	96 95       	lsr	r25
    2cb8:	87 95       	ror	r24

		// Set the brightness. Since the PWM has already been set up, we only need to
		// put a new value into the duty cycle control register, which on an AVR is 
		// the output compare register for a given timer/counter
		OCR3B = duty_cycle;
    2cba:	f6 01       	movw	r30, r12
    2cbc:	91 83       	std	Z+1, r25	; 0x01
    2cbe:	80 83       	st	Z, r24

		// Increment the run counter. This counter belongs to the parent class and can
		// be printed out for debugging purposes
		runs++;
    2cc0:	f8 01       	movw	r30, r16
    2cc2:	86 85       	ldd	r24, Z+14	; 0x0e
    2cc4:	97 85       	ldd	r25, Z+15	; 0x0f
    2cc6:	a0 89       	ldd	r26, Z+16	; 0x10
    2cc8:	b1 89       	ldd	r27, Z+17	; 0x11
    2cca:	01 96       	adiw	r24, 0x01	; 1
    2ccc:	a1 1d       	adc	r26, r1
    2cce:	b1 1d       	adc	r27, r1
    2cd0:	86 87       	std	Z+14, r24	; 0x0e
    2cd2:	97 87       	std	Z+15, r25	; 0x0f
    2cd4:	a0 8b       	std	Z+16, r26	; 0x10
    2cd6:	b1 8b       	std	Z+17, r27	; 0x11
         *  @param   millisec The duration of the delay interval in milliseconds
         */
        void delay_from_for_ms (TickType_t& from_ticks, TickType_t millisec)
        {
            TickType_t ticks = ((uint32_t)millisec * configTICK_RATE_HZ) / 1000UL;
            vTaskDelayUntil (&from_ticks, ticks);
    2cd8:	44 e6       	ldi	r20, 0x64	; 100
    2cda:	50 e0       	ldi	r21, 0x00	; 0
    2cdc:	60 e0       	ldi	r22, 0x00	; 0
    2cde:	70 e0       	ldi	r23, 0x00	; 0
    2ce0:	ce 01       	movw	r24, r28
    2ce2:	01 96       	adiw	r24, 0x01	; 1
    2ce4:	0e 94 10 0b 	call	0x1620	; 0x1620 <vTaskDelayUntil>
    2ce8:	df cf       	rjmp	.-66     	; 0x2ca8 <_ZN15task_brightness3runEv+0x46>

00002cea <_ZN15task_brightnessC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_brightness::task_brightness (const char* a_name, 
    2cea:	0f 93       	push	r16
    2cec:	1f 93       	push	r17
    2cee:	cf 93       	push	r28
    2cf0:	df 93       	push	r29
    2cf2:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: TaskBase (a_name, a_priority, a_stack_size, p_ser_dev)
    2cf4:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <_ZN8TaskBaseC1EPKchjP8emstream>
    2cf8:	83 e7       	ldi	r24, 0x73	; 115
    2cfa:	92 e0       	ldi	r25, 0x02	; 2
    2cfc:	99 83       	std	Y+1, r25	; 0x01
    2cfe:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    2d00:	df 91       	pop	r29
    2d02:	cf 91       	pop	r28
    2d04:	1f 91       	pop	r17
    2d06:	0f 91       	pop	r16
    2d08:	08 95       	ret

00002d0a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    2d0a:	0f 93       	push	r16
    2d0c:	1f 93       	push	r17
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: TaskBase (a_name, a_priority, a_stack_size, p_ser_dev)
    2d14:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <_ZN8TaskBaseC1EPKchjP8emstream>
    2d18:	8f e7       	ldi	r24, 0x7F	; 127
    2d1a:	92 e0       	ldi	r25, 0x02	; 2
    2d1c:	99 83       	std	Y+1, r25	; 0x01
    2d1e:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    2d20:	df 91       	pop	r29
    2d22:	cf 91       	pop	r28
    2d24:	1f 91       	pop	r17
    2d26:	0f 91       	pop	r16
    2d28:	08 95       	ret

00002d2a <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    2d2a:	0f 93       	push	r16
    2d2c:	1f 93       	push	r17
    2d2e:	cf 93       	push	r28
    2d30:	df 93       	push	r29
    2d32:	ec 01       	movw	r28, r24
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    2d34:	6b e0       	ldi	r22, 0x0B	; 11
    2d36:	8e 81       	ldd	r24, Y+6	; 0x06
    2d38:	9f 81       	ldd	r25, Y+7	; 0x07
    2d3a:	74 dc       	rcall	.-1816   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2d3c:	8c 01       	movw	r16, r24
    2d3e:	6f e1       	ldi	r22, 0x1F	; 31
    2d40:	73 e0       	ldi	r23, 0x03	; 3
    2d42:	39 dc       	rcall	.-1934   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2d44:	6b e0       	ldi	r22, 0x0B	; 11
    2d46:	c8 01       	movw	r24, r16
    2d48:	6d dc       	rcall	.-1830   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2d4a:	8c 01       	movw	r16, r24
    2d4c:	65 e4       	ldi	r22, 0x45	; 69
    2d4e:	73 e0       	ldi	r23, 0x03	; 3
    2d50:	32 dc       	rcall	.-1948   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2d52:	66 e0       	ldi	r22, 0x06	; 6
    2d54:	c8 01       	movw	r24, r16
    2d56:	66 dc       	rcall	.-1844   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  t:     Show the time right now") << endl;
    2d58:	6b e0       	ldi	r22, 0x0B	; 11
    2d5a:	8e 81       	ldd	r24, Y+6	; 0x06
    2d5c:	9f 81       	ldd	r25, Y+7	; 0x07
    2d5e:	62 dc       	rcall	.-1852   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2d60:	8c 01       	movw	r16, r24
    2d62:	6e ef       	ldi	r22, 0xFE	; 254
    2d64:	72 e0       	ldi	r23, 0x02	; 2
    2d66:	27 dc       	rcall	.-1970   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2d68:	66 e0       	ldi	r22, 0x06	; 6
    2d6a:	c8 01       	movw	r24, r16
    2d6c:	5b dc       	rcall	.-1866   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  s:     Version and setup information") << endl;
    2d6e:	6b e0       	ldi	r22, 0x0B	; 11
    2d70:	8e 81       	ldd	r24, Y+6	; 0x06
    2d72:	9f 81       	ldd	r25, Y+7	; 0x07
    2d74:	57 dc       	rcall	.-1874   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2d76:	8c 01       	movw	r16, r24
    2d78:	67 ed       	ldi	r22, 0xD7	; 215
    2d7a:	72 e0       	ldi	r23, 0x02	; 2
    2d7c:	1c dc       	rcall	.-1992   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2d7e:	66 e0       	ldi	r22, 0x06	; 6
    2d80:	c8 01       	movw	r24, r16
    2d82:	50 dc       	rcall	.-1888   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  d:     Stack dump for tasks") << endl;
    2d84:	6b e0       	ldi	r22, 0x0B	; 11
    2d86:	8e 81       	ldd	r24, Y+6	; 0x06
    2d88:	9f 81       	ldd	r25, Y+7	; 0x07
    2d8a:	4c dc       	rcall	.-1896   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2d8c:	8c 01       	movw	r16, r24
    2d8e:	69 eb       	ldi	r22, 0xB9	; 185
    2d90:	72 e0       	ldi	r23, 0x02	; 2
    2d92:	11 dc       	rcall	.-2014   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2d94:	66 e0       	ldi	r22, 0x06	; 6
    2d96:	c8 01       	movw	r24, r16
    2d98:	45 dc       	rcall	.-1910   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  n:     Enter a number (demo)") << endl;
    2d9a:	6b e0       	ldi	r22, 0x0B	; 11
    2d9c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d9e:	9f 81       	ldd	r25, Y+7	; 0x07
    2da0:	41 dc       	rcall	.-1918   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2da2:	8c 01       	movw	r16, r24
    2da4:	6a e9       	ldi	r22, 0x9A	; 154
    2da6:	72 e0       	ldi	r23, 0x02	; 2
    2da8:	06 dc       	rcall	.-2036   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2daa:	66 e0       	ldi	r22, 0x06	; 6
    2dac:	c8 01       	movw	r24, r16
    2dae:	3a dc       	rcall	.-1932   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    2db0:	6b e0       	ldi	r22, 0x0B	; 11
    2db2:	8e 81       	ldd	r24, Y+6	; 0x06
    2db4:	9f 81       	ldd	r25, Y+7	; 0x07
    2db6:	36 dc       	rcall	.-1940   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2db8:	8c 01       	movw	r16, r24
    2dba:	63 e8       	ldi	r22, 0x83	; 131
    2dbc:	72 e0       	ldi	r23, 0x02	; 2
    2dbe:	fb db       	rcall	.-2058   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2dc0:	66 e0       	ldi	r22, 0x06	; 6
    2dc2:	c8 01       	movw	r24, r16
    2dc4:	2f dc       	rcall	.-1954   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  h:     HALP!") << endl;
    2dc6:	6b e0       	ldi	r22, 0x0B	; 11
    2dc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2dca:	9f 81       	ldd	r25, Y+7	; 0x07
    2dcc:	2b dc       	rcall	.-1962   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2dce:	ec 01       	movw	r28, r24
    2dd0:	64 e7       	ldi	r22, 0x74	; 116
    2dd2:	72 e0       	ldi	r23, 0x02	; 2
    2dd4:	f0 db       	rcall	.-2080   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2dd6:	66 e0       	ldi	r22, 0x06	; 6
    2dd8:	ce 01       	movw	r24, r28
    2dda:	24 dc       	rcall	.-1976   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
}
    2ddc:	df 91       	pop	r29
    2dde:	cf 91       	pop	r28
    2de0:	1f 91       	pop	r17
    2de2:	0f 91       	pop	r16
    2de4:	08 95       	ret

00002de6 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    2de6:	8f 92       	push	r8
    2de8:	9f 92       	push	r9
    2dea:	af 92       	push	r10
    2dec:	bf 92       	push	r11
    2dee:	cf 92       	push	r12
    2df0:	df 92       	push	r13
    2df2:	ef 92       	push	r14
    2df4:	ff 92       	push	r15
    2df6:	0f 93       	push	r16
    2df8:	1f 93       	push	r17
    2dfa:	cf 93       	push	r28
    2dfc:	df 93       	push	r29
    2dfe:	00 d0       	rcall	.+0      	; 0x2e00 <_ZN9task_user11show_statusEv+0x1a>
    2e00:	00 d0       	rcall	.+0      	; 0x2e02 <_ZN9task_user11show_statusEv+0x1c>
    2e02:	00 d0       	rcall	.+0      	; 0x2e04 <_ZN9task_user11show_statusEv+0x1e>
    2e04:	cd b7       	in	r28, 0x3d	; 61
    2e06:	de b7       	in	r29, 0x3e	; 62
    2e08:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    2e0a:	19 82       	std	Y+1, r1	; 0x01
    2e0c:	1a 82       	std	Y+2, r1	; 0x02
    2e0e:	1b 82       	std	Y+3, r1	; 0x03
    2e10:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    2e12:	1e 82       	std	Y+6, r1	; 0x06
    2e14:	1d 82       	std	Y+5, r1	; 0x05
	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("System time: ") << the_time.set_to_now ()
			  << PMS (", Heap: ") << heap_left() << "/" << configTOTAL_HEAP_SIZE
			  #ifdef OCR5A
				<< PMS (", OCR5A: ") << OCR5A << endl << endl;
    2e16:	c0 90 28 01 	lds	r12, 0x0128
    2e1a:	d0 90 29 01 	lds	r13, 0x0129
		 *           available for allocation. 
		 *  @return  The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    2e1e:	0e 94 53 03 	call	0x6a6	; 0x6a6 <xPortGetFreeHeapSize>
    2e22:	5c 01       	movw	r10, r24
{
	time_stamp the_time;					// Holds current time for printing

	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("System time: ") << the_time.set_to_now ()
    2e24:	ce 01       	movw	r24, r28
    2e26:	01 96       	adiw	r24, 0x01	; 1
    2e28:	88 da       	rcall	.-2800   	; 0x233a <_ZN10time_stamp10set_to_nowEv>
    2e2a:	4c 01       	movw	r8, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// First print the program version, compile date, etc. 
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    2e2c:	66 e0       	ldi	r22, 0x06	; 6
    2e2e:	f8 01       	movw	r30, r16
    2e30:	86 81       	ldd	r24, Z+6	; 0x06
    2e32:	97 81       	ldd	r25, Z+7	; 0x07
    2e34:	f7 db       	rcall	.-2066   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e36:	6b e0       	ldi	r22, 0x0B	; 11
    2e38:	f5 db       	rcall	.-2070   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e3a:	7c 01       	movw	r14, r24
    2e3c:	61 e2       	ldi	r22, 0x21	; 33
    2e3e:	72 e0       	ldi	r23, 0x02	; 2
    2e40:	ba db       	rcall	.-2188   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e42:	6b e0       	ldi	r22, 0x0B	; 11
    2e44:	c7 01       	movw	r24, r14
    2e46:	ee db       	rcall	.-2084   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e48:	7c 01       	movw	r14, r24
    2e4a:	67 e4       	ldi	r22, 0x47	; 71
    2e4c:	72 e0       	ldi	r23, 0x02	; 2
    2e4e:	b3 db       	rcall	.-2202   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e50:	66 e0       	ldi	r22, 0x06	; 6
    2e52:	c7 01       	movw	r24, r14
    2e54:	e7 db       	rcall	.-2098   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("System time: ") << the_time.set_to_now ()
    2e56:	6b e0       	ldi	r22, 0x0B	; 11
    2e58:	e5 db       	rcall	.-2102   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e5a:	7c 01       	movw	r14, r24
    2e5c:	63 e5       	ldi	r22, 0x53	; 83
    2e5e:	72 e0       	ldi	r23, 0x02	; 2
    2e60:	aa db       	rcall	.-2220   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e62:	b4 01       	movw	r22, r8
    2e64:	c7 01       	movw	r24, r14
    2e66:	0c da       	rcall	.-3048   	; 0x2280 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap: ") << heap_left() << "/" << configTOTAL_HEAP_SIZE
    2e68:	6b e0       	ldi	r22, 0x0B	; 11
    2e6a:	dc db       	rcall	.-2120   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e6c:	7c 01       	movw	r14, r24
    2e6e:	61 e6       	ldi	r22, 0x61	; 97
    2e70:	72 e0       	ldi	r23, 0x02	; 2
    2e72:	a1 db       	rcall	.-2238   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e74:	b5 01       	movw	r22, r10
    2e76:	c7 01       	movw	r24, r14
    2e78:	19 dc       	rcall	.-1998   	; 0x26ac <_ZN8emstreamlsEj>
    2e7a:	7c 01       	movw	r14, r24
    2e7c:	67 e7       	ldi	r22, 0x77	; 119
    2e7e:	72 e0       	ldi	r23, 0x02	; 2
    2e80:	9a db       	rcall	.-2252   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e82:	48 e3       	ldi	r20, 0x38	; 56
    2e84:	57 e1       	ldi	r21, 0x17	; 23
    2e86:	60 e0       	ldi	r22, 0x00	; 0
    2e88:	70 e0       	ldi	r23, 0x00	; 0
    2e8a:	c7 01       	movw	r24, r14
    2e8c:	45 dc       	rcall	.-1910   	; 0x2718 <_ZN8emstreamlsEm>
			  #ifdef OCR5A
				<< PMS (", OCR5A: ") << OCR5A << endl << endl;
    2e8e:	6b e0       	ldi	r22, 0x0B	; 11
    2e90:	c9 db       	rcall	.-2158   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2e92:	7c 01       	movw	r14, r24
    2e94:	6a e6       	ldi	r22, 0x6A	; 106
    2e96:	72 e0       	ldi	r23, 0x02	; 2
    2e98:	8e db       	rcall	.-2276   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2e9a:	b6 01       	movw	r22, r12
    2e9c:	c7 01       	movw	r24, r14
    2e9e:	06 dc       	rcall	.-2036   	; 0x26ac <_ZN8emstreamlsEj>
    2ea0:	66 e0       	ldi	r22, 0x06	; 6
    2ea2:	c0 db       	rcall	.-2176   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2ea4:	66 e0       	ldi	r22, 0x06	; 6
    2ea6:	be db       	rcall	.-2180   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
			  #else
				<< PMS (", OCR1A: ") << OCR1A << endl << endl;
			  #endif

	// Have the tasks print their status; then the same for the shared data items
	print_task_list (p_serial);
    2ea8:	f8 01       	movw	r30, r16
    2eaa:	86 81       	ldd	r24, Z+6	; 0x06
    2eac:	97 81       	ldd	r25, Z+7	; 0x07
    2eae:	50 d8       	rcall	.-3936   	; 0x1f50 <_Z15print_task_listP8emstream>
	*p_serial << endl;
    2eb0:	66 e0       	ldi	r22, 0x06	; 6
    2eb2:	f8 01       	movw	r30, r16
    2eb4:	86 81       	ldd	r24, Z+6	; 0x06
    2eb6:	97 81       	ldd	r25, Z+7	; 0x07
    2eb8:	b5 db       	rcall	.-2198   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
	print_all_shares (p_serial);
    2eba:	f8 01       	movw	r30, r16
    2ebc:	86 81       	ldd	r24, Z+6	; 0x06
    2ebe:	97 81       	ldd	r25, Z+7	; 0x07
    2ec0:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <_Z16print_all_sharesP8emstream>
}
    2ec4:	26 96       	adiw	r28, 0x06	; 6
    2ec6:	0f b6       	in	r0, 0x3f	; 63
    2ec8:	f8 94       	cli
    2eca:	de bf       	out	0x3e, r29	; 62
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	cd bf       	out	0x3d, r28	; 61
    2ed0:	df 91       	pop	r29
    2ed2:	cf 91       	pop	r28
    2ed4:	1f 91       	pop	r17
    2ed6:	0f 91       	pop	r16
    2ed8:	ff 90       	pop	r15
    2eda:	ef 90       	pop	r14
    2edc:	df 90       	pop	r13
    2ede:	cf 90       	pop	r12
    2ee0:	bf 90       	pop	r11
    2ee2:	af 90       	pop	r10
    2ee4:	9f 90       	pop	r9
    2ee6:	8f 90       	pop	r8
    2ee8:	08 95       	ret

00002eea <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29
    2eee:	00 d0       	rcall	.+0      	; 0x2ef0 <_ZN9task_user3runEv+0x6>
    2ef0:	00 d0       	rcall	.+0      	; 0x2ef2 <_ZN9task_user3runEv+0x8>
    2ef2:	00 d0       	rcall	.+0      	; 0x2ef4 <_ZN9task_user3runEv+0xa>
    2ef4:	cd b7       	in	r28, 0x3d	; 61
    2ef6:	de b7       	in	r29, 0x3e	; 62
    2ef8:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    2efa:	19 82       	std	Y+1, r1	; 0x01
    2efc:	1a 82       	std	Y+2, r1	; 0x02
    2efe:	1b 82       	std	Y+3, r1	; 0x03
    2f00:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    2f02:	1e 82       	std	Y+6, r1	; 0x06
    2f04:	1d 82       	std	Y+5, r1	; 0x05
	time_stamp a_time;                      // Holds the time so it can be displayed
	uint32_t number_entered = 0;            // Holds a number being entered by user

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press 'h' or '?' for help") << endl;
    2f06:	6b e0       	ldi	r22, 0x0B	; 11
    2f08:	dc 01       	movw	r26, r24
    2f0a:	16 96       	adiw	r26, 0x06	; 6
    2f0c:	8d 91       	ld	r24, X+
    2f0e:	9c 91       	ld	r25, X
    2f10:	17 97       	sbiw	r26, 0x07	; 7
    2f12:	88 db       	rcall	.-2288   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2f14:	7c 01       	movw	r14, r24
    2f16:	63 ed       	ldi	r22, 0xD3	; 211
    2f18:	73 e0       	ldi	r23, 0x03	; 3
    2f1a:	4d db       	rcall	.-2406   	; 0x25b6 <_ZN8emstream4putsEPKc>
    2f1c:	66 e0       	ldi	r22, 0x06	; 6
    2f1e:	c7 01       	movw	r24, r14
    2f20:	81 db       	rcall	.-2302   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>

void task_user::run (void)
{
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed
	uint32_t number_entered = 0;            // Holds a number being entered by user
    2f22:	c1 2c       	mov	r12, r1
    2f24:	d1 2c       	mov	r13, r1
    2f26:	76 01       	movw	r14, r12

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
							             "then RETURN or ESC") << endl;
							number_entered = 0;
    2f28:	51 2c       	mov	r5, r1
    2f2a:	61 2c       	mov	r6, r1
    2f2c:	71 2c       	mov	r7, r1
    2f2e:	81 2c       	mov	r8, r1
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by parent class
		switch (state)
    2f30:	f8 01       	movw	r30, r16
    2f32:	84 85       	ldd	r24, Z+12	; 0x0c
    2f34:	88 23       	and	r24, r24
    2f36:	21 f0       	breq	.+8      	; 0x2f40 <_ZN9task_user3runEv+0x56>
    2f38:	81 30       	cpi	r24, 0x01	; 1
    2f3a:	09 f4       	brne	.+2      	; 0x2f3e <_ZN9task_user3runEv+0x54>
    2f3c:	9a c0       	rjmp	.+308    	; 0x3072 <_ZN9task_user3runEv+0x188>
    2f3e:	48 c1       	rjmp	.+656    	; 0x31d0 <_ZN9task_user3runEv+0x2e6>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we're in command mode, so when the user types characters, 
			// the characters are interpreted as commands to do something
			case (0):
				if (p_serial->check_for_char ())            // If the user typed a
    2f40:	86 81       	ldd	r24, Z+6	; 0x06
    2f42:	97 81       	ldd	r25, Z+7	; 0x07
    2f44:	dc 01       	movw	r26, r24
    2f46:	ed 91       	ld	r30, X+
    2f48:	fc 91       	ld	r31, X
    2f4a:	04 80       	ldd	r0, Z+4	; 0x04
    2f4c:	f5 81       	ldd	r31, Z+5	; 0x05
    2f4e:	e0 2d       	mov	r30, r0
    2f50:	09 95       	icall
    2f52:	88 23       	and	r24, r24
    2f54:	09 f4       	brne	.+2      	; 0x2f58 <_ZN9task_user3runEv+0x6e>
    2f56:	52 c1       	rjmp	.+676    	; 0x31fc <_ZN9task_user3runEv+0x312>
				{                                           // character, read
					char_in = p_serial->getchar ();         // the character
    2f58:	f8 01       	movw	r30, r16
    2f5a:	86 81       	ldd	r24, Z+6	; 0x06
    2f5c:	97 81       	ldd	r25, Z+7	; 0x07
    2f5e:	dc 01       	movw	r26, r24
    2f60:	ed 91       	ld	r30, X+
    2f62:	fc 91       	ld	r31, X
    2f64:	06 80       	ldd	r0, Z+6	; 0x06
    2f66:	f7 81       	ldd	r31, Z+7	; 0x07
    2f68:	e0 2d       	mov	r30, r0
    2f6a:	09 95       	icall
    2f6c:	98 2e       	mov	r9, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    2f6e:	b8 e6       	ldi	r27, 0x68	; 104
    2f70:	8b 17       	cp	r24, r27
    2f72:	61 f1       	breq	.+88     	; 0x2fcc <_ZN9task_user3runEv+0xe2>
    2f74:	b8 17       	cp	r27, r24
    2f76:	50 f0       	brcs	.+20     	; 0x2f8c <_ZN9task_user3runEv+0xa2>
    2f78:	ef e3       	ldi	r30, 0x3F	; 63
    2f7a:	8e 17       	cp	r24, r30
    2f7c:	39 f1       	breq	.+78     	; 0x2fcc <_ZN9task_user3runEv+0xe2>
    2f7e:	f4 e6       	ldi	r31, 0x64	; 100
    2f80:	8f 17       	cp	r24, r31
    2f82:	f1 f0       	breq	.+60     	; 0x2fc0 <_ZN9task_user3runEv+0xd6>
    2f84:	83 e0       	ldi	r24, 0x03	; 3
    2f86:	98 12       	cpse	r9, r24
    2f88:	52 c0       	rjmp	.+164    	; 0x302e <_ZN9task_user3runEv+0x144>
    2f8a:	3a c0       	rjmp	.+116    	; 0x3000 <_ZN9task_user3runEv+0x116>
    2f8c:	a3 e7       	ldi	r26, 0x73	; 115
    2f8e:	8a 17       	cp	r24, r26
    2f90:	a1 f0       	breq	.+40     	; 0x2fba <_ZN9task_user3runEv+0xd0>
    2f92:	b4 e7       	ldi	r27, 0x74	; 116
    2f94:	8b 17       	cp	r24, r27
    2f96:	21 f0       	breq	.+8      	; 0x2fa0 <_ZN9task_user3runEv+0xb6>
    2f98:	ee e6       	ldi	r30, 0x6E	; 110
    2f9a:	8e 13       	cpse	r24, r30
    2f9c:	48 c0       	rjmp	.+144    	; 0x302e <_ZN9task_user3runEv+0x144>
    2f9e:	19 c0       	rjmp	.+50     	; 0x2fd2 <_ZN9task_user3runEv+0xe8>
					{
						// The 't' command asks what time it is right now
						case ('t'):
							*p_serial << (a_time.set_to_now ()) << endl;
    2fa0:	ce 01       	movw	r24, r28
    2fa2:	01 96       	adiw	r24, 0x01	; 1
    2fa4:	ca d9       	rcall	.-3180   	; 0x233a <_ZN10time_stamp10set_to_nowEv>
    2fa6:	bc 01       	movw	r22, r24
    2fa8:	d8 01       	movw	r26, r16
    2faa:	16 96       	adiw	r26, 0x06	; 6
    2fac:	8d 91       	ld	r24, X+
    2fae:	9c 91       	ld	r25, X
    2fb0:	17 97       	sbiw	r26, 0x07	; 7
    2fb2:	66 d9       	rcall	.-3380   	; 0x2280 <_ZlsR8emstreamR10time_stamp>
    2fb4:	66 e0       	ldi	r22, 0x06	; 6
    2fb6:	36 db       	rcall	.-2452   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
							break;
    2fb8:	21 c1       	rjmp	.+578    	; 0x31fc <_ZN9task_user3runEv+0x312>

						// The 's' command asks for version and status information
						case ('s'):
							show_status ();
    2fba:	c8 01       	movw	r24, r16
    2fbc:	14 df       	rcall	.-472    	; 0x2de6 <_ZN9task_user11show_statusEv>
							break;
    2fbe:	1e c1       	rjmp	.+572    	; 0x31fc <_ZN9task_user3runEv+0x312>

						// The 'd' command has all the tasks dump their stacks
						case ('d'):
							print_task_stacks (p_serial);
    2fc0:	f8 01       	movw	r30, r16
    2fc2:	86 81       	ldd	r24, Z+6	; 0x06
    2fc4:	97 81       	ldd	r25, Z+7	; 0x07
    2fc6:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <_Z17print_task_stacksP8emstream>
							break;
    2fca:	18 c1       	rjmp	.+560    	; 0x31fc <_ZN9task_user3runEv+0x312>

						// The 'h' command is a plea for help; '?' works also
						case ('h'):
						case ('?'):
							print_help_message ();
    2fcc:	c8 01       	movw	r24, r16
    2fce:	ad de       	rcall	.-678    	; 0x2d2a <_ZN9task_user18print_help_messageEv>
							break;
    2fd0:	15 c1       	rjmp	.+554    	; 0x31fc <_ZN9task_user3runEv+0x312>

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
    2fd2:	6b e0       	ldi	r22, 0x0B	; 11
    2fd4:	d8 01       	movw	r26, r16
    2fd6:	16 96       	adiw	r26, 0x06	; 6
    2fd8:	8d 91       	ld	r24, X+
    2fda:	9c 91       	ld	r25, X
    2fdc:	17 97       	sbiw	r26, 0x07	; 7
    2fde:	22 db       	rcall	.-2492   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    2fe0:	7c 01       	movw	r14, r24
    2fe2:	62 ea       	ldi	r22, 0xA2	; 162
    2fe4:	73 e0       	ldi	r23, 0x03	; 3
    2fe6:	e7 da       	rcall	.-2610   	; 0x25b6 <_ZN8emstream4putsEPKc>
							             "then RETURN or ESC") << endl;
    2fe8:	66 e0       	ldi	r22, 0x06	; 6
    2fea:	c7 01       	movw	r24, r14
    2fec:	1b db       	rcall	.-2506   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
							number_entered = 0;
							transition_to (1);
    2fee:	61 e0       	ldi	r22, 0x01	; 1
    2ff0:	c8 01       	movw	r24, r16
    2ff2:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN8TaskBase13transition_toEh>

						// The 'n' command runs a test of entering a number
						case ('n'):
							*p_serial << PMS ("Enter decimal numeric digits, "
							             "then RETURN or ESC") << endl;
							number_entered = 0;
    2ff6:	c5 2c       	mov	r12, r5
    2ff8:	d6 2c       	mov	r13, r6
    2ffa:	e7 2c       	mov	r14, r7
    2ffc:	f8 2c       	mov	r15, r8
							transition_to (1);
							break;
    2ffe:	fe c0       	rjmp	.+508    	; 0x31fc <_ZN9task_user3runEv+0x312>

						// A control-C character causes the CPU to restart
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    3000:	6b e0       	ldi	r22, 0x0B	; 11
    3002:	f8 01       	movw	r30, r16
    3004:	86 81       	ldd	r24, Z+6	; 0x06
    3006:	97 81       	ldd	r25, Z+7	; 0x07
    3008:	0d db       	rcall	.-2534   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    300a:	8c 01       	movw	r16, r24
    300c:	64 e9       	ldi	r22, 0x94	; 148
    300e:	73 e0       	ldi	r23, 0x03	; 3
    3010:	d2 da       	rcall	.-2652   	; 0x25b6 <_ZN8emstream4putsEPKc>
    3012:	66 e0       	ldi	r22, 0x06	; 6
    3014:	c8 01       	movw	r24, r16
    3016:	06 db       	rcall	.-2548   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
    3018:	9b e0       	ldi	r25, 0x0B	; 11
    301a:	88 e1       	ldi	r24, 0x18	; 24
    301c:	0f b6       	in	r0, 0x3f	; 63
    301e:	f8 94       	cli
    3020:	a8 95       	wdr
    3022:	80 93 60 00 	sts	0x0060, r24
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	90 93 60 00 	sts	0x0060, r25
							break;

						// If character isn't recognized, ask What's That Function?
						default:
							*p_serial << '"' << char_in << PMS ("\": WTF?") << endl;
							break;
    302c:	ff cf       	rjmp	.-2      	; 0x302c <_ZN9task_user3runEv+0x142>
							for (;;);
							break;

						// If character isn't recognized, ask What's That Function?
						default:
							*p_serial << '"' << char_in << PMS ("\": WTF?") << endl;
    302e:	d8 01       	movw	r26, r16
    3030:	16 96       	adiw	r26, 0x06	; 6
    3032:	ad 90       	ld	r10, X+
    3034:	bc 90       	ld	r11, X
    3036:	17 97       	sbiw	r26, 0x07	; 7
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3038:	d5 01       	movw	r26, r10
    303a:	ed 91       	ld	r30, X+
    303c:	fc 91       	ld	r31, X
    303e:	02 80       	ldd	r0, Z+2	; 0x02
    3040:	f3 81       	ldd	r31, Z+3	; 0x03
    3042:	e0 2d       	mov	r30, r0
    3044:	62 e2       	ldi	r22, 0x22	; 34
    3046:	c5 01       	movw	r24, r10
    3048:	09 95       	icall
    304a:	d5 01       	movw	r26, r10
    304c:	ed 91       	ld	r30, X+
    304e:	fc 91       	ld	r31, X
    3050:	02 80       	ldd	r0, Z+2	; 0x02
    3052:	f3 81       	ldd	r31, Z+3	; 0x03
    3054:	e0 2d       	mov	r30, r0
    3056:	69 2d       	mov	r22, r9
    3058:	c5 01       	movw	r24, r10
    305a:	09 95       	icall
    305c:	6b e0       	ldi	r22, 0x0B	; 11
    305e:	c5 01       	movw	r24, r10
    3060:	e1 da       	rcall	.-2622   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    3062:	5c 01       	movw	r10, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3064:	6c e8       	ldi	r22, 0x8C	; 140
    3066:	73 e0       	ldi	r23, 0x03	; 3
    3068:	a6 da       	rcall	.-2740   	; 0x25b6 <_ZN8emstream4putsEPKc>
    306a:	66 e0       	ldi	r22, 0x06	; 6
    306c:	c5 01       	movw	r24, r10
    306e:	da da       	rcall	.-2636   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
							break;
    3070:	c5 c0       	rjmp	.+394    	; 0x31fc <_ZN9task_user3runEv+0x312>
				break; // End of state 0

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, wait for user to enter digits and build 'em into a number
			case (1):
				if (p_serial->check_for_char ())        // If the user typed a
    3072:	f8 01       	movw	r30, r16
    3074:	86 81       	ldd	r24, Z+6	; 0x06
    3076:	97 81       	ldd	r25, Z+7	; 0x07
    3078:	dc 01       	movw	r26, r24
    307a:	ed 91       	ld	r30, X+
    307c:	fc 91       	ld	r31, X
    307e:	04 80       	ldd	r0, Z+4	; 0x04
    3080:	f5 81       	ldd	r31, Z+5	; 0x05
    3082:	e0 2d       	mov	r30, r0
    3084:	09 95       	icall
    3086:	88 23       	and	r24, r24
    3088:	09 f4       	brne	.+2      	; 0x308c <_ZN9task_user3runEv+0x1a2>
    308a:	79 c0       	rjmp	.+242    	; 0x317e <_ZN9task_user3runEv+0x294>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    308c:	f8 01       	movw	r30, r16
    308e:	86 81       	ldd	r24, Z+6	; 0x06
    3090:	97 81       	ldd	r25, Z+7	; 0x07
    3092:	dc 01       	movw	r26, r24
    3094:	ed 91       	ld	r30, X+
    3096:	fc 91       	ld	r31, X
    3098:	06 80       	ldd	r0, Z+6	; 0x06
    309a:	f7 81       	ldd	r31, Z+7	; 0x07
    309c:	e0 2d       	mov	r30, r0
    309e:	09 95       	icall
    30a0:	98 2e       	mov	r9, r24

					// Respond to numeric characters, Enter or Esc only. Numbers are
					// put into the numeric value we're building up
					if (char_in >= '0' && char_in <= '9')
    30a2:	80 ed       	ldi	r24, 0xD0	; 208
    30a4:	89 0d       	add	r24, r9
    30a6:	8a 30       	cpi	r24, 0x0A	; 10
    30a8:	48 f5       	brcc	.+82     	; 0x30fc <_ZN9task_user3runEv+0x212>
					{
						*p_serial << char_in;
    30aa:	f8 01       	movw	r30, r16
    30ac:	86 81       	ldd	r24, Z+6	; 0x06
    30ae:	97 81       	ldd	r25, Z+7	; 0x07
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    30b0:	dc 01       	movw	r26, r24
    30b2:	ed 91       	ld	r30, X+
    30b4:	fc 91       	ld	r31, X
    30b6:	02 80       	ldd	r0, Z+2	; 0x02
    30b8:	f3 81       	ldd	r31, Z+3	; 0x03
    30ba:	e0 2d       	mov	r30, r0
    30bc:	69 2d       	mov	r22, r9
    30be:	09 95       	icall
						number_entered *= 10;
    30c0:	cc 0c       	add	r12, r12
    30c2:	dd 1c       	adc	r13, r13
    30c4:	ee 1c       	adc	r14, r14
    30c6:	ff 1c       	adc	r15, r15
    30c8:	d7 01       	movw	r26, r14
    30ca:	c6 01       	movw	r24, r12
    30cc:	88 0f       	add	r24, r24
    30ce:	99 1f       	adc	r25, r25
    30d0:	aa 1f       	adc	r26, r26
    30d2:	bb 1f       	adc	r27, r27
    30d4:	88 0f       	add	r24, r24
    30d6:	99 1f       	adc	r25, r25
    30d8:	aa 1f       	adc	r26, r26
    30da:	bb 1f       	adc	r27, r27
    30dc:	c8 0e       	add	r12, r24
    30de:	d9 1e       	adc	r13, r25
    30e0:	ea 1e       	adc	r14, r26
    30e2:	fb 1e       	adc	r15, r27
						number_entered += char_in - '0';
    30e4:	89 2d       	mov	r24, r9
    30e6:	90 e0       	ldi	r25, 0x00	; 0
    30e8:	c0 97       	sbiw	r24, 0x30	; 48
    30ea:	09 2e       	mov	r0, r25
    30ec:	00 0c       	add	r0, r0
    30ee:	aa 0b       	sbc	r26, r26
    30f0:	bb 0b       	sbc	r27, r27
    30f2:	c8 0e       	add	r12, r24
    30f4:	d9 1e       	adc	r13, r25
    30f6:	ea 1e       	adc	r14, r26
    30f8:	fb 1e       	adc	r15, r27
    30fa:	80 c0       	rjmp	.+256    	; 0x31fc <_ZN9task_user3runEv+0x312>
					}
					// Carriage return is ignored; the newline character ends the entry
					else if (char_in == 10)
    30fc:	ba e0       	ldi	r27, 0x0A	; 10
    30fe:	9b 12       	cpse	r9, r27
    3100:	07 c0       	rjmp	.+14     	; 0x3110 <_ZN9task_user3runEv+0x226>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3102:	69 e7       	ldi	r22, 0x79	; 121
    3104:	72 e0       	ldi	r23, 0x02	; 2
    3106:	f8 01       	movw	r30, r16
    3108:	86 81       	ldd	r24, Z+6	; 0x06
    310a:	97 81       	ldd	r25, Z+7	; 0x07
    310c:	54 da       	rcall	.-2904   	; 0x25b6 <_ZN8emstream4putsEPKc>
    310e:	76 c0       	rjmp	.+236    	; 0x31fc <_ZN9task_user3runEv+0x312>
					{
						*p_serial << "\r";
					}
					// Carriage return or Escape ends numeric entry
					else if (char_in == 13 || char_in == 27)
    3110:	fd e0       	ldi	r31, 0x0D	; 13
    3112:	9f 16       	cp	r9, r31
    3114:	19 f0       	breq	.+6      	; 0x311c <_ZN9task_user3runEv+0x232>
    3116:	8b e1       	ldi	r24, 0x1B	; 27
    3118:	98 12       	cpse	r9, r24
    311a:	18 c0       	rjmp	.+48     	; 0x314c <_ZN9task_user3runEv+0x262>
					{
						*p_serial << endl << PMS ("Number entered: ") 
    311c:	66 e0       	ldi	r22, 0x06	; 6
    311e:	d8 01       	movw	r26, r16
    3120:	16 96       	adiw	r26, 0x06	; 6
    3122:	8d 91       	ld	r24, X+
    3124:	9c 91       	ld	r25, X
    3126:	17 97       	sbiw	r26, 0x07	; 7
    3128:	7d da       	rcall	.-2822   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    312a:	6b e0       	ldi	r22, 0x0B	; 11
    312c:	7b da       	rcall	.-2826   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    312e:	5c 01       	movw	r10, r24
    3130:	6b e7       	ldi	r22, 0x7B	; 123
    3132:	73 e0       	ldi	r23, 0x03	; 3
    3134:	40 da       	rcall	.-2944   	; 0x25b6 <_ZN8emstream4putsEPKc>
								  << number_entered << endl;
    3136:	b7 01       	movw	r22, r14
    3138:	a6 01       	movw	r20, r12
    313a:	c5 01       	movw	r24, r10
    313c:	ed da       	rcall	.-2598   	; 0x2718 <_ZN8emstreamlsEm>
    313e:	66 e0       	ldi	r22, 0x06	; 6
    3140:	71 da       	rcall	.-2846   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
						transition_to (0);
    3142:	60 e0       	ldi	r22, 0x00	; 0
    3144:	c8 01       	movw	r24, r16
    3146:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN8TaskBase13transition_toEh>
    314a:	58 c0       	rjmp	.+176    	; 0x31fc <_ZN9task_user3runEv+0x312>
					}
					else
					{
						*p_serial << PMS ("<invalid char \"") << char_in 
    314c:	6b e0       	ldi	r22, 0x0B	; 11
    314e:	f8 01       	movw	r30, r16
    3150:	86 81       	ldd	r24, Z+6	; 0x06
    3152:	97 81       	ldd	r25, Z+7	; 0x07
    3154:	67 da       	rcall	.-2866   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    3156:	5c 01       	movw	r10, r24
    3158:	68 e6       	ldi	r22, 0x68	; 104
    315a:	73 e0       	ldi	r23, 0x03	; 3
    315c:	2c da       	rcall	.-2984   	; 0x25b6 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    315e:	d5 01       	movw	r26, r10
    3160:	ed 91       	ld	r30, X+
    3162:	fc 91       	ld	r31, X
    3164:	02 80       	ldd	r0, Z+2	; 0x02
    3166:	f3 81       	ldd	r31, Z+3	; 0x03
    3168:	e0 2d       	mov	r30, r0
    316a:	69 2d       	mov	r22, r9
    316c:	c5 01       	movw	r24, r10
    316e:	09 95       	icall
								  << PMS ("\">");
    3170:	6b e0       	ldi	r22, 0x0B	; 11
    3172:	c5 01       	movw	r24, r10
    3174:	57 da       	rcall	.-2898   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3176:	68 e7       	ldi	r22, 0x78	; 120
    3178:	73 e0       	ldi	r23, 0x03	; 3
    317a:	1d da       	rcall	.-3014   	; 0x25b6 <_ZN8emstream4putsEPKc>
    317c:	3f c0       	rjmp	.+126    	; 0x31fc <_ZN9task_user3runEv+0x312>
					}
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (p_print_ser_queue->check_for_char ())
    317e:	80 91 3a 1a 	lds	r24, 0x1A3A
    3182:	90 91 3b 1a 	lds	r25, 0x1A3B
    3186:	dc 01       	movw	r26, r24
    3188:	ed 91       	ld	r30, X+
    318a:	fc 91       	ld	r31, X
    318c:	04 80       	ldd	r0, Z+4	; 0x04
    318e:	f5 81       	ldd	r31, Z+5	; 0x05
    3190:	e0 2d       	mov	r30, r0
    3192:	09 95       	icall
    3194:	88 23       	and	r24, r24
    3196:	91 f1       	breq	.+100    	; 0x31fc <_ZN9task_user3runEv+0x312>
				{
					p_serial->putchar (p_print_ser_queue->getchar ());
    3198:	d8 01       	movw	r26, r16
    319a:	16 96       	adiw	r26, 0x06	; 6
    319c:	ed 91       	ld	r30, X+
    319e:	fc 91       	ld	r31, X
    31a0:	17 97       	sbiw	r26, 0x07	; 7
    31a2:	01 90       	ld	r0, Z+
    31a4:	f0 81       	ld	r31, Z
    31a6:	e0 2d       	mov	r30, r0
    31a8:	a2 80       	ldd	r10, Z+2	; 0x02
    31aa:	b3 80       	ldd	r11, Z+3	; 0x03
    31ac:	80 91 3a 1a 	lds	r24, 0x1A3A
    31b0:	90 91 3b 1a 	lds	r25, 0x1A3B
    31b4:	dc 01       	movw	r26, r24
    31b6:	ed 91       	ld	r30, X+
    31b8:	fc 91       	ld	r31, X
    31ba:	06 80       	ldd	r0, Z+6	; 0x06
    31bc:	f7 81       	ldd	r31, Z+7	; 0x07
    31be:	e0 2d       	mov	r30, r0
    31c0:	09 95       	icall
    31c2:	68 2f       	mov	r22, r24
    31c4:	f8 01       	movw	r30, r16
    31c6:	86 81       	ldd	r24, Z+6	; 0x06
    31c8:	97 81       	ldd	r25, Z+7	; 0x07
    31ca:	f5 01       	movw	r30, r10
    31cc:	09 95       	icall
    31ce:	16 c0       	rjmp	.+44     	; 0x31fc <_ZN9task_user3runEv+0x312>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    31d0:	6b e0       	ldi	r22, 0x0B	; 11
    31d2:	86 81       	ldd	r24, Z+6	; 0x06
    31d4:	97 81       	ldd	r25, Z+7	; 0x07
    31d6:	26 da       	rcall	.-2996   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    31d8:	8c 01       	movw	r16, r24
    31da:	6b e4       	ldi	r22, 0x4B	; 75
    31dc:	73 e0       	ldi	r23, 0x03	; 3
    31de:	eb d9       	rcall	.-3114   	; 0x25b6 <_ZN8emstream4putsEPKc>
    31e0:	66 e0       	ldi	r22, 0x06	; 6
    31e2:	c8 01       	movw	r24, r16
    31e4:	1f da       	rcall	.-3010   	; 0x2624 <_ZN8emstreamlsE15ser_manipulator>
    31e6:	9b e0       	ldi	r25, 0x0B	; 11
    31e8:	88 e1       	ldi	r24, 0x18	; 24
    31ea:	0f b6       	in	r0, 0x3f	; 63
    31ec:	f8 94       	cli
    31ee:	a8 95       	wdr
    31f0:	80 93 60 00 	sts	0x0060, r24
    31f4:	0f be       	out	0x3f, r0	; 63
    31f6:	90 93 60 00 	sts	0x0060, r25
				wdt_enable (WDTO_120MS);
				for (;;);
				break;
    31fa:	ff cf       	rjmp	.-2      	; 0x31fa <_ZN9task_user3runEv+0x310>

		} // End switch state

		runs++;                             // Increment counter for debugging
    31fc:	f8 01       	movw	r30, r16
    31fe:	86 85       	ldd	r24, Z+14	; 0x0e
    3200:	97 85       	ldd	r25, Z+15	; 0x0f
    3202:	a0 89       	ldd	r26, Z+16	; 0x10
    3204:	b1 89       	ldd	r27, Z+17	; 0x11
    3206:	01 96       	adiw	r24, 0x01	; 1
    3208:	a1 1d       	adc	r26, r1
    320a:	b1 1d       	adc	r27, r1
    320c:	86 87       	std	Z+14, r24	; 0x0e
    320e:	97 87       	std	Z+15, r25	; 0x0f
    3210:	a0 8b       	std	Z+16, r26	; 0x10
    3212:	b1 8b       	std	Z+17, r27	; 0x11
		 *  @param   duration_ms The duration for the task to stop in milliseconds
		 */
		void delay_ms (TickType_t duration_ms)
		{
			TickType_t ticks = ((uint32_t)duration_ms * configTICK_RATE_HZ) / 1000UL;
            vTaskDelay (ticks);
    3214:	61 e0       	ldi	r22, 0x01	; 1
    3216:	70 e0       	ldi	r23, 0x00	; 0
    3218:	80 e0       	ldi	r24, 0x00	; 0
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <vTaskDelay>
    3220:	87 ce       	rjmp	.-754    	; 0x2f30 <_ZN9task_user3runEv+0x46>

00003222 <__mulsi3>:
    3222:	db 01       	movw	r26, r22
    3224:	8f 93       	push	r24
    3226:	9f 93       	push	r25
    3228:	65 d0       	rcall	.+202    	; 0x32f4 <__muluhisi3>
    322a:	bf 91       	pop	r27
    322c:	af 91       	pop	r26
    322e:	a2 9f       	mul	r26, r18
    3230:	80 0d       	add	r24, r0
    3232:	91 1d       	adc	r25, r1
    3234:	a3 9f       	mul	r26, r19
    3236:	90 0d       	add	r25, r0
    3238:	b2 9f       	mul	r27, r18
    323a:	90 0d       	add	r25, r0
    323c:	11 24       	eor	r1, r1
    323e:	08 95       	ret

00003240 <__divmodhi4>:
    3240:	97 fb       	bst	r25, 7
    3242:	07 2e       	mov	r0, r23
    3244:	16 f4       	brtc	.+4      	; 0x324a <__divmodhi4+0xa>
    3246:	00 94       	com	r0
    3248:	06 d0       	rcall	.+12     	; 0x3256 <__divmodhi4_neg1>
    324a:	77 fd       	sbrc	r23, 7
    324c:	08 d0       	rcall	.+16     	; 0x325e <__divmodhi4_neg2>
    324e:	5c d0       	rcall	.+184    	; 0x3308 <__udivmodhi4>
    3250:	07 fc       	sbrc	r0, 7
    3252:	05 d0       	rcall	.+10     	; 0x325e <__divmodhi4_neg2>
    3254:	3e f4       	brtc	.+14     	; 0x3264 <__divmodhi4_exit>

00003256 <__divmodhi4_neg1>:
    3256:	90 95       	com	r25
    3258:	81 95       	neg	r24
    325a:	9f 4f       	sbci	r25, 0xFF	; 255
    325c:	08 95       	ret

0000325e <__divmodhi4_neg2>:
    325e:	70 95       	com	r23
    3260:	61 95       	neg	r22
    3262:	7f 4f       	sbci	r23, 0xFF	; 255

00003264 <__divmodhi4_exit>:
    3264:	08 95       	ret

00003266 <__udivmodsi4>:
    3266:	a1 e2       	ldi	r26, 0x21	; 33
    3268:	1a 2e       	mov	r1, r26
    326a:	aa 1b       	sub	r26, r26
    326c:	bb 1b       	sub	r27, r27
    326e:	fd 01       	movw	r30, r26
    3270:	0d c0       	rjmp	.+26     	; 0x328c <__udivmodsi4_ep>

00003272 <__udivmodsi4_loop>:
    3272:	aa 1f       	adc	r26, r26
    3274:	bb 1f       	adc	r27, r27
    3276:	ee 1f       	adc	r30, r30
    3278:	ff 1f       	adc	r31, r31
    327a:	a2 17       	cp	r26, r18
    327c:	b3 07       	cpc	r27, r19
    327e:	e4 07       	cpc	r30, r20
    3280:	f5 07       	cpc	r31, r21
    3282:	20 f0       	brcs	.+8      	; 0x328c <__udivmodsi4_ep>
    3284:	a2 1b       	sub	r26, r18
    3286:	b3 0b       	sbc	r27, r19
    3288:	e4 0b       	sbc	r30, r20
    328a:	f5 0b       	sbc	r31, r21

0000328c <__udivmodsi4_ep>:
    328c:	66 1f       	adc	r22, r22
    328e:	77 1f       	adc	r23, r23
    3290:	88 1f       	adc	r24, r24
    3292:	99 1f       	adc	r25, r25
    3294:	1a 94       	dec	r1
    3296:	69 f7       	brne	.-38     	; 0x3272 <__udivmodsi4_loop>
    3298:	60 95       	com	r22
    329a:	70 95       	com	r23
    329c:	80 95       	com	r24
    329e:	90 95       	com	r25
    32a0:	9b 01       	movw	r18, r22
    32a2:	ac 01       	movw	r20, r24
    32a4:	bd 01       	movw	r22, r26
    32a6:	cf 01       	movw	r24, r30
    32a8:	08 95       	ret

000032aa <__divmodsi4>:
    32aa:	05 2e       	mov	r0, r21
    32ac:	97 fb       	bst	r25, 7
    32ae:	16 f4       	brtc	.+4      	; 0x32b4 <__divmodsi4+0xa>
    32b0:	00 94       	com	r0
    32b2:	0f d0       	rcall	.+30     	; 0x32d2 <__negsi2>
    32b4:	57 fd       	sbrc	r21, 7
    32b6:	05 d0       	rcall	.+10     	; 0x32c2 <__divmodsi4_neg2>
    32b8:	d6 df       	rcall	.-84     	; 0x3266 <__udivmodsi4>
    32ba:	07 fc       	sbrc	r0, 7
    32bc:	02 d0       	rcall	.+4      	; 0x32c2 <__divmodsi4_neg2>
    32be:	46 f4       	brtc	.+16     	; 0x32d0 <__divmodsi4_exit>
    32c0:	08 c0       	rjmp	.+16     	; 0x32d2 <__negsi2>

000032c2 <__divmodsi4_neg2>:
    32c2:	50 95       	com	r21
    32c4:	40 95       	com	r20
    32c6:	30 95       	com	r19
    32c8:	21 95       	neg	r18
    32ca:	3f 4f       	sbci	r19, 0xFF	; 255
    32cc:	4f 4f       	sbci	r20, 0xFF	; 255
    32ce:	5f 4f       	sbci	r21, 0xFF	; 255

000032d0 <__divmodsi4_exit>:
    32d0:	08 95       	ret

000032d2 <__negsi2>:
    32d2:	90 95       	com	r25
    32d4:	80 95       	com	r24
    32d6:	70 95       	com	r23
    32d8:	61 95       	neg	r22
    32da:	7f 4f       	sbci	r23, 0xFF	; 255
    32dc:	8f 4f       	sbci	r24, 0xFF	; 255
    32de:	9f 4f       	sbci	r25, 0xFF	; 255
    32e0:	08 95       	ret

000032e2 <__tablejump2__>:
    32e2:	ee 0f       	add	r30, r30
    32e4:	ff 1f       	adc	r31, r31
    32e6:	00 24       	eor	r0, r0
    32e8:	00 1c       	adc	r0, r0
    32ea:	0b be       	out	0x3b, r0	; 59
    32ec:	07 90       	elpm	r0, Z+
    32ee:	f6 91       	elpm	r31, Z
    32f0:	e0 2d       	mov	r30, r0
    32f2:	09 94       	ijmp

000032f4 <__muluhisi3>:
    32f4:	1d d0       	rcall	.+58     	; 0x3330 <__umulhisi3>
    32f6:	a5 9f       	mul	r26, r21
    32f8:	90 0d       	add	r25, r0
    32fa:	b4 9f       	mul	r27, r20
    32fc:	90 0d       	add	r25, r0
    32fe:	a4 9f       	mul	r26, r20
    3300:	80 0d       	add	r24, r0
    3302:	91 1d       	adc	r25, r1
    3304:	11 24       	eor	r1, r1
    3306:	08 95       	ret

00003308 <__udivmodhi4>:
    3308:	aa 1b       	sub	r26, r26
    330a:	bb 1b       	sub	r27, r27
    330c:	51 e1       	ldi	r21, 0x11	; 17
    330e:	07 c0       	rjmp	.+14     	; 0x331e <__udivmodhi4_ep>

00003310 <__udivmodhi4_loop>:
    3310:	aa 1f       	adc	r26, r26
    3312:	bb 1f       	adc	r27, r27
    3314:	a6 17       	cp	r26, r22
    3316:	b7 07       	cpc	r27, r23
    3318:	10 f0       	brcs	.+4      	; 0x331e <__udivmodhi4_ep>
    331a:	a6 1b       	sub	r26, r22
    331c:	b7 0b       	sbc	r27, r23

0000331e <__udivmodhi4_ep>:
    331e:	88 1f       	adc	r24, r24
    3320:	99 1f       	adc	r25, r25
    3322:	5a 95       	dec	r21
    3324:	a9 f7       	brne	.-22     	; 0x3310 <__udivmodhi4_loop>
    3326:	80 95       	com	r24
    3328:	90 95       	com	r25
    332a:	bc 01       	movw	r22, r24
    332c:	cd 01       	movw	r24, r26
    332e:	08 95       	ret

00003330 <__umulhisi3>:
    3330:	a2 9f       	mul	r26, r18
    3332:	b0 01       	movw	r22, r0
    3334:	b3 9f       	mul	r27, r19
    3336:	c0 01       	movw	r24, r0
    3338:	a3 9f       	mul	r26, r19
    333a:	70 0d       	add	r23, r0
    333c:	81 1d       	adc	r24, r1
    333e:	11 24       	eor	r1, r1
    3340:	91 1d       	adc	r25, r1
    3342:	b2 9f       	mul	r27, r18
    3344:	70 0d       	add	r23, r0
    3346:	81 1d       	adc	r24, r1
    3348:	11 24       	eor	r1, r1
    334a:	91 1d       	adc	r25, r1
    334c:	08 95       	ret

0000334e <memcpy>:
    334e:	fb 01       	movw	r30, r22
    3350:	dc 01       	movw	r26, r24
    3352:	02 c0       	rjmp	.+4      	; 0x3358 <memcpy+0xa>
    3354:	01 90       	ld	r0, Z+
    3356:	0d 92       	st	X+, r0
    3358:	41 50       	subi	r20, 0x01	; 1
    335a:	50 40       	sbci	r21, 0x00	; 0
    335c:	d8 f7       	brcc	.-10     	; 0x3354 <memcpy+0x6>
    335e:	08 95       	ret

00003360 <memset>:
    3360:	dc 01       	movw	r26, r24
    3362:	01 c0       	rjmp	.+2      	; 0x3366 <memset+0x6>
    3364:	6d 93       	st	X+, r22
    3366:	41 50       	subi	r20, 0x01	; 1
    3368:	50 40       	sbci	r21, 0x00	; 0
    336a:	e0 f7       	brcc	.-8      	; 0x3364 <memset+0x4>
    336c:	08 95       	ret

0000336e <strncpy>:
    336e:	fb 01       	movw	r30, r22
    3370:	dc 01       	movw	r26, r24
    3372:	41 50       	subi	r20, 0x01	; 1
    3374:	50 40       	sbci	r21, 0x00	; 0
    3376:	48 f0       	brcs	.+18     	; 0x338a <strncpy+0x1c>
    3378:	01 90       	ld	r0, Z+
    337a:	0d 92       	st	X+, r0
    337c:	00 20       	and	r0, r0
    337e:	c9 f7       	brne	.-14     	; 0x3372 <strncpy+0x4>
    3380:	01 c0       	rjmp	.+2      	; 0x3384 <strncpy+0x16>
    3382:	1d 92       	st	X+, r1
    3384:	41 50       	subi	r20, 0x01	; 1
    3386:	50 40       	sbci	r21, 0x00	; 0
    3388:	e0 f7       	brcc	.-8      	; 0x3382 <strncpy+0x14>
    338a:	08 95       	ret

0000338c <ultoa>:
    338c:	25 32       	cpi	r18, 0x25	; 37
    338e:	31 05       	cpc	r19, r1
    3390:	18 f4       	brcc	.+6      	; 0x3398 <ultoa+0xc>
    3392:	22 30       	cpi	r18, 0x02	; 2
    3394:	08 f0       	brcs	.+2      	; 0x3398 <ultoa+0xc>
    3396:	04 c0       	rjmp	.+8      	; 0x33a0 <__ultoa_ncheck>
    3398:	fa 01       	movw	r30, r20
    339a:	10 82       	st	Z, r1
    339c:	ca 01       	movw	r24, r20
    339e:	08 95       	ret

000033a0 <__ultoa_ncheck>:
    33a0:	bb 27       	eor	r27, r27

000033a2 <__ultoa_common>:
    33a2:	fa 01       	movw	r30, r20
    33a4:	a6 2f       	mov	r26, r22
    33a6:	62 17       	cp	r22, r18
    33a8:	71 05       	cpc	r23, r1
    33aa:	81 05       	cpc	r24, r1
    33ac:	91 05       	cpc	r25, r1
    33ae:	33 0b       	sbc	r19, r19
    33b0:	30 fb       	bst	r19, 0
    33b2:	66 f0       	brts	.+24     	; 0x33cc <__ultoa_common+0x2a>
    33b4:	aa 27       	eor	r26, r26
    33b6:	66 0f       	add	r22, r22
    33b8:	77 1f       	adc	r23, r23
    33ba:	88 1f       	adc	r24, r24
    33bc:	99 1f       	adc	r25, r25
    33be:	aa 1f       	adc	r26, r26
    33c0:	a2 17       	cp	r26, r18
    33c2:	10 f0       	brcs	.+4      	; 0x33c8 <__ultoa_common+0x26>
    33c4:	a2 1b       	sub	r26, r18
    33c6:	63 95       	inc	r22
    33c8:	38 50       	subi	r19, 0x08	; 8
    33ca:	a9 f7       	brne	.-22     	; 0x33b6 <__ultoa_common+0x14>
    33cc:	a0 5d       	subi	r26, 0xD0	; 208
    33ce:	aa 33       	cpi	r26, 0x3A	; 58
    33d0:	08 f0       	brcs	.+2      	; 0x33d4 <__ultoa_common+0x32>
    33d2:	a9 5d       	subi	r26, 0xD9	; 217
    33d4:	a1 93       	st	Z+, r26
    33d6:	36 f7       	brtc	.-52     	; 0x33a4 <__ultoa_common+0x2>
    33d8:	b1 11       	cpse	r27, r1
    33da:	b1 93       	st	Z+, r27
    33dc:	10 82       	st	Z, r1
    33de:	ca 01       	movw	r24, r20
    33e0:	23 c0       	rjmp	.+70     	; 0x3428 <strrev>

000033e2 <utoa>:
    33e2:	45 32       	cpi	r20, 0x25	; 37
    33e4:	51 05       	cpc	r21, r1
    33e6:	18 f4       	brcc	.+6      	; 0x33ee <utoa+0xc>
    33e8:	42 30       	cpi	r20, 0x02	; 2
    33ea:	08 f0       	brcs	.+2      	; 0x33ee <utoa+0xc>
    33ec:	04 c0       	rjmp	.+8      	; 0x33f6 <__utoa_ncheck>
    33ee:	fb 01       	movw	r30, r22
    33f0:	10 82       	st	Z, r1
    33f2:	cb 01       	movw	r24, r22
    33f4:	08 95       	ret

000033f6 <__utoa_ncheck>:
    33f6:	bb 27       	eor	r27, r27

000033f8 <__utoa_common>:
    33f8:	fb 01       	movw	r30, r22
    33fa:	55 27       	eor	r21, r21
    33fc:	aa 27       	eor	r26, r26
    33fe:	88 0f       	add	r24, r24
    3400:	99 1f       	adc	r25, r25
    3402:	aa 1f       	adc	r26, r26
    3404:	a4 17       	cp	r26, r20
    3406:	10 f0       	brcs	.+4      	; 0x340c <__utoa_common+0x14>
    3408:	a4 1b       	sub	r26, r20
    340a:	83 95       	inc	r24
    340c:	50 51       	subi	r21, 0x10	; 16
    340e:	b9 f7       	brne	.-18     	; 0x33fe <__utoa_common+0x6>
    3410:	a0 5d       	subi	r26, 0xD0	; 208
    3412:	aa 33       	cpi	r26, 0x3A	; 58
    3414:	08 f0       	brcs	.+2      	; 0x3418 <__utoa_common+0x20>
    3416:	a9 5d       	subi	r26, 0xD9	; 217
    3418:	a1 93       	st	Z+, r26
    341a:	00 97       	sbiw	r24, 0x00	; 0
    341c:	79 f7       	brne	.-34     	; 0x33fc <__utoa_common+0x4>
    341e:	b1 11       	cpse	r27, r1
    3420:	b1 93       	st	Z+, r27
    3422:	11 92       	st	Z+, r1
    3424:	cb 01       	movw	r24, r22
    3426:	00 c0       	rjmp	.+0      	; 0x3428 <strrev>

00003428 <strrev>:
    3428:	dc 01       	movw	r26, r24
    342a:	fc 01       	movw	r30, r24
    342c:	67 2f       	mov	r22, r23
    342e:	71 91       	ld	r23, Z+
    3430:	77 23       	and	r23, r23
    3432:	e1 f7       	brne	.-8      	; 0x342c <strrev+0x4>
    3434:	32 97       	sbiw	r30, 0x02	; 2
    3436:	04 c0       	rjmp	.+8      	; 0x3440 <strrev+0x18>
    3438:	7c 91       	ld	r23, X
    343a:	6d 93       	st	X+, r22
    343c:	70 83       	st	Z, r23
    343e:	62 91       	ld	r22, -Z
    3440:	ae 17       	cp	r26, r30
    3442:	bf 07       	cpc	r27, r31
    3444:	c8 f3       	brcs	.-14     	; 0x3438 <strrev+0x10>
    3446:	08 95       	ret

00003448 <_exit>:
    3448:	f8 94       	cli

0000344a <__stop_program>:
    344a:	ff cf       	rjmp	.-2      	; 0x344a <__stop_program>
